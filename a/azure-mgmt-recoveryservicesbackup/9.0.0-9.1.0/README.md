# Comparing `tmp/azure-mgmt-recoveryservicesbackup-9.0.0.tar.gz` & `tmp/azure-mgmt-recoveryservicesbackup-9.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "azure-mgmt-recoveryservicesbackup-9.0.0.tar", last modified: Wed Jan 24 03:06:17 2024, max compression
+gzip compressed data, was "azure-mgmt-recoveryservicesbackup-9.1.0.tar", last modified: Mon Apr 22 05:56:22 2024, max compression
```

## Comparing `azure-mgmt-recoveryservicesbackup-9.0.0.tar` & `azure-mgmt-recoveryservicesbackup-9.1.0.tar`

### file list

```diff
@@ -1,203 +1,201 @@
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.065756 azure-mgmt-recoveryservicesbackup-9.0.0/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    32457 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/CHANGELOG.md
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1074 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/LICENSE
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1086 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/LICENSE.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      228 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/MANIFEST.in
--rw-r--r--   0 cloudtest  (1000) cloudtest  (1000)    35624 2024-01-24 03:06:17.065756 azure-mgmt-recoveryservicesbackup-9.0.0/PKG-INFO
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2093 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/README.md
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      652 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/_meta.json
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.041756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       65 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.041756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       65 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.041756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      677 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      486 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.041756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      925 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3505 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3635 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24605 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_recovery_services_backup_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    79289 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1344 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_vendor.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      486 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.041756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      872 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3553 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2797 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24955 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_recovery_services_backup_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1084 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_vendor.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.049756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7061 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10328 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_engines_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6768 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_jobs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5285 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5349 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_operation_statuses_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6751 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_policies_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7043 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protectable_items_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6908 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protected_items_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6734 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protection_containers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6932 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protection_intent_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11386 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_encryption_configs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17635 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_storage_configs_non_crr_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18110 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_vault_configs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7675 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_status_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6869 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_usage_summaries_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7380 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_workload_items_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10054 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backups_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5464 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_bms_prepare_data_move_operation_result_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6757 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_deleted_protection_containers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5585 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_export_jobs_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8255 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_feature_support_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13924 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_fetch_tiering_cost_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5064 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_get_tiering_cost_operation_result_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15182 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_item_level_recovery_connections_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4916 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_cancellations_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4958 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_details_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5082 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4826 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_jobs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8684 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_operation_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5862 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23716 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_private_endpoint_connection_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5657 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_private_endpoint_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6888 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protectable_containers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5998 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_item_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6133 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_item_operation_statuses_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17789 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_items_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5799 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_container_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5214 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_container_refresh_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27796 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_containers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22327 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_intent_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18434 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policies_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5378 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policy_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5630 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policy_operation_statuses_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11330 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_points_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11806 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_points_recommended_for_move_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38559 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_services_backup_client_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6550 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_resource_guard_proxies_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21746 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_resource_guard_proxy_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15576 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_restores_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8379 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_security_pins_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5053 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_tiering_cost_operation_status_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13114 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5297 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5399 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_statuses_operations.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.049756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33890 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)  1118164 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_models_py3.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23920 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_recovery_services_backup_client_enums.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.057756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7061 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13540 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_engines_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8319 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_jobs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6682 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6739 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_operation_statuses_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8130 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_policies_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8593 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protectable_items_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8458 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protected_items_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8112 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protection_containers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8483 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protection_intent_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14219 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_encryption_configs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21916 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_storage_configs_non_crr_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22373 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_vault_configs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9022 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_status_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8419 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_usage_summaries_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9184 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_workload_items_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11994 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backups_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6880 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_bms_prepare_data_move_operation_result_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8141 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_deleted_protection_containers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6982 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_export_jobs_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9610 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_feature_support_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15386 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_fetch_tiering_cost_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6570 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_get_tiering_cost_operation_result_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19165 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_item_level_recovery_connections_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6296 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_cancellations_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6336 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_details_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6577 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6260 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_jobs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10197 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_operation_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6549 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28299 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_private_endpoint_connection_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7331 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_private_endpoint_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8410 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protectable_containers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7827 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_item_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7961 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_item_operation_statuses_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23267 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_items_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7460 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_container_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6702 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_container_refresh_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35748 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_containers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28353 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_intent_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22699 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policies_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6878 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policy_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7123 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policy_operation_statuses_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14954 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_points_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13682 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_points_recommended_for_move_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    44660 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_services_backup_client_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7796 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_resource_guard_proxies_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28036 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_resource_guard_proxy_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17515 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_restores_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9876 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_security_pins_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6563 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_tiering_cost_operation_status_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14472 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6700 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6803 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_statuses_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       26 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/py.typed
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.057756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      947 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3526 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3717 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8111 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_recovery_services_backup_passive_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    79289 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      778 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_vendor.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      486 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.057756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      894 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3574 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2864 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8287 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_recovery_services_backup_passive_client.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.061756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1951 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4876 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_aad_properties_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7612 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_crr_job_details_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10463 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_crr_jobs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6991 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_protected_items_crr_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17570 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_resource_storage_configs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6951 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_usage_summaries_crr_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12468 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_cross_region_restore_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4569 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_crr_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4729 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_crr_operation_status_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11397 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_recovery_points_crr_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10966 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_recovery_points_operations.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.061756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13473 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   476127 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_models_py3.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9909 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_recovery_services_backup_passive_client_enums.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.061756 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1951 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6164 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_aad_properties_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8971 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_crr_job_details_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12075 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_crr_jobs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8559 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_protected_items_crr_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21880 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_resource_storage_configs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8518 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_usage_summaries_crr_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13671 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_cross_region_restore_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5842 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_crr_operation_results_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6003 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_crr_operation_status_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15039 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_recovery_points_crr_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13076 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_recovery_points_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       26 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/py.typed
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-01-24 03:06:17.065756 azure-mgmt-recoveryservicesbackup-9.0.0/azure_mgmt_recoveryservicesbackup.egg-info/
--rw-r--r--   0 cloudtest  (1000) cloudtest  (1000)    35624 2024-01-24 03:06:16.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure_mgmt_recoveryservicesbackup.egg-info/PKG-INFO
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15830 2024-01-24 03:06:17.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure_mgmt_recoveryservicesbackup.egg-info/SOURCES.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2024-01-24 03:06:16.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure_mgmt_recoveryservicesbackup.egg-info/dependency_links.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2024-01-24 03:06:16.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure_mgmt_recoveryservicesbackup.egg-info/not-zip-safe
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       70 2024-01-24 03:06:16.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure_mgmt_recoveryservicesbackup.egg-info/requires.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        6 2024-01-24 03:06:16.000000 azure-mgmt-recoveryservicesbackup-9.0.0/azure_mgmt_recoveryservicesbackup.egg-info/top_level.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       38 2024-01-24 03:06:17.065756 azure-mgmt-recoveryservicesbackup-9.0.0/setup.cfg
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2826 2024-01-24 03:05:36.000000 azure-mgmt-recoveryservicesbackup-9.0.0/setup.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:22.011601 azure-mgmt-recoveryservicesbackup-9.1.0/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33812 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/CHANGELOG.md
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1074 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/LICENSE
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1086 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/LICENSE.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      228 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/MANIFEST.in
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36864 2024-04-22 05:56:22.011601 azure-mgmt-recoveryservicesbackup-9.1.0/PKG-INFO
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2093 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/README.md
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      654 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/_meta.json
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:21.975601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       65 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:21.975601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       65 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:21.975601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      677 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      486 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:21.975601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      925 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3438 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3635 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25657 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_recovery_services_backup_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    78873 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1344 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_vendor.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      486 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:21.979601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      872 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3486 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2797 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26031 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_recovery_services_backup_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1084 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_vendor.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:21.987601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7061 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9711 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_engines_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6465 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_jobs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4974 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5060 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_operation_statuses_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6444 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_policies_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6728 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protectable_items_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6595 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protected_items_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6415 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protection_containers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6616 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protection_intent_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10425 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_encryption_configs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16059 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_storage_configs_non_crr_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17779 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_vault_configs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7108 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_status_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6556 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_usage_summaries_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7018 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_workload_items_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9340 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backups_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5169 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_bms_prepare_data_move_operation_result_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6431 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_deleted_protection_containers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5253 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_export_jobs_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7668 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_feature_support_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11513 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_fetch_tiering_cost_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4749 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_get_tiering_cost_operation_result_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13951 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_item_level_recovery_connections_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4606 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_cancellations_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4679 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_details_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4756 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4529 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_jobs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8075 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_operation_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5658 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19820 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_private_endpoint_connection_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5275 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_private_endpoint_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6547 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protectable_containers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5610 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_item_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5745 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_item_operation_statuses_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16903 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_items_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5479 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_container_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4915 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_container_refresh_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23920 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_containers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20329 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_intent_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17019 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policies_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5094 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policy_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5352 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policy_operation_statuses_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10514 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_points_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11089 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_points_recommended_for_move_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    30333 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_services_backup_client_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6233 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_resource_guard_proxies_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19748 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_resource_guard_proxy_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13620 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_restores_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8385 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_security_pins_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4738 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_tiering_cost_operation_status_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10651 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4994 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5094 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_statuses_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:21.991601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34009 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)  1126762 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_models_py3.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24071 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_recovery_services_backup_client_enums.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:22.003601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7061 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12923 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_engines_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8016 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_jobs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6371 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6450 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_operation_statuses_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7823 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_policies_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8278 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protectable_items_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8145 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protected_items_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7793 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protection_containers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8167 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protection_intent_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13258 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_encryption_configs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20340 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_storage_configs_non_crr_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22624 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_vault_configs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8455 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_status_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8106 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_usage_summaries_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8822 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_workload_items_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11280 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backups_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6585 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_bms_prepare_data_move_operation_result_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7815 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_deleted_protection_containers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6650 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_export_jobs_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9023 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_feature_support_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13005 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_fetch_tiering_cost_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6255 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_get_tiering_cost_operation_result_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17934 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_item_level_recovery_connections_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5986 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_cancellations_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6057 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_details_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6251 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5963 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_jobs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9588 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_operation_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6345 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24443 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_private_endpoint_connection_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6949 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_private_endpoint_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8069 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protectable_containers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7439 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_item_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7573 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_item_operation_statuses_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22654 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_items_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7140 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_container_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6403 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_container_refresh_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31902 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_containers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26355 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_intent_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21583 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policies_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6594 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policy_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6845 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policy_operation_statuses_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14138 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_points_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12965 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_points_recommended_for_move_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36524 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_services_backup_client_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7479 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_resource_guard_proxies_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26038 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_resource_guard_proxy_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15862 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_restores_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10173 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_security_pins_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6248 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_tiering_cost_operation_status_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12039 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6397 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6498 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_statuses_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:22.003601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      947 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3452 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3717 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9163 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_recovery_services_backup_passive_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    78873 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      778 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_vendor.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      486 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:22.003601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      894 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3500 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2864 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9363 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_recovery_services_backup_passive_client.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:22.007601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1951 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4628 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_aad_properties_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7063 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_crr_job_details_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9870 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_crr_jobs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6677 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_protected_items_crr_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15979 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_resource_storage_configs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6638 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_usage_summaries_crr_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10068 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_cross_region_restore_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4285 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_crr_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4461 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_crr_operation_status_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10580 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_recovery_points_crr_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10212 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_recovery_points_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:22.007601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13473 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   475786 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_models_py3.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9909 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_recovery_services_backup_passive_client_enums.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:22.011601 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1951 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5916 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_aad_properties_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8422 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_crr_job_details_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11482 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_crr_jobs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8245 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_protected_items_crr_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20289 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_resource_storage_configs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8205 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_usage_summaries_crr_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11301 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_cross_region_restore_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5558 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_crr_operation_results_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5735 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_crr_operation_status_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14222 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_recovery_points_crr_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12322 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_recovery_points_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-22 05:56:22.011601 azure-mgmt-recoveryservicesbackup-9.1.0/azure_mgmt_recoveryservicesbackup.egg-info/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36864 2024-04-22 05:56:21.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure_mgmt_recoveryservicesbackup.egg-info/PKG-INFO
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15719 2024-04-22 05:56:21.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure_mgmt_recoveryservicesbackup.egg-info/SOURCES.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2024-04-22 05:56:21.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure_mgmt_recoveryservicesbackup.egg-info/dependency_links.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2024-04-22 05:56:21.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure_mgmt_recoveryservicesbackup.egg-info/not-zip-safe
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       56 2024-04-22 05:56:21.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure_mgmt_recoveryservicesbackup.egg-info/requires.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        6 2024-04-22 05:56:21.000000 azure-mgmt-recoveryservicesbackup-9.1.0/azure_mgmt_recoveryservicesbackup.egg-info/top_level.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       38 2024-04-22 05:56:22.011601 azure-mgmt-recoveryservicesbackup-9.1.0/setup.cfg
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2812 2024-04-22 05:55:04.000000 azure-mgmt-recoveryservicesbackup-9.1.0/setup.py
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/CHANGELOG.md` & `azure-mgmt-recoveryservicesbackup-9.1.0/CHANGELOG.md`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,26 @@
 # Release History
 
+## 9.1.0 (2024-04-22)
+
+### Features Added
+
+  - Model AzureIaaSVMProtectionPolicy has a new parameter snapshot_consistency_type
+  - Model AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model AzureWorkloadSAPHanaRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model AzureWorkloadSQLRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model IaasVMRestoreWithRehydrationRequest has a new parameter resource_guard_operation_requests
+  - Operation BackupResourceVaultConfigsOperations.put has a new optional parameter x_ms_authorization_auxiliary
+  - Operation BackupResourceVaultConfigsOperations.update has a new optional parameter x_ms_authorization_auxiliary
+  - Operation ProtectedItemsOperations.create_or_update has a new optional parameter x_ms_authorization_auxiliary
+  - Operation ProtectionPoliciesOperations.create_or_update has a new optional parameter x_ms_authorization_auxiliary
+  - Operation RestoresOperations.begin_trigger has a new optional parameter x_ms_authorization_auxiliary
+  - Operation SecurityPINsOperations.get has a new optional parameter x_ms_authorization_auxiliary
+
 ## 9.0.0 (2024-01-24)
 
 ### Features Added
 
   - Added operation group FetchTieringCostOperations
   - Added operation group GetTieringCostOperationResultOperations
   - Added operation group TieringCostOperationStatusOperations
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/LICENSE` & `azure-mgmt-recoveryservicesbackup-9.1.0/LICENSE`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/LICENSE.txt` & `azure-mgmt-recoveryservicesbackup-9.1.0/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/PKG-INFO` & `azure-mgmt-recoveryservicesbackup-9.1.0/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-recoveryservicesbackup
-Version: 9.0.0
+Version: 9.1.0
 Summary: Microsoft Azure Recovery Services Backup Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 5 - Production/Stable
@@ -17,17 +17,14 @@
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
 Classifier: License :: OSI Approved :: MIT License
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 License-File: LICENSE
 License-File: LICENSE.txt
-Requires-Dist: isodate<1.0.0,>=0.6.1
-Requires-Dist: azure-common~=1.1
-Requires-Dist: azure-mgmt-core<2.0.0,>=1.3.2
 
 # Microsoft Azure SDK for Python
 
 This is the Microsoft Azure Recovery Services Backup Management Client Library.
 This package has been tested with Python 3.8+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
@@ -86,14 +83,31 @@
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 # Release History
 
+## 9.1.0 (2024-04-22)
+
+### Features Added
+
+  - Model AzureIaaSVMProtectionPolicy has a new parameter snapshot_consistency_type
+  - Model AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model AzureWorkloadSAPHanaRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model AzureWorkloadSQLRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model IaasVMRestoreWithRehydrationRequest has a new parameter resource_guard_operation_requests
+  - Operation BackupResourceVaultConfigsOperations.put has a new optional parameter x_ms_authorization_auxiliary
+  - Operation BackupResourceVaultConfigsOperations.update has a new optional parameter x_ms_authorization_auxiliary
+  - Operation ProtectedItemsOperations.create_or_update has a new optional parameter x_ms_authorization_auxiliary
+  - Operation ProtectionPoliciesOperations.create_or_update has a new optional parameter x_ms_authorization_auxiliary
+  - Operation RestoresOperations.begin_trigger has a new optional parameter x_ms_authorization_auxiliary
+  - Operation SecurityPINsOperations.get has a new optional parameter x_ms_authorization_auxiliary
+
 ## 9.0.0 (2024-01-24)
 
 ### Features Added
 
   - Added operation group FetchTieringCostOperations
   - Added operation group GetTieringCostOperationResultOperations
   - Added operation group TieringCostOperationStatusOperations
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/README.md` & `azure-mgmt-recoveryservicesbackup-9.1.0/README.md`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/_meta.json` & `azure-mgmt-recoveryservicesbackup-9.1.0/_meta.json`

 * *Files 8% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.75%*

 * *Differences: {"'autorest_command'": "'autorest specification/recoveryservicesbackup/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.13.7 --use=@autorest/modelerfour@4.27.0 '*

 * *                       "--version=3.9.7 --version-tolerant=False'",*

 * * "'commit'": "'2897e4040dd3d922061ae55bc002358aeaded619'",*

 * * "' […]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.7",
-    "autorest_command": "autorest specification/recoveryservicesbackup/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.7.1 --use=@autorest/modelerfour@4.26.2 --version=3.9.7 --version-tolerant=False",
-    "commit": "51a6e410cf9752dfdaad71f0f9778645d737d8c4",
+    "autorest_command": "autorest specification/recoveryservicesbackup/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.13.7 --use=@autorest/modelerfour@4.27.0 --version=3.9.7 --version-tolerant=False",
+    "commit": "2897e4040dd3d922061ae55bc002358aeaded619",
     "readme": "specification/recoveryservicesbackup/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.7.1",
-        "@autorest/modelerfour@4.26.2"
+        "@autorest/python@6.13.7",
+        "@autorest/modelerfour@4.27.0"
     ]
 }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_configuration.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_configuration.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,63 +4,62 @@
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, TYPE_CHECKING
 
-from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
-class RecoveryServicesBackupClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
+class RecoveryServicesBackupClientConfiguration:  # pylint: disable=too-many-instance-attributes,name-too-long
     """Configuration for RecoveryServicesBackupClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2023-06-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2024-04-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
-        super(RecoveryServicesBackupClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2023-06-01")
+        api_version: str = kwargs.pop("api_version", "2024-04-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
         self.subscription_id = subscription_id
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-recoveryservicesbackup/{}".format(VERSION))
+        self.polling_interval = kwargs.get("polling_interval", 30)
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
         self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
             self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_recovery_services_backup_client.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_recovery_services_backup_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,16 +5,18 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
 from typing import Any, TYPE_CHECKING
 
+from azure.core.pipeline import policies
 from azure.core.rest import HttpRequest, HttpResponse
 from azure.mgmt.core import ARMPipelineClient
+from azure.mgmt.core.policies import ARMAutoResourceProviderRegistrationPolicy
 
 from . import models as _models
 from ._configuration import RecoveryServicesBackupClientConfiguration
 from ._serialization import Deserializer, Serializer
 from .operations import (
     BMSPrepareDataMoveOperationResultOperations,
     BackupEnginesOperations,
@@ -242,15 +244,15 @@
      azure.mgmt.recoveryservicesbackup.activestamp.operations.TieringCostOperationStatusOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The subscription Id. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2023-06-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2024-04-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -259,15 +261,33 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = RecoveryServicesBackupClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        _policies = kwargs.pop("policies", None)
+        if _policies is None:
+            _policies = [
+                policies.RequestIdPolicy(**kwargs),
+                self._config.headers_policy,
+                self._config.user_agent_policy,
+                self._config.proxy_policy,
+                policies.ContentDecodePolicy(**kwargs),
+                ARMAutoResourceProviderRegistrationPolicy(),
+                self._config.redirect_policy,
+                self._config.retry_policy,
+                self._config.authentication_policy,
+                self._config.custom_hook_policy,
+                self._config.logging_policy,
+                policies.DistributedTracingPolicy(**kwargs),
+                policies.SensitiveHeaderCleanupPolicy(**kwargs) if self._config.redirect_policy else None,
+                self._config.http_logging_policy,
+            ]
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, policies=_policies, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.backup_resource_storage_configs_non_crr = BackupResourceStorageConfigsNonCRROperations(
             self._client, self._config, self._serialize, self._deserialize
@@ -394,15 +414,15 @@
         self.get_tiering_cost_operation_result = GetTieringCostOperationResultOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.tiering_cost_operation_status = TieringCostOperationStatusOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
 
-    def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
+    def _send_request(self, request: HttpRequest, *, stream: bool = False, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
         >>> response = client._send_request(request)
         <HttpResponse: 200 OK>
@@ -414,15 +434,15 @@
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
-        return self._client.send_request(request_copy, **kwargs)
+        return self._client.send_request(request_copy, stream=stream, **kwargs)  # type: ignore
 
     def close(self) -> None:
         self._client.close()
 
     def __enter__(self) -> "RecoveryServicesBackupClient":
         self._client.__enter__()
         return self
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_serialization.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -59,16 +59,16 @@
     from urllib import quote  # type: ignore
 except ImportError:
     from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
 import isodate  # type: ignore
 
-from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
-from azure.core.serialization import NULL as AzureCoreNull
+from azure.core.exceptions import DeserializationError, SerializationError
+from azure.core.serialization import NULL as CoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
 ModelType = TypeVar("ModelType", bound="Model")
 JSON = MutableMapping[str, Any]
 
 
@@ -120,15 +120,15 @@
                     if isinstance(data, unicode):  # type: ignore
                         # If I'm Python 2.7 and unicode XML will scream if I try a "fromstring" on unicode string
                         data_as_str = data_as_str.encode(encoding="utf-8")  # type: ignore
                 except NameError:
                     pass
 
                 return ET.fromstring(data_as_str)  # nosec
-            except ET.ParseError:
+            except ET.ParseError as err:
                 # It might be because the server has an issue, and returned JSON with
                 # content-type XML....
                 # So let's try a JSON load, and if it's still broken
                 # let's flow the initial exception
                 def _json_attemp(data):
                     try:
                         return True, json.loads(data)
@@ -139,15 +139,15 @@
                 if success:
                     return json_result
                 # If i'm here, it's not JSON, it's not XML, let's scream
                 # and raise the last context in this block (the XML exception)
                 # The function hack is because Py2.7 messes up with exception
                 # context otherwise.
                 _LOGGER.critical("Wasn't XML not JSON, failing")
-                raise_with_traceback(DeserializationError, "XML is invalid")
+                raise DeserializationError("XML is invalid") from err
         raise DeserializationError("Cannot deserialize content-type: {}".format(content_type))
 
     @classmethod
     def deserialize_from_http_generics(cls, body_bytes: Optional[Union[AnyStr, IO]], headers: Mapping) -> Any:
         """Deserialize from HTTP response.
 
         Use bytes and headers to NOT use any requests/aiohttp or whatever
@@ -166,21 +166,14 @@
             content_type = "application/json"
 
         if body_bytes:
             return cls.deserialize_from_text(body_bytes, content_type)
         return None
 
 
-try:
-    basestring  # type: ignore
-    unicode_str = unicode  # type: ignore
-except NameError:
-    basestring = str
-    unicode_str = str
-
 _LOGGER = logging.getLogger(__name__)
 
 try:
     _long_type = long  # type: ignore
 except NameError:
     _long_type = int
 
@@ -291,15 +284,15 @@
     """
 
     _subtype_map: Dict[str, Dict[str, Any]] = {}
     _attribute_map: Dict[str, Dict[str, Any]] = {}
     _validation: Dict[str, Dict[str, Any]] = {}
 
     def __init__(self, **kwargs: Any) -> None:
-        self.additional_properties: Dict[str, Any] = {}
+        self.additional_properties: Optional[Dict[str, Any]] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
@@ -336,26 +329,26 @@
             xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
     def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
-        """Return the JSON that would be sent to azure from this model.
+        """Return the JSON that would be sent to server from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
-        return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
+        return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)  # type: ignore
 
     def as_dict(
         self,
         keep_readonly: bool = True,
         key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
         **kwargs: Any
     ) -> JSON:
@@ -386,15 +379,15 @@
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param function key_transformer: A key transformer function.
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
-        return serializer._serialize(self, key_transformer=key_transformer, keep_readonly=keep_readonly, **kwargs)
+        return serializer._serialize(self, key_transformer=key_transformer, keep_readonly=keep_readonly, **kwargs)  # type: ignore
 
     @classmethod
     def _infer_class_models(cls):
         try:
             str_models = cls.__module__.rsplit(".", 1)[0]
             models = sys.modules[str_models]
             client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
@@ -411,15 +404,15 @@
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        return deserializer(cls.__name__, data, content_type=content_type)
+        return deserializer(cls.__name__, data, content_type=content_type)  # type: ignore
 
     @classmethod
     def from_dict(
         cls: Type[ModelType],
         data: Any,
         key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
         content_type: Optional[str] = None,
@@ -441,15 +434,15 @@
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
-        return deserializer(cls.__name__, data, content_type=content_type)
+        return deserializer(cls.__name__, data, content_type=content_type)  # type: ignore
 
     @classmethod
     def _flatten_subtype(cls, key, objects):
         if "_subtype_map" not in cls.__dict__:
             return {}
         result = dict(cls._subtype_map[key])
         for valuetype in cls._subtype_map[key].values():
@@ -541,15 +534,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes: Optional[Mapping[str, type]] = None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -557,15 +550,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies: Dict[str, type] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -645,15 +638,15 @@
                                     new_attr.tag = "}".join([splitted_tag[0], xml_name])
                                 else:
                                     new_attr.tag = xml_name
                             serialized.append(new_attr)  # type: ignore
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
-                            local_node.text = unicode_str(new_attr)
+                            local_node.text = str(new_attr)
                             serialized.append(local_node)  # type: ignore
                     else:  # JSON
                         for k in reversed(keys):  # type: ignore
                             new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
@@ -664,15 +657,15 @@
                             _serialized = _serialized[k]
                 except ValueError as err:
                     if isinstance(err, SerializationError):
                         raise
 
         except (AttributeError, KeyError, TypeError) as err:
             msg = "Attribute {} in object {} cannot be serialized.\n{}".format(attr_name, class_name, str(target_obj))
-            raise_with_traceback(SerializationError, msg, err)
+            raise SerializationError(msg) from err
         else:
             return serialized
 
     def body(self, data, data_type, **kwargs):
         """Serialize data intended for a request body.
 
         :param data: The data to be serialized.
@@ -706,15 +699,15 @@
                     deserializer.key_extractors = [
                         rest_key_case_insensitive_extractor,
                         attribute_key_case_insensitive_extractor,
                         last_rest_key_case_insensitive_extractor,
                     ]
                 data = deserializer._deserialize(data_type, data)
             except DeserializationError as err:
-                raise_with_traceback(SerializationError, "Unable to build a model: " + str(err), err)
+                raise SerializationError("Unable to build a model: " + str(err)) from err
 
         return self._serialize(data, data_type, **kwargs)
 
     def url(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL path.
 
         :param data: The data to be serialized.
@@ -726,38 +719,39 @@
         try:
             output = self.serialize_data(data, data_type, **kwargs)
             if data_type == "bool":
                 output = json.dumps(output)
 
             if kwargs.get("skip_quote") is True:
                 output = str(output)
+                output = output.replace("{", quote("{")).replace("}", quote("}"))
             else:
                 output = quote(str(output), safe="")
         except SerializationError:
             raise TypeError("{} must be type {}.".format(name, data_type))
         else:
             return output
 
     def query(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL query.
 
         :param data: The data to be serialized.
         :param str data_type: The type to be serialized from.
         :keyword bool skip_quote: Whether to skip quote the serialized result.
         Defaults to False.
-        :rtype: str
+        :rtype: str, list
         :raises: TypeError if serialization fails.
         :raises: ValueError if data is None
         """
         try:
             # Treat the list aside, since we don't want to encode the div separator
             if data_type.startswith("["):
                 internal_data_type = data_type[1:-1]
                 do_quote = not kwargs.get("skip_quote", False)
-                return str(self.serialize_iter(data, internal_data_type, do_quote=do_quote, **kwargs))
+                return self.serialize_iter(data, internal_data_type, do_quote=do_quote, **kwargs)
 
             # Not a list, regular serialization
             output = self.serialize_data(data, data_type, **kwargs)
             if data_type == "bool":
                 output = json.dumps(output)
             if kwargs.get("skip_quote") is True:
                 output = str(output)
@@ -800,15 +794,15 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
-            if data is AzureCoreNull:
+            if data is CoreNull:
                 return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
@@ -820,15 +814,15 @@
 
             iter_type = data_type[0] + data_type[-1]
             if iter_type in self.serialize_type:
                 return self.serialize_type[iter_type](data, data_type[1:-1], **kwargs)
 
         except (ValueError, TypeError) as err:
             msg = "Unable to serialize value: {!r} as type: {!r}."
-            raise_with_traceback(SerializationError, msg.format(data, data_type), err)
+            raise SerializationError(msg.format(data, data_type)) from err
         else:
             return self._serialize(data, **kwargs)
 
     @classmethod
     def _get_custom_serializers(cls, data_type, **kwargs):
         custom_serializer = kwargs.get("basic_types_serializers", {}).get(data_type)
         if custom_serializer:
@@ -989,15 +983,15 @@
         if isinstance(attr, ET.Element):
             return attr
         obj_type = type(attr)
         if obj_type in self.basic_types:
             return self.serialize_basic(attr, self.basic_types[obj_type], **kwargs)
         if obj_type is _long_type:
             return self.serialize_long(attr)
-        if obj_type is unicode_str:
+        if obj_type is str:
             return self.serialize_unicode(attr)
         if obj_type is datetime.datetime:
             return self.serialize_iso(attr)
         if obj_type is datetime.date:
             return self.serialize_date(attr)
         if obj_type is datetime.time:
             return self.serialize_time(attr)
@@ -1166,18 +1160,18 @@
                 microseconds = "." + microseconds
             date = "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}".format(
                 utc.tm_year, utc.tm_mon, utc.tm_mday, utc.tm_hour, utc.tm_min, utc.tm_sec
             )
             return date + microseconds + "Z"
         except (ValueError, OverflowError) as err:
             msg = "Unable to serialize datetime object."
-            raise_with_traceback(SerializationError, msg, err)
+            raise SerializationError(msg) from err
         except AttributeError as err:
             msg = "ISO-8601 object must be valid Datetime object."
-            raise_with_traceback(TypeError, msg, err)
+            raise TypeError(msg) from err
 
     @staticmethod
     def serialize_unix(attr, **kwargs):
         """Serialize Datetime object into IntTime format.
         This is represented as seconds.
 
         :param Datetime attr: Object to be serialized.
@@ -1205,15 +1199,14 @@
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
-            # https://github.com/Azure/msrest-for-python/issues/197
             return None
         key = ".".join(dict_keys[1:])
 
     return working_data.get(key)
 
 
 def rest_key_case_insensitive_extractor(attr, attr_desc, data):
@@ -1226,15 +1219,14 @@
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = attribute_key_case_insensitive_extractor(working_key, None, working_data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
-            # https://github.com/Azure/msrest-for-python/issues/197
             return None
         key = ".".join(dict_keys[1:])
 
     if working_data:
         return attribute_key_case_insensitive_extractor(key, None, working_data)
 
 
@@ -1367,15 +1359,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes: Optional[Mapping[str, type]] = None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1387,15 +1379,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies: Dict[str, type] = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1440,15 +1432,15 @@
                     setattr(data, attr, self._deserialize(local_type, value))
                 return data
             except AttributeError:
                 return
 
         response, class_name = self._classify_target(target_obj, data)
 
-        if isinstance(response, basestring):
+        if isinstance(response, str):
             return self.deserialize_data(data, response)
         elif isinstance(response, type) and issubclass(response, Enum):
             return self.deserialize_enum(data, response)
 
         if data is None:
             return data
         try:
@@ -1477,15 +1469,15 @@
                             continue
                         raw_value = found_value
 
                 value = self.deserialize_data(raw_value, attr_desc["type"])
                 d_attrs[attr] = value
         except (AttributeError, TypeError, KeyError) as err:
             msg = "Unable to deserialize to object: " + class_name  # type: ignore
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             additional_properties = self._build_additional_properties(attributes, data)
             return self._instantiate_model(response, d_attrs, additional_properties)
 
     def _build_additional_properties(self, attribute_map, data):
         if not self.additional_properties_detection:
             return None
@@ -1511,22 +1503,22 @@
 
         :param str target: The target object type to deserialize to.
         :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
-        if isinstance(target, basestring):
+        if isinstance(target, str):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
-            target = target._classify(data, self.dependencies)
+            target = target._classify(data, self.dependencies)  # type: ignore
         except AttributeError:
             pass  # Target is not a Model, no classify
         return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
@@ -1574,15 +1566,15 @@
         if hasattr(raw_data, "body"):
             return RawDeserializer.deserialize_from_http_generics(raw_data.text(), raw_data.headers)
 
         # Assume this enough to recognize requests.Response without importing it.
         if hasattr(raw_data, "_content_consumed"):
             return RawDeserializer.deserialize_from_http_generics(raw_data.text, raw_data.headers)
 
-        if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, "read"):
+        if isinstance(raw_data, (str, bytes)) or hasattr(raw_data, "read"):
             return RawDeserializer.deserialize_from_text(raw_data, content_type)  # type: ignore
         return raw_data
 
     def _instantiate_model(self, response, attrs, additional_properties=None):
         """Instantiate a response model passing in deserialized args.
 
         :param response: The response model class.
@@ -1648,15 +1640,15 @@
                 if isinstance(data, ET.Element):
                     data = data.text
                 return self.deserialize_enum(data, obj_type)
 
         except (ValueError, TypeError, AttributeError) as err:
             msg = "Unable to deserialize response data."
             msg += " Data: {}, {}".format(data, data_type)
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return self._deserialize(obj_type, data)
 
     def deserialize_iter(self, attr, iter_type):
         """Deserialize an iterable.
 
         :param list attr: Iterable to be deserialized.
@@ -1696,15 +1688,15 @@
         :raises: TypeError if non-builtin datatype encountered.
         """
         if attr is None:
             return None
         if isinstance(attr, ET.Element):
             # Do no recurse on XML, just return the tree as-is
             return attr
-        if isinstance(attr, basestring):
+        if isinstance(attr, str):
             return self.deserialize_basic(attr, "str")
         obj_type = type(attr)
         if obj_type in self.basic_types:
             return self.deserialize_basic(attr, self.basic_types[obj_type])
         if obj_type is _long_type:
             return self.deserialize_long(attr)
 
@@ -1753,15 +1745,15 @@
                     # None or '', node <a/> with a strong type is None.
                     # Don't try to model "empty bool" or "empty int"
                     return None
 
         if data_type == "bool":
             if attr in [True, False, 1, 0]:
                 return bool(attr)
-            elif isinstance(attr, basestring):
+            elif isinstance(attr, str):
                 if attr.lower() in ["true", "1"]:
                     return True
                 elif attr.lower() in ["false", "0"]:
                     return False
             raise TypeError("Invalid boolean value: {}".format(attr))
 
         if data_type == "str":
@@ -1804,15 +1796,14 @@
         """
         if isinstance(data, enum_obj) or data is None:
             return data
         if isinstance(data, Enum):
             data = data.value
         if isinstance(data, int):
             # Workaround. We might consider remove it in the future.
-            # https://github.com/Azure/azure-rest-api-specs/issues/141
             try:
                 return list(enum_obj.__members__.values())[data]
             except IndexError:
                 error = "{!r} is not a valid index for enum {!r}"
                 raise DeserializationError(error.format(data, enum_obj))
         try:
             return enum_obj(str(data))
@@ -1858,18 +1849,18 @@
         :param str attr: response string to be deserialized.
         :rtype: Decimal
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            return decimal.Decimal(attr)  # type: ignore
+            return decimal.Decimal(str(attr))  # type: ignore
         except decimal.DecimalException as err:
             msg = "Invalid decimal {}".format(attr)
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
 
     @staticmethod
     def deserialize_long(attr):
         """Deserialize string into long (Py2) or int (Py3).
 
         :param str attr: response string to be deserialized.
         :rtype: long or int
@@ -1889,15 +1880,15 @@
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
             duration = isodate.parse_duration(attr)
         except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize duration object."
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return duration
 
     @staticmethod
     def deserialize_date(attr):
         """Deserialize ISO-8601 formatted string into Date object.
 
@@ -1906,15 +1897,15 @@
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         # This must NOT use defaultmonth/defaultday. Using None ensure this raises an exception.
-        return isodate.parse_date(attr, defaultmonth=None, defaultday=None)
+        return isodate.parse_date(attr, defaultmonth=0, defaultday=0)
 
     @staticmethod
     def deserialize_time(attr):
         """Deserialize ISO-8601 formatted string into time object.
 
         :param str attr: response string to be deserialized.
         :rtype: datetime.time
@@ -1941,15 +1932,15 @@
             date_obj = datetime.datetime(
                 *parsed_date[:6], tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0) / 60))
             )
             if not date_obj.tzinfo:
                 date_obj = date_obj.astimezone(tz=TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to rfc datetime object."
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return date_obj
 
     @staticmethod
     def deserialize_iso(attr):
         """Deserialize ISO-8601 formatted string into Datetime object.
 
@@ -1978,15 +1969,15 @@
 
             date_obj = isodate.parse_datetime(attr)
             test_utc = date_obj.utctimetuple()
             if test_utc.tm_year > 9999 or test_utc.tm_year < 1:
                 raise OverflowError("Hit max or min date")
         except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize datetime object."
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return date_obj
 
     @staticmethod
     def deserialize_unix(attr):
         """Serialize Datetime object into IntTime format.
         This is represented as seconds.
@@ -1994,13 +1985,14 @@
         :param int attr: Object to be serialized.
         :rtype: Datetime
         :raises: DeserializationError if format invalid
         """
         if isinstance(attr, ET.Element):
             attr = int(attr.text)  # type: ignore
         try:
+            attr = int(attr)
             date_obj = datetime.datetime.fromtimestamp(attr, TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to unix datetime object."
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return date_obj
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/_vendor.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/_vendor.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_configuration.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_configuration.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,63 +4,62 @@
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, TYPE_CHECKING
 
-from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
-class RecoveryServicesBackupClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
+class RecoveryServicesBackupClientConfiguration:  # pylint: disable=too-many-instance-attributes,name-too-long
     """Configuration for RecoveryServicesBackupClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2023-06-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2024-04-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
-        super(RecoveryServicesBackupClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2023-06-01")
+        api_version: str = kwargs.pop("api_version", "2024-04-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
         self.subscription_id = subscription_id
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-recoveryservicesbackup/{}".format(VERSION))
+        self.polling_interval = kwargs.get("polling_interval", 30)
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
         self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
             self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_recovery_services_backup_client.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_recovery_services_backup_client.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,16 +5,18 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
 from typing import Any, Awaitable, TYPE_CHECKING
 
+from azure.core.pipeline import policies
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 from azure.mgmt.core import AsyncARMPipelineClient
+from azure.mgmt.core.policies import AsyncARMAutoResourceProviderRegistrationPolicy
 
 from .. import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import RecoveryServicesBackupClientConfiguration
 from .operations import (
     BMSPrepareDataMoveOperationResultOperations,
     BackupEnginesOperations,
@@ -244,15 +246,15 @@
      azure.mgmt.recoveryservicesbackup.activestamp.aio.operations.TieringCostOperationStatusOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The subscription Id. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2023-06-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2024-04-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -261,15 +263,33 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = RecoveryServicesBackupClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        _policies = kwargs.pop("policies", None)
+        if _policies is None:
+            _policies = [
+                policies.RequestIdPolicy(**kwargs),
+                self._config.headers_policy,
+                self._config.user_agent_policy,
+                self._config.proxy_policy,
+                policies.ContentDecodePolicy(**kwargs),
+                AsyncARMAutoResourceProviderRegistrationPolicy(),
+                self._config.redirect_policy,
+                self._config.retry_policy,
+                self._config.authentication_policy,
+                self._config.custom_hook_policy,
+                self._config.logging_policy,
+                policies.DistributedTracingPolicy(**kwargs),
+                policies.SensitiveHeaderCleanupPolicy(**kwargs) if self._config.redirect_policy else None,
+                self._config.http_logging_policy,
+            ]
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, policies=_policies, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.backup_resource_storage_configs_non_crr = BackupResourceStorageConfigsNonCRROperations(
             self._client, self._config, self._serialize, self._deserialize
@@ -396,15 +416,17 @@
         self.get_tiering_cost_operation_result = GetTieringCostOperationResultOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.tiering_cost_operation_status = TieringCostOperationStatusOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
 
-    def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
+    def _send_request(
+        self, request: HttpRequest, *, stream: bool = False, **kwargs: Any
+    ) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
         >>> response = await client._send_request(request)
         <AsyncHttpResponse: 200 OK>
@@ -416,15 +438,15 @@
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
         :rtype: ~azure.core.rest.AsyncHttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
-        return self._client.send_request(request_copy, **kwargs)
+        return self._client.send_request(request_copy, stream=stream, **kwargs)  # type: ignore
 
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "RecoveryServicesBackupClient":
         await self._client.__aenter__()
         return self
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_vendor.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/_vendor.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_engines_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_engines_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -71,15 +71,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either BackupEngineBaseResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupEngineBaseResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -95,74 +94,69 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("BackupEngineBaseResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEngines"
-    }
-
     @distributed_trace_async
     async def get(
         self,
         vault_name: str,
         resource_group_name: str,
         backup_engine_name: str,
         filter: Optional[str] = None,
@@ -178,15 +172,14 @@
         :type resource_group_name: str
         :param backup_engine_name: Name of the backup management server. Required.
         :type backup_engine_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupEngineBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupEngineBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -197,43 +190,38 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupEngineBaseResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             backup_engine_name=backup_engine_name,
             subscription_id=self._config.subscription_id,
             filter=filter,
             skip_token=skip_token,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupEngineBaseResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEngines/{backupEngineName}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_jobs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_jobs_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -69,15 +69,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -92,66 +91,61 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("JobResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_operation_results_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -66,15 +66,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param operation_id: OperationID which represents the operation. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -85,37 +84,32 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupOperationResults/{operationId}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_operation_statuses_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_operation_statuses_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -64,15 +64,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param operation_id: OperationID which represents the operation. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -83,41 +82,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupOperations/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_policies_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_resource_guard_proxies_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -23,130 +23,119 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._backup_policies_operations import build_list_request
+from ...operations._resource_guard_proxies_operations import build_get_request
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class BackupPoliciesOperations:
+class ResourceGuardProxiesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`backup_policies` attribute.
+        :attr:`resource_guard_proxies` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(
-        self, vault_name: str, resource_group_name: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.ProtectionPolicyResource"]:
-        """Lists of backup policies associated with Recovery Services Vault. API provides pagination
-        parameters to fetch
-        scoped results.
+    def get(
+        self, vault_name: str, resource_group_name: str, **kwargs: Any
+    ) -> AsyncIterable["_models.ResourceGuardProxyBaseResource"]:
+        """List the ResourceGuardProxies under vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param filter: OData filter options. Default value is None.
-        :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ProtectionPolicyResource or the result of
+        :return: An iterator like instance of either ResourceGuardProxyBaseResource or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectionPolicyResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ResourceGuardProxyBaseResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_get_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
-                    filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProtectionPolicyResourceList", pipeline_response)
+            deserialized = self._deserialize("ResourceGuardProxyBaseResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protectable_items_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_policies_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -23,138 +23,124 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._backup_protectable_items_operations import build_list_request
+from ...operations._backup_policies_operations import build_list_request
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class BackupProtectableItemsOperations:
+class BackupPoliciesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`backup_protectable_items` attribute.
+        :attr:`backup_policies` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(
-        self,
-        vault_name: str,
-        resource_group_name: str,
-        filter: Optional[str] = None,
-        skip_token: Optional[str] = None,
-        **kwargs: Any
-    ) -> AsyncIterable["_models.WorkloadProtectableItemResource"]:
-        """Provides a pageable list of protectable objects within your subscription according to the query
-        filter and the
-        pagination parameters.
+        self, vault_name: str, resource_group_name: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.ProtectionPolicyResource"]:
+        """Lists of backup policies associated with Recovery Services Vault. API provides pagination
+        parameters to fetch
+        scoped results.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :param skip_token: skipToken Filter. Default value is None.
-        :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either WorkloadProtectableItemResource or the result of
+        :return: An iterator like instance of either ProtectionPolicyResource or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.WorkloadProtectableItemResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.WorkloadProtectableItemResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ProtectionPolicyResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
-                    skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("WorkloadProtectableItemResourceList", pipeline_response)
+            deserialized = self._deserialize("ProtectionPolicyResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectableItems"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protected_items_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protected_items_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -69,15 +69,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ProtectedItemResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -93,66 +92,61 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ProtectedItemResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectedItems"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protection_containers_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protection_containers_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -62,15 +62,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ProtectionContainerResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -86,65 +85,60 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ProtectionContainerResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectionContainers"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protection_intent_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protection_intent_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -69,15 +69,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ProtectionIntentResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -93,66 +92,61 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ProtectionIntentResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectionIntents"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_encryption_configs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_encryption_configs_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -29,15 +29,15 @@
 from ...operations._backup_resource_encryption_configs_operations import build_get_request, build_update_request
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class BackupResourceEncryptionConfigsOperations:
+class BackupResourceEncryptionConfigsOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
         :attr:`backup_resource_encryption_configs` attribute.
@@ -59,15 +59,14 @@
         """Fetches Vault Encryption config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceEncryptionConfigExtendedResource or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceEncryptionConfigExtendedResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
@@ -79,48 +78,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupResourceEncryptionConfigExtendedResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceEncryptionConfigExtendedResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEncryptionConfigs/backupResourceEncryptionConfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def update(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceEncryptionConfigResource,
@@ -137,72 +131,66 @@
         :type resource_group_name: str
         :param parameters: Vault encryption input config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceEncryptionConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> None:
         """Updates Vault encryption config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault encryption input config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceEncryptionConfigResource, IO],
+        parameters: Union[_models.BackupResourceEncryptionConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         """Updates Vault encryption config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault encryption input config request. Is either a
-         BackupResourceEncryptionConfigResource type or a IO type. Required.
+         BackupResourceEncryptionConfigResource type or a IO[bytes] type. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceEncryptionConfigResource or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         IO[bytes]
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -222,40 +210,35 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceEncryptionConfigResource")
 
-        request = build_update_request(
+        _request = build_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEncryptionConfigs/backupResourceEncryptionConfig"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_storage_configs_non_crr_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_storage_configs_non_crr_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -33,15 +33,15 @@
 )
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class BackupResourceStorageConfigsNonCRROperations:
+class BackupResourceStorageConfigsNonCRROperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
         :attr:`backup_resource_storage_configs_non_crr` attribute.
@@ -63,15 +63,14 @@
         """Fetches resource storage config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -82,48 +81,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupResourceConfigResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def update(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceConfigResource,
@@ -140,71 +134,65 @@
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceConfigResource:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceConfigResource, IO],
+        parameters: Union[_models.BackupResourceConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.BackupResourceConfigResource:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Is either a BackupResourceConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource or IO[bytes]
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -224,51 +212,46 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceConfigResource")
 
-        request = build_update_request(
+        _request = build_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    update.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceConfigResource,
@@ -285,71 +268,65 @@
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> None:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceConfigResource, IO],
+        parameters: Union[_models.BackupResourceConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Is either a BackupResourceConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource or IO[bytes]
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -369,40 +346,35 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceConfigResource")
 
-        request = build_patch_request(
+        _request = build_patch_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    patch.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_vault_configs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_resource_vault_configs_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -63,15 +63,14 @@
         """Fetches resource vault config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -82,129 +81,128 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupResourceVaultConfigResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceVaultConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupconfig/vaultconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def update(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceVaultConfigResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceVaultConfigResource, IO],
+        parameters: Union[_models.BackupResourceVaultConfigResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Is either a BackupResourceVaultConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource or
+         IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -224,132 +222,132 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceVaultConfigResource")
 
-        request = build_update_request(
+        _request = build_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceVaultConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupconfig/vaultconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def put(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceVaultConfigResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def put(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def put(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceVaultConfigResource, IO],
+        parameters: Union[_models.BackupResourceVaultConfigResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Is either a BackupResourceVaultConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource or
+         IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -369,44 +367,40 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceVaultConfigResource")
 
-        request = build_put_request(
+        _request = build_put_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceVaultConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    put.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupconfig/vaultconfig"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_status_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_status_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -68,59 +68,53 @@
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Container Backup Status Request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupStatusResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def get(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
+        self, azure_region: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.BackupStatusResponse:
         """Get the container backup status.
 
         Get the container backup status.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Container Backup Status Request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupStatusResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def get(
-        self, azure_region: str, parameters: Union[_models.BackupStatusRequest, IO], **kwargs: Any
+        self, azure_region: str, parameters: Union[_models.BackupStatusRequest, IO[bytes]], **kwargs: Any
     ) -> _models.BackupStatusResponse:
         """Get the container backup status.
 
         Get the container backup status.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Container Backup Status Request. Is either a BackupStatusRequest type or a
-         IO type. Required.
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusRequest or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         IO[bytes]
         :return: BackupStatusResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -140,42 +134,37 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupStatusRequest")
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupStatusResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupStatus"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_usage_summaries_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_usage_summaries_crr_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -23,29 +23,28 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._backup_usage_summaries_operations import build_list_request
-from .._vendor import RecoveryServicesBackupClientMixinABC
+from ...operations._backup_usage_summaries_crr_operations import build_list_request
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class BackupUsageSummariesOperations:
+class BackupUsageSummariesCRROperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`backup_usage_summaries` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.aio.RecoveryServicesBackupPassiveClient`'s
+        :attr:`backup_usage_summaries_crr` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -69,19 +68,18 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either BackupManagementUsage or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupManagementUsage]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupManagementUsage]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupManagementUsageList] = kwargs.pop("cls", None)
@@ -93,66 +91,62 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("BackupManagementUsageList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupUsageSummaries"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_workload_items_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_workload_items_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -77,15 +77,14 @@
         :type fabric_name: str
         :param container_name: Name of the container. Required.
         :type container_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either WorkloadItemResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.WorkloadItemResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -101,68 +100,63 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     fabric_name=fabric_name,
                     container_name=container_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("WorkloadItemResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/items"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backups_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backups_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -81,29 +81,28 @@
         :param protected_item_name: Backup item for which backup needs to be triggered. Required.
         :type protected_item_name: str
         :param parameters: resource backup request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupRequestResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def trigger(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> None:
         """Triggers backup for specified backed up item. This is an asynchronous operation. To know the
         status of the
         operation, call GetProtectedItemOperationResult API.
@@ -116,33 +115,32 @@
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Backup item for which backup needs to be triggered. Required.
         :type protected_item_name: str
         :param parameters: resource backup request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def trigger(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: Union[_models.BackupRequestResource, IO],
+        parameters: Union[_models.BackupRequestResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         """Triggers backup for specified backed up item. This is an asynchronous operation. To know the
         status of the
         operation, call GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
@@ -152,22 +150,18 @@
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Backup item for which backup needs to be triggered. Required.
         :type protected_item_name: str
-        :param parameters: resource backup request. Is either a BackupRequestResource type or a IO
-         type. Required.
+        :param parameters: resource backup request. Is either a BackupRequestResource type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupRequestResource
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         or IO[bytes]
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -187,42 +181,37 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupRequestResource")
 
-        request = build_trigger_request(
+        _request = build_trigger_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.trigger.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/backup"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_bms_prepare_data_move_operation_result_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_bms_prepare_data_move_operation_result_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -28,15 +28,15 @@
 from ...operations._bms_prepare_data_move_operation_result_operations import build_get_request
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class BMSPrepareDataMoveOperationResultOperations:
+class BMSPrepareDataMoveOperationResultOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
         :attr:`bms_prepare_data_move_operation_result` attribute.
@@ -60,15 +60,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: VaultStorageConfigOperationResultResponse or None or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.VaultStorageConfigOperationResultResponse
          or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -81,44 +80,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Optional[_models.VaultStorageConfigOperationResultResponse]] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("VaultStorageConfigOperationResultResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_deleted_protection_containers_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protectable_containers_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -23,128 +23,125 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._deleted_protection_containers_operations import build_list_request
+from ...operations._protectable_containers_operations import build_list_request
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class DeletedProtectionContainersOperations:
+class ProtectableContainersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`deleted_protection_containers` attribute.
+        :attr:`protectable_containers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(
-        self, resource_group_name: str, vault_name: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.ProtectionContainerResource"]:
-        """Lists the soft deleted containers registered to Recovery Services Vault.
+        self, vault_name: str, resource_group_name: str, fabric_name: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.ProtectableContainerResource"]:
+        """Lists the containers that can be registered to Recovery Services Vault.
 
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
+        :param fabric_name: Required.
+        :type fabric_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ProtectionContainerResource or the result of
+        :return: An iterator like instance of either ProtectableContainerResource or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectableContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectionContainerResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ProtectableContainerResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
-                    resource_group_name=resource_group_name,
+                _request = build_list_request(
                     vault_name=vault_name,
+                    resource_group_name=resource_group_name,
+                    fabric_name=fabric_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProtectionContainerResourceList", pipeline_response)
+            deserialized = self._deserialize("ProtectableContainerResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupDeletedProtectionContainers"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_export_jobs_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_export_jobs_operation_results_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -63,15 +63,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param operation_id: OperationID which represents the export job. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationResultInfoBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationResultInfoBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -82,30 +81,29 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationResultInfoBaseResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -116,11 +114,7 @@
         if response.status_code == 202:
             deserialized = self._deserialize("OperationResultInfoBaseResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/operationResults/{operationId}"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_feature_support_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_feature_support_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -68,61 +68,55 @@
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Feature support request object. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.FeatureSupportRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AzureVMResourceFeatureSupportResponse or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.AzureVMResourceFeatureSupportResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
+        self, azure_region: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AzureVMResourceFeatureSupportResponse:
         """It will validate if given feature with resource properties is supported in service.
 
         It will validate if given feature with resource properties is supported in service.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Feature support request object. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AzureVMResourceFeatureSupportResponse or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.AzureVMResourceFeatureSupportResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate(
-        self, azure_region: str, parameters: Union[_models.FeatureSupportRequest, IO], **kwargs: Any
+        self, azure_region: str, parameters: Union[_models.FeatureSupportRequest, IO[bytes]], **kwargs: Any
     ) -> _models.AzureVMResourceFeatureSupportResponse:
         """It will validate if given feature with resource properties is supported in service.
 
         It will validate if given feature with resource properties is supported in service.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Feature support request object. Is either a FeatureSupportRequest type or a
-         IO type. Required.
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.FeatureSupportRequest
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         or IO[bytes]
         :return: AzureVMResourceFeatureSupportResponse or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.AzureVMResourceFeatureSupportResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
@@ -143,42 +137,37 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "FeatureSupportRequest")
 
-        request = build_validate_request(
+        _request = build_validate_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AzureVMResourceFeatureSupportResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    validate.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupValidateFeatures"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_fetch_tiering_cost_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_fetch_tiering_cost_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -14,55 +14,91 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._fetch_tiering_cost_operations import build_post_request
-from .._vendor import RecoveryServicesBackupClientMixinABC
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_post_request(resource_group_name: str, vault_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/fetchTieringCost",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "vaultName": _SERIALIZER.url(
+            "vault_name", vault_name, "str", max_length=50, min_length=2, pattern=r"^[A-Za-z][-A-Za-z0-9]*[A-Za-z0-9]$"
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class FetchTieringCostOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
         :attr:`fetch_tiering_cost` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _post_initial(
+    def _post_initial(
         self,
         resource_group_name: str,
         vault_name: str,
-        parameters: Union[_models.FetchTieringCostInfoRequest, IO],
+        parameters: Union[_models.FetchTieringCostInfoRequest, IO[bytes]],
         **kwargs: Any
     ) -> Optional[_models.TieringCostInfo]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -80,32 +116,31 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "FetchTieringCostInfoRequest")
 
-        request = build_post_request(
+        _request = build_post_request(
             resource_group_name=resource_group_name,
             vault_name=vault_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._post_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -115,32 +150,28 @@
         if response.status_code == 200:
             deserialized = self._deserialize("TieringCostInfo", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
-
-        return deserialized
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
-    _post_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/fetchTieringCost"
-    }
+        return deserialized  # type: ignore
 
     @overload
-    async def begin_post(
+    def begin_post(
         self,
         resource_group_name: str,
         vault_name: str,
         parameters: _models.FetchTieringCostInfoRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.TieringCostInfo]:
+    ) -> LROPoller[_models.TieringCostInfo]:
         """Provides the details of the tiering related sizes and cost.
         Status of the operation can be fetched using GetTieringCostOperationStatus API and result using
         GetTieringCostOperationResult API.
 
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
@@ -148,117 +179,90 @@
         :type vault_name: str
         :param parameters: Fetch Tiering Cost Request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.FetchTieringCostInfoRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either TieringCostInfo or the result of
+        :return: An instance of LROPoller that returns either TieringCostInfo or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
+         ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_post(
+    def begin_post(
         self,
         resource_group_name: str,
         vault_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.TieringCostInfo]:
+    ) -> LROPoller[_models.TieringCostInfo]:
         """Provides the details of the tiering related sizes and cost.
         Status of the operation can be fetched using GetTieringCostOperationStatus API and result using
         GetTieringCostOperationResult API.
 
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param parameters: Fetch Tiering Cost Request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either TieringCostInfo or the result of
+        :return: An instance of LROPoller that returns either TieringCostInfo or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
+         ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_post(
+    @distributed_trace
+    def begin_post(
         self,
         resource_group_name: str,
         vault_name: str,
-        parameters: Union[_models.FetchTieringCostInfoRequest, IO],
+        parameters: Union[_models.FetchTieringCostInfoRequest, IO[bytes]],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.TieringCostInfo]:
+    ) -> LROPoller[_models.TieringCostInfo]:
         """Provides the details of the tiering related sizes and cost.
         Status of the operation can be fetched using GetTieringCostOperationStatus API and result using
         GetTieringCostOperationResult API.
 
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param parameters: Fetch Tiering Cost Request. Is either a FetchTieringCostInfoRequest type or
-         a IO type. Required.
+         a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.FetchTieringCostInfoRequest or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either TieringCostInfo or the result of
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.FetchTieringCostInfoRequest or IO[bytes]
+        :return: An instance of LROPoller that returns either TieringCostInfo or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
+         ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.TieringCostInfo] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._post_initial(
+            raw_result = self._post_initial(
                 resource_group_name=resource_group_name,
                 vault_name=vault_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -266,28 +270,26 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("TieringCostInfo", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, {})  # type: ignore
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller[_models.TieringCostInfo].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_post.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/fetchTieringCost"
-    }
+        return LROPoller[_models.TieringCostInfo](
+            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
+        )
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_get_tiering_cost_operation_result_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_get_tiering_cost_operation_result_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -60,15 +60,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: TieringCostInfo or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -79,41 +78,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.TieringCostInfo] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             resource_group_name=resource_group_name,
             vault_name=vault_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("TieringCostInfo", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_item_level_recovery_connections_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_items_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -22,178 +22,243 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._item_level_recovery_connections_operations import build_provision_request, build_revoke_request
+from ...operations._protected_items_operations import (
+    build_create_or_update_request,
+    build_delete_request,
+    build_get_request,
+)
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ItemLevelRecoveryConnectionsOperations:
+class ProtectedItemsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`item_level_recovery_connections` attribute.
+        :attr:`protected_items` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
+    @distributed_trace_async
+    async def get(
+        self,
+        vault_name: str,
+        resource_group_name: str,
+        fabric_name: str,
+        container_name: str,
+        protected_item_name: str,
+        filter: Optional[str] = None,
+        **kwargs: Any
+    ) -> _models.ProtectedItemResource:
+        """Provides the details of the backed up item. This is an asynchronous operation. To know the
+        status of the operation,
+        call the GetItemOperationResult API.
+
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
+        :param resource_group_name: The name of the resource group where the recovery services vault is
+         present. Required.
+        :type resource_group_name: str
+        :param fabric_name: Fabric name associated with the backed up item. Required.
+        :type fabric_name: str
+        :param container_name: Container name associated with the backed up item. Required.
+        :type container_name: str
+        :param protected_item_name: Backed up item name whose details are to be fetched. Required.
+        :type protected_item_name: str
+        :param filter: OData filter options. Default value is None.
+        :type filter: str
+        :return: ProtectedItemResource or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ProtectedItemResource] = kwargs.pop("cls", None)
+
+        _request = build_get_request(
+            vault_name=vault_name,
+            resource_group_name=resource_group_name,
+            fabric_name=fabric_name,
+            container_name=container_name,
+            protected_item_name=protected_item_name,
+            subscription_id=self._config.subscription_id,
+            filter=filter,
+            api_version=api_version,
+            headers=_headers,
+            params=_params,
+        )
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("ProtectedItemResource", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})  # type: ignore
+
+        return deserialized  # type: ignore
+
     @overload
-    async def provision(  # pylint: disable=inconsistent-return-statements
+    async def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        recovery_point_id: str,
-        parameters: _models.ILRRequestResource,
+        parameters: _models.ProtectedItemResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> None:
-        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
-        opens a file
-        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
-        To know the status of
-        provisioning, call GetProtectedItemOperationResult API.
+    ) -> Optional[_models.ProtectedItemResource]:
+        """Enables backup of an item or to modifies the backup policy information of an already backed up
+        item. This is an
+        asynchronous operation. To know the status of the operation, call the GetItemOperationResult
+        API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up items. Required.
+        :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backed up items. Required.
+        :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
-        :param protected_item_name: Backed up item name whose files/folders are to be restored.
-         Required.
+        :param protected_item_name: Item name to be backed up. Required.
         :type protected_item_name: str
-        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
-         will be provisioned
-         for this backed up data. Required.
-        :type recovery_point_id: str
-        :param parameters: resource ILR request. Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ILRRequestResource
+        :param parameters: resource backed up item. Required.
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: ProtectedItemResource or None or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def provision(  # pylint: disable=inconsistent-return-statements
+    async def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        recovery_point_id: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> None:
-        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
-        opens a file
-        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
-        To know the status of
-        provisioning, call GetProtectedItemOperationResult API.
+    ) -> Optional[_models.ProtectedItemResource]:
+        """Enables backup of an item or to modifies the backup policy information of an already backed up
+        item. This is an
+        asynchronous operation. To know the status of the operation, call the GetItemOperationResult
+        API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up items. Required.
+        :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backed up items. Required.
+        :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
-        :param protected_item_name: Backed up item name whose files/folders are to be restored.
-         Required.
+        :param protected_item_name: Item name to be backed up. Required.
         :type protected_item_name: str
-        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
-         will be provisioned
-         for this backed up data. Required.
-        :type recovery_point_id: str
-        :param parameters: resource ILR request. Required.
-        :type parameters: IO
+        :param parameters: resource backed up item. Required.
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: ProtectedItemResource or None or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
-    async def provision(  # pylint: disable=inconsistent-return-statements
+    async def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        recovery_point_id: str,
-        parameters: Union[_models.ILRRequestResource, IO],
+        parameters: Union[_models.ProtectedItemResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
-    ) -> None:
-        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
-        opens a file
-        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
-        To know the status of
-        provisioning, call GetProtectedItemOperationResult API.
+    ) -> Optional[_models.ProtectedItemResource]:
+        """Enables backup of an item or to modifies the backup policy information of an already backed up
+        item. This is an
+        asynchronous operation. To know the status of the operation, call the GetItemOperationResult
+        API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up items. Required.
+        :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backed up items. Required.
+        :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
-        :param protected_item_name: Backed up item name whose files/folders are to be restored.
-         Required.
+        :param protected_item_name: Item name to be backed up. Required.
         :type protected_item_name: str
-        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
-         will be provisioned
-         for this backed up data. Required.
-        :type recovery_point_id: str
-        :param parameters: resource ILR request. Is either a ILRRequestResource type or a IO type.
-         Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ILRRequestResource or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :param parameters: resource backed up item. Is either a ProtectedItemResource type or a
+         IO[bytes] type. Required.
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource
+         or IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
+        :return: ProtectedItemResource or None or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -201,93 +266,87 @@
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.ProtectedItemResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
-            _json = self._serialize.body(parameters, "ILRRequestResource")
+            _json = self._serialize.body(parameters, "ProtectedItemResource")
 
-        request = build_provision_request(
+        _request = build_create_or_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
-            recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.provision.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
+        deserialized = None
+        if response.status_code == 200:
+            deserialized = self._deserialize("ProtectedItemResource", pipeline_response)
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    provision.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/provisionInstantItemRecovery"
-    }
+        return deserialized  # type: ignore
 
     @distributed_trace_async
-    async def revoke(  # pylint: disable=inconsistent-return-statements
+    async def delete(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        recovery_point_id: str,
         **kwargs: Any
     ) -> None:
-        """Revokes an iSCSI connection which can be used to download a script. Executing this script opens
-        a file explorer
-        displaying all recoverable files and folders. This is an asynchronous operation.
+        """Used to disable backup of an item within a container. This is an asynchronous operation. To
+        know the status of the
+        request, call the GetItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up items. Required.
+        :param fabric_name: Fabric name associated with the backed up item. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backed up items. Required.
+        :param container_name: Container name associated with the backed up item. Required.
         :type container_name: str
-        :param protected_item_name: Backed up item name whose files/folders are to be restored.
-         Required.
+        :param protected_item_name: Backed up item to be deleted. Required.
         :type protected_item_name: str
-        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
-         will be revoked for
-         this backed up data. Required.
-        :type recovery_point_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -298,40 +357,34 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_revoke_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
-            recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.revoke.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    revoke.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/revokeInstantItemRecovery"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_cancellations_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_cancellations_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -61,15 +61,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param job_name: Name of the job to cancel. Required.
         :type job_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -80,37 +79,32 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_trigger_request(
+        _request = build_trigger_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.trigger.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/{jobName}/cancel"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_details_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_details_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -58,15 +58,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param job_name: Name of the job whose details are to be fetched. Required.
         :type job_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -77,41 +76,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/{jobName}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_job_operation_results_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -63,15 +63,14 @@
          present. Required.
         :type resource_group_name: str
         :param job_name: Job name whose operation result has to be fetched. Required.
         :type job_name: str
         :param operation_id: OperationID which represents the operation whose result has to be fetched.
          Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -82,38 +81,33 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             job_name=job_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/{jobName}/operationResults/{operationId}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_jobs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_jobs_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -60,15 +60,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -79,37 +78,32 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_export_request(
+        _request = build_export_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             filter=filter,
             api_version=api_version,
-            template_url=self.export.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    export.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobsExport"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_operation_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_operation_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -71,71 +71,66 @@
         :type resource_group_name: str
         :param parameters: resource validate operation request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidateOperationsResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationsResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ValidateOperationsResponse:
         """Validate operation for specified backed up item. This is a synchronous operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidateOperationsResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationsResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.ValidateOperationRequestResource, IO],
+        parameters: Union[_models.ValidateOperationRequestResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.ValidateOperationsResponse:
         """Validate operation for specified backed up item. This is a synchronous operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Is either a
-         ValidateOperationRequestResource type or a IO type. Required.
+         ValidateOperationRequestResource type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource or
+         IO[bytes]
         :return: ValidateOperationsResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationsResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -155,43 +150,38 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ValidateOperationRequestResource")
 
-        request = build_validate_request(
+        _request = build_validate_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ValidateOperationsResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    validate.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperation"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -53,15 +53,14 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.ClientDiscoveryValueForSingleApi"]:
         """Returns the list of available operations.
 
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ClientDiscoveryValueForSingleApi or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ClientDiscoveryValueForSingleApi]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -77,59 +76,56 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ClientDiscoveryResponse", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {"url": "/providers/Microsoft.RecoveryServices/operations"}
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_private_endpoint_connection_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_private_endpoint_connection_operations.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -67,15 +67,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: PrivateEndpointConnectionResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -86,56 +85,51 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnectionResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("PrivateEndpointConnectionResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
+        return deserialized  # type: ignore
 
     async def _put_initial(
         self,
         vault_name: str,
         resource_group_name: str,
         private_endpoint_connection_name: str,
-        parameters: Union[_models.PrivateEndpointConnectionResource, IO],
+        parameters: Union[_models.PrivateEndpointConnectionResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.PrivateEndpointConnectionResource:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -153,33 +147,32 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "PrivateEndpointConnectionResource")
 
-        request = build_put_request(
+        _request = build_put_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._put_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -191,18 +184,14 @@
             deserialized = self._deserialize("PrivateEndpointConnectionResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
-    _put_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
-
     @overload
     async def begin_put(
         self,
         vault_name: str,
         resource_group_name: str,
         private_endpoint_connection_name: str,
         parameters: _models.PrivateEndpointConnectionResource,
@@ -221,102 +210,76 @@
         :type private_endpoint_connection_name: str
         :param parameters: Request body for operation. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either PrivateEndpointConnectionResource or
          the result of cls(response)
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_put(
         self,
         vault_name: str,
         resource_group_name: str,
         private_endpoint_connection_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.PrivateEndpointConnectionResource]:
         """Approve or Reject Private Endpoint requests. This call is made by Backup Admin.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param parameters: Request body for operation. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either PrivateEndpointConnectionResource or
          the result of cls(response)
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_put(
         self,
         vault_name: str,
         resource_group_name: str,
         private_endpoint_connection_name: str,
-        parameters: Union[_models.PrivateEndpointConnectionResource, IO],
+        parameters: Union[_models.PrivateEndpointConnectionResource, IO[bytes]],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.PrivateEndpointConnectionResource]:
         """Approve or Reject Private Endpoint requests. This call is made by Backup Admin.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param parameters: Request body for operation. Is either a PrivateEndpointConnectionResource
-         type or a IO type. Required.
+         type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource or
+         IO[bytes]
         :return: An instance of AsyncLROPoller that returns either PrivateEndpointConnectionResource or
          the result of cls(response)
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
@@ -342,35 +305,33 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("PrivateEndpointConnectionResource", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, {})  # type: ignore
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return AsyncLROPoller[_models.PrivateEndpointConnectionResource].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_put.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
+        return AsyncLROPoller[_models.PrivateEndpointConnectionResource](
+            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
+        )
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, private_endpoint_connection_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -381,66 +342,53 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @distributed_trace_async
     async def begin_delete(
         self, vault_name: str, resource_group_name: str, private_endpoint_connection_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Delete Private Endpoint requests. This call is made by Backup Admin.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -460,27 +408,23 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return AsyncLROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
+        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_private_endpoint_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_private_endpoint_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -69,15 +69,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param operation_id: Operation id. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -88,43 +87,38 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_operation_status_request(
+        _request = build_get_operation_status_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get_operation_status.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}/operationsStatus/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protectable_containers_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_deleted_protection_containers_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,153 +1,179 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._protectable_containers_operations import build_list_request
-from .._vendor import RecoveryServicesBackupClientMixinABC
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
 
-class ProtectableContainersOperations:
+
+def build_list_request(
+    resource_group_name: str, vault_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupDeletedProtectionContainers",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class DeletedProtectionContainersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`protectable_containers` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
+        :attr:`deleted_protection_containers` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(
-        self, vault_name: str, resource_group_name: str, fabric_name: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.ProtectableContainerResource"]:
-        """Lists the containers that can be registered to Recovery Services Vault.
+        self, resource_group_name: str, vault_name: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> Iterable["_models.ProtectionContainerResource"]:
+        """Lists the soft deleted containers registered to Recovery Services Vault.
 
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Required.
-        :type fabric_name: str
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ProtectableContainerResource or the result of
+        :return: An iterator like instance of either ProtectionContainerResource or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectableContainerResource]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectableContainerResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ProtectionContainerResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
-                    vault_name=vault_name,
+                _request = build_list_request(
                     resource_group_name=resource_group_name,
-                    fabric_name=fabric_name,
+                    vault_name=vault_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProtectableContainerResourceList", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("ProtectionContainerResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
+        def get_next(next_link=None):
+            _request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectableContainers"
-    }
+        return ItemPaged(get_next, extract_data)
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_item_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_item_operation_results_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -74,15 +74,14 @@
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Backup item name whose details are to be fetched. Required.
         :type protected_item_name: str
         :param operation_id: OperationID which represents the operation whose result needs to be
          fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectedItemResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -93,46 +92,41 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Optional[_models.ProtectedItemResource]] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("ProtectedItemResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_item_operation_statuses_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_item_operation_statuses_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -78,15 +78,14 @@
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Backup item name whose details are to be fetched. Required.
         :type protected_item_name: str
         :param operation_id: OperationID represents the operation whose status needs to be fetched.
          Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -97,44 +96,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/operationsStatus/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protected_items_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_item_level_recovery_connections_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -14,254 +14,269 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._protected_items_operations import (
-    build_create_or_update_request,
-    build_delete_request,
-    build_get_request,
-)
-from .._vendor import RecoveryServicesBackupClientMixinABC
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_provision_request(
+    vault_name: str,
+    resource_group_name: str,
+    fabric_name: str,
+    container_name: str,
+    protected_item_name: str,
+    recovery_point_id: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/provisionInstantItemRecovery",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "fabricName": _SERIALIZER.url("fabric_name", fabric_name, "str"),
+        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
+        "protectedItemName": _SERIALIZER.url("protected_item_name", protected_item_name, "str"),
+        "recoveryPointId": _SERIALIZER.url("recovery_point_id", recovery_point_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_revoke_request(
+    vault_name: str,
+    resource_group_name: str,
+    fabric_name: str,
+    container_name: str,
+    protected_item_name: str,
+    recovery_point_id: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/revokeInstantItemRecovery",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "fabricName": _SERIALIZER.url("fabric_name", fabric_name, "str"),
+        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
+        "protectedItemName": _SERIALIZER.url("protected_item_name", protected_item_name, "str"),
+        "recoveryPointId": _SERIALIZER.url("recovery_point_id", recovery_point_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-class ProtectedItemsOperations:
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class ItemLevelRecoveryConnectionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`protected_items` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
+        :attr:`item_level_recovery_connections` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    @distributed_trace_async
-    async def get(
-        self,
-        vault_name: str,
-        resource_group_name: str,
-        fabric_name: str,
-        container_name: str,
-        protected_item_name: str,
-        filter: Optional[str] = None,
-        **kwargs: Any
-    ) -> _models.ProtectedItemResource:
-        """Provides the details of the backed up item. This is an asynchronous operation. To know the
-        status of the operation,
-        call the GetItemOperationResult API.
-
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
-        :param resource_group_name: The name of the resource group where the recovery services vault is
-         present. Required.
-        :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up item. Required.
-        :type fabric_name: str
-        :param container_name: Container name associated with the backed up item. Required.
-        :type container_name: str
-        :param protected_item_name: Backed up item name whose details are to be fetched. Required.
-        :type protected_item_name: str
-        :param filter: OData filter options. Default value is None.
-        :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: ProtectedItemResource or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectedItemResource] = kwargs.pop("cls", None)
-
-        request = build_get_request(
-            vault_name=vault_name,
-            resource_group_name=resource_group_name,
-            fabric_name=fabric_name,
-            container_name=container_name,
-            protected_item_name=protected_item_name,
-            subscription_id=self._config.subscription_id,
-            filter=filter,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("ProtectedItemResource", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}"
-    }
-
     @overload
-    async def create_or_update(
+    def provision(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: _models.ProtectedItemResource,
+        recovery_point_id: str,
+        parameters: _models.ILRRequestResource,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> Optional[_models.ProtectedItemResource]:
-        """Enables backup of an item or to modifies the backup policy information of an already backed up
-        item. This is an
-        asynchronous operation. To know the status of the operation, call the GetItemOperationResult
-        API.
+    ) -> None:
+        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
+        opens a file
+        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
+        To know the status of
+        provisioning, call GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backup item. Required.
+        :param fabric_name: Fabric name associated with the backed up items. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backup item. Required.
+        :param container_name: Container name associated with the backed up items. Required.
         :type container_name: str
-        :param protected_item_name: Item name to be backed up. Required.
+        :param protected_item_name: Backed up item name whose files/folders are to be restored.
+         Required.
         :type protected_item_name: str
-        :param parameters: resource backed up item. Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource
+        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
+         will be provisioned
+         for this backed up data. Required.
+        :type recovery_point_id: str
+        :param parameters: resource ILR request. Required.
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ILRRequestResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: ProtectedItemResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def create_or_update(
+    def provision(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: IO,
+        recovery_point_id: str,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> Optional[_models.ProtectedItemResource]:
-        """Enables backup of an item or to modifies the backup policy information of an already backed up
-        item. This is an
-        asynchronous operation. To know the status of the operation, call the GetItemOperationResult
-        API.
+    ) -> None:
+        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
+        opens a file
+        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
+        To know the status of
+        provisioning, call GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backup item. Required.
+        :param fabric_name: Fabric name associated with the backed up items. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backup item. Required.
+        :param container_name: Container name associated with the backed up items. Required.
         :type container_name: str
-        :param protected_item_name: Item name to be backed up. Required.
+        :param protected_item_name: Backed up item name whose files/folders are to be restored.
+         Required.
         :type protected_item_name: str
-        :param parameters: resource backed up item. Required.
-        :type parameters: IO
+        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
+         will be provisioned
+         for this backed up data. Required.
+        :type recovery_point_id: str
+        :param parameters: resource ILR request. Required.
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: ProtectedItemResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def create_or_update(
+    @distributed_trace
+    def provision(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: Union[_models.ProtectedItemResource, IO],
+        recovery_point_id: str,
+        parameters: Union[_models.ILRRequestResource, IO[bytes]],
         **kwargs: Any
-    ) -> Optional[_models.ProtectedItemResource]:
-        """Enables backup of an item or to modifies the backup policy information of an already backed up
-        item. This is an
-        asynchronous operation. To know the status of the operation, call the GetItemOperationResult
-        API.
+    ) -> None:
+        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
+        opens a file
+        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
+        To know the status of
+        provisioning, call GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backup item. Required.
+        :param fabric_name: Fabric name associated with the backed up items. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backup item. Required.
+        :param container_name: Container name associated with the backed up items. Required.
         :type container_name: str
-        :param protected_item_name: Item name to be backed up. Required.
+        :param protected_item_name: Backed up item name whose files/folders are to be restored.
+         Required.
         :type protected_item_name: str
-        :param parameters: resource backed up item. Is either a ProtectedItemResource type or a IO
+        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
+         will be provisioned
+         for this backed up data. Required.
+        :type recovery_point_id: str
+        :param parameters: resource ILR request. Is either a ILRRequestResource type or a IO[bytes]
          type. Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: ProtectedItemResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ILRRequestResource or
+         IO[bytes]
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -269,92 +284,87 @@
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.ProtectedItemResource]] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
-            _json = self._serialize.body(parameters, "ProtectedItemResource")
+            _json = self._serialize.body(parameters, "ILRRequestResource")
 
-        request = build_create_or_update_request(
+        _request = build_provision_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
+            recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = None
-        if response.status_code == 200:
-            deserialized = self._deserialize("ProtectedItemResource", pipeline_response)
-
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, None, {})  # type: ignore
 
-        return deserialized
-
-    create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}"
-    }
-
-    @distributed_trace_async
-    async def delete(  # pylint: disable=inconsistent-return-statements
+    @distributed_trace
+    def revoke(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
+        recovery_point_id: str,
         **kwargs: Any
     ) -> None:
-        """Used to disable backup of an item within a container. This is an asynchronous operation. To
-        know the status of the
-        request, call the GetItemOperationResult API.
+        """Revokes an iSCSI connection which can be used to download a script. Executing this script opens
+        a file explorer
+        displaying all recoverable files and folders. This is an asynchronous operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up item. Required.
+        :param fabric_name: Fabric name associated with the backed up items. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backed up item. Required.
+        :param container_name: Container name associated with the backed up items. Required.
         :type container_name: str
-        :param protected_item_name: Backed up item to be deleted. Required.
+        :param protected_item_name: Backed up item name whose files/folders are to be restored.
+         Required.
         :type protected_item_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
+         will be revoked for
+         this backed up data. Required.
+        :type recovery_point_id: str
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -365,39 +375,35 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_revoke_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
+            recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202, 204]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_container_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policy_operation_statuses_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -21,115 +21,101 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._protection_container_operation_results_operations import build_get_request
+from ...operations._protection_policy_operation_statuses_operations import build_get_request
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ProtectionContainerOperationResultsOperations:
+class ProtectionPolicyOperationStatusesOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`protection_container_operation_results` attribute.
+        :attr:`protection_policy_operation_statuses` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace_async
     async def get(
-        self,
-        vault_name: str,
-        resource_group_name: str,
-        fabric_name: str,
-        container_name: str,
-        operation_id: str,
-        **kwargs: Any
-    ) -> Optional[_models.ProtectionContainerResource]:
-        """Fetches the result of any operation on the container.
+        self, vault_name: str, resource_group_name: str, policy_name: str, operation_id: str, **kwargs: Any
+    ) -> _models.OperationStatus:
+        """Provides the status of the asynchronous operations like backup, restore. The status can be in
+        progress, completed
+        or failed. You can refer to the Operation Status enum for all the possible states of an
+        operation. Some operations
+        create jobs. This method returns the list of jobs associated with operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the container. Required.
-        :type fabric_name: str
-        :param container_name: Container name whose information should be fetched. Required.
-        :type container_name: str
-        :param operation_id: Operation ID which represents the operation whose result needs to be
+        :param policy_name: Backup policy name whose operation's status needs to be fetched. Required.
+        :type policy_name: str
+        :param operation_id: Operation ID which represents an operation whose status needs to be
          fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: ProtectionContainerResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource or
-         None
+        :return: OperationStatus or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[Optional[_models.ProtectionContainerResource]] = kwargs.pop("cls", None)
+        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
-            fabric_name=fabric_name,
-            container_name=container_name,
+            policy_name=policy_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202, 204]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = None
-        if response.status_code == 200:
-            deserialized = self._deserialize("ProtectionContainerResource", pipeline_response)
+        deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_container_refresh_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_container_refresh_operation_results_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -28,15 +28,15 @@
 from ...operations._protection_container_refresh_operation_results_operations import build_get_request
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ProtectionContainerRefreshOperationResultsOperations:
+class ProtectionContainerRefreshOperationResultsOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
         :attr:`protection_container_refresh_operation_results` attribute.
@@ -63,15 +63,14 @@
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the container. Required.
         :type fabric_name: str
         :param operation_id: Operation ID associated with the operation whose result needs to be
          fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -82,38 +81,33 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/operationResults/{operationId}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_containers_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_containers_operations.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -71,15 +71,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Name of the fabric where the container belongs. Required.
         :type fabric_name: str
         :param container_name: Name of the container whose details need to be fetched. Required.
         :type container_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionContainerResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -90,57 +89,52 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProtectionContainerResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectionContainerResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}"
-    }
+        return deserialized  # type: ignore
 
     async def _register_initial(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
-        parameters: Union[_models.ProtectionContainerResource, IO],
+        parameters: Union[_models.ProtectionContainerResource, IO[bytes]],
         **kwargs: Any
     ) -> Optional[_models.ProtectionContainerResource]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -158,54 +152,49 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ProtectionContainerResource")
 
-        request = build_register_request(
+        _request = build_register_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._register_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("ProtectionContainerResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    _register_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def begin_register(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
@@ -231,37 +220,29 @@
         :type container_name: str
         :param parameters: Request body for operation. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either ProtectionContainerResource or the
          result of cls(response)
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_register(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ProtectionContainerResource]:
         """Registers the container with Recovery Services vault.
         This is an asynchronous operation. To track the operation status, use location header to call
         get latest status of
@@ -273,41 +254,33 @@
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the container. Required.
         :type fabric_name: str
         :param container_name: Name of the container to be registered. Required.
         :type container_name: str
         :param parameters: Request body for operation. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either ProtectionContainerResource or the
          result of cls(response)
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_register(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
-        parameters: Union[_models.ProtectionContainerResource, IO],
+        parameters: Union[_models.ProtectionContainerResource, IO[bytes]],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ProtectionContainerResource]:
         """Registers the container with Recovery Services vault.
         This is an asynchronous operation. To track the operation status, use location header to call
         get latest status of
         the operation.
 
@@ -317,28 +290,17 @@
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the container. Required.
         :type fabric_name: str
         :param container_name: Name of the container to be registered. Required.
         :type container_name: str
         :param parameters: Request body for operation. Is either a ProtectionContainerResource type or
-         a IO type. Required.
+         a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource or IO[bytes]
         :return: An instance of AsyncLROPoller that returns either ProtectionContainerResource or the
          result of cls(response)
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
@@ -365,35 +327,33 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("ProtectionContainerResource", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, {})  # type: ignore
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return AsyncLROPoller[_models.ProtectionContainerResource].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_register.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}"
-    }
+        return AsyncLROPoller[_models.ProtectionContainerResource](
+            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
+        )
 
     @distributed_trace_async
     async def unregister(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, fabric_name: str, container_name: str, **kwargs: Any
     ) -> None:
         """Unregisters the given container from your Recovery Services Vault. This is an asynchronous
         operation. To determine
@@ -406,15 +366,14 @@
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Name of the fabric where the container belongs. Required.
         :type fabric_name: str
         :param container_name: Name of the container which needs to be unregistered from the Recovery
          Services Vault. Required.
         :type container_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -425,45 +384,40 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_unregister_request(
+        _request = build_unregister_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.unregister.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    unregister.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @distributed_trace_async
     async def inquire(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
@@ -483,15 +437,14 @@
         :type resource_group_name: str
         :param fabric_name: Fabric Name associated with the container. Required.
         :type fabric_name: str
         :param container_name: Name of the container in which inquiry needs to be triggered. Required.
         :type container_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -502,46 +455,41 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_inquire_request(
+        _request = build_inquire_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             subscription_id=self._config.subscription_id,
             filter=filter,
             api_version=api_version,
-            template_url=self.inquire.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    inquire.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/inquire"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @distributed_trace_async
     async def refresh(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, fabric_name: str, filter: Optional[str] = None, **kwargs: Any
     ) -> None:
         """Discovers all the containers in the subscription that can be backed up to Recovery Services
         Vault. This is an
@@ -553,15 +501,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated the container. Required.
         :type fabric_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -572,38 +519,33 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_refresh_request(
+        _request = build_refresh_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             subscription_id=self._config.subscription_id,
             filter=filter,
             api_version=api_version,
-            template_url=self.refresh.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    refresh.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/refreshContainers"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_intent_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_intent_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -84,23 +84,22 @@
         :type azure_region: str
         :param parameters: Enable backup validation request on Virtual Machine. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: PreValidateEnableBackupResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
+        self, azure_region: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.PreValidateEnableBackupResponse:
         """It will validate followings
 
 
         #. Vault capacity
         #. VM is already protected
         #. Any VM related configuration passed in properties.
@@ -111,27 +110,26 @@
         #. Vault capacity
         #. VM is already protected
         #. Any VM related configuration passed in properties.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Enable backup validation request on Virtual Machine. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: PreValidateEnableBackupResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate(
-        self, azure_region: str, parameters: Union[_models.PreValidateEnableBackupRequest, IO], **kwargs: Any
+        self, azure_region: str, parameters: Union[_models.PreValidateEnableBackupRequest, IO[bytes]], **kwargs: Any
     ) -> _models.PreValidateEnableBackupResponse:
         """It will validate followings
 
 
         #. Vault capacity
         #. VM is already protected
         #. Any VM related configuration passed in properties.
@@ -142,21 +140,18 @@
         #. Vault capacity
         #. VM is already protected
         #. Any VM related configuration passed in properties.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Enable backup validation request on Virtual Machine. Is either a
-         PreValidateEnableBackupRequest type or a IO type. Required.
+         PreValidateEnableBackupRequest type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupRequest or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupRequest or
+         IO[bytes]
         :return: PreValidateEnableBackupResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -176,49 +171,44 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "PreValidateEnableBackupRequest")
 
-        request = build_validate_request(
+        _request = build_validate_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("PreValidateEnableBackupResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    validate.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupPreValidateProtection"
-    }
+        return deserialized  # type: ignore
 
     @distributed_trace_async
     async def get(
         self, vault_name: str, resource_group_name: str, fabric_name: str, intent_object_name: str, **kwargs: Any
     ) -> _models.ProtectionIntentResource:
         """Provides the details of the protection intent up item. This is an asynchronous operation. To
         know the status of the operation,
@@ -229,15 +219,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backed up item. Required.
         :type fabric_name: str
         :param intent_object_name: Backed up item name whose details are to be fetched. Required.
         :type intent_object_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionIntentResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -248,49 +237,44 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProtectionIntentResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             intent_object_name=intent_object_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectionIntentResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/backupProtectionIntent/{intentObjectName}"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
@@ -313,28 +297,27 @@
         :type intent_object_name: str
         :param parameters: resource backed up item. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionIntentResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         intent_object_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ProtectionIntentResource:
         """Create Intent for Enabling backup of an item. This is a synchronous operation.
 
         :param vault_name: The name of the recovery services vault. Required.
@@ -343,53 +326,48 @@
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param intent_object_name: Intent object name. Required.
         :type intent_object_name: str
         :param parameters: resource backed up item. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionIntentResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         intent_object_name: str,
-        parameters: Union[_models.ProtectionIntentResource, IO],
+        parameters: Union[_models.ProtectionIntentResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.ProtectionIntentResource:
         """Create Intent for Enabling backup of an item. This is a synchronous operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param intent_object_name: Intent object name. Required.
         :type intent_object_name: str
-        :param parameters: resource backed up item. Is either a ProtectionIntentResource type or a IO
-         type. Required.
+        :param parameters: resource backed up item. Is either a ProtectionIntentResource type or a
+         IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource or IO[bytes]
         :return: ProtectionIntentResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -409,52 +387,47 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ProtectionIntentResource")
 
-        request = build_create_or_update_request(
+        _request = build_create_or_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             intent_object_name=intent_object_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectionIntentResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    create_or_update.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/backupProtectionIntent/{intentObjectName}"
-    }
+        return deserialized  # type: ignore
 
     @distributed_trace_async
     async def delete(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, fabric_name: str, intent_object_name: str, **kwargs: Any
     ) -> None:
         """Used to remove intent from an item.
 
@@ -463,15 +436,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the intent. Required.
         :type fabric_name: str
         :param intent_object_name: Intent to be deleted. Required.
         :type intent_object_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -482,38 +454,33 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             intent_object_name=intent_object_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    delete.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/backupProtectionIntent/{intentObjectName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policies_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policies_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -69,15 +69,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy information to be fetched. Required.
         :type policy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionPolicyResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -88,56 +87,52 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProtectionPolicyResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectionPolicyResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         policy_name: str,
         parameters: _models.ProtectionPolicyResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ProtectionPolicyResource]:
         """Creates or modifies a backup policy. This is an asynchronous operation. Status of the operation
         can be fetched
         using GetPolicyOperationResult API.
@@ -148,30 +143,32 @@
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy to be created. Required.
         :type policy_name: str
         :param parameters: resource backup policy. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionPolicyResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         policy_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ProtectionPolicyResource]:
         """Creates or modifies a backup policy. This is an asynchronous operation. Status of the operation
         can be fetched
         using GetPolicyOperationResult API.
@@ -180,52 +177,52 @@
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy to be created. Required.
         :type policy_name: str
         :param parameters: resource backup policy. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionPolicyResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         policy_name: str,
-        parameters: Union[_models.ProtectionPolicyResource, IO],
+        parameters: Union[_models.ProtectionPolicyResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> Optional[_models.ProtectionPolicyResource]:
         """Creates or modifies a backup policy. This is an asynchronous operation. Status of the operation
         can be fetched
         using GetPolicyOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy to be created. Required.
         :type policy_name: str
-        :param parameters: resource backup policy. Is either a ProtectionPolicyResource type or a IO
-         type. Required.
+        :param parameters: resource backup policy. Is either a ProtectionPolicyResource type or a
+         IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :return: ProtectionPolicyResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -245,53 +242,49 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ProtectionPolicyResource")
 
-        request = build_create_or_update_request(
+        _request = build_create_or_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("ProtectionPolicyResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}"
-    }
+        return deserialized  # type: ignore
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, policy_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -302,44 +295,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @distributed_trace_async
     async def begin_delete(
         self, vault_name: str, resource_group_name: str, policy_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes specified backup policy from your Recovery Services Vault. This is an asynchronous
         operation. Status of the
@@ -348,22 +336,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy to be deleted. Required.
         :type policy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -383,27 +363,23 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return AsyncLROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}"
-    }
+        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policy_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policy_operation_results_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -28,15 +28,15 @@
 from ...operations._protection_policy_operation_results_operations import build_get_request
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ProtectionPolicyOperationResultsOperations:
+class ProtectionPolicyOperationResultsOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
         :attr:`protection_policy_operation_results` attribute.
@@ -63,15 +63,14 @@
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy name whose operation's result needs to be fetched. Required.
         :type policy_name: str
         :param operation_id: Operation ID which represents the operation whose result needs to be
          fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionPolicyResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -82,42 +81,37 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProtectionPolicyResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectionPolicyResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_protection_policy_operation_statuses_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_operation_statuses_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -13,69 +13,99 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._protection_policy_operation_statuses_operations import build_get_request
-from .._vendor import RecoveryServicesBackupClientMixinABC
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
 
-class ProtectionPolicyOperationStatusesOperations:
+
+def build_get_request(
+    vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupOperations/{operationId}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class BackupOperationStatusesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`protection_policy_operation_statuses` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
+        :attr:`backup_operation_statuses` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    @distributed_trace_async
-    async def get(
-        self, vault_name: str, resource_group_name: str, policy_name: str, operation_id: str, **kwargs: Any
+    @distributed_trace
+    def get(
+        self, vault_name: str, resource_group_name: str, operation_id: str, **kwargs: Any
     ) -> _models.OperationStatus:
-        """Provides the status of the asynchronous operations like backup, restore. The status can be in
+        """Fetches the status of an operation such as triggering a backup, restore. The status can be in
         progress, completed
-        or failed. You can refer to the Operation Status enum for all the possible states of an
+        or failed. You can refer to the OperationStatus enum for all the possible states of an
         operation. Some operations
-        create jobs. This method returns the list of jobs associated with operation.
+        create jobs. This method returns the list of jobs when the operation is complete.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param policy_name: Backup policy name whose operation's status needs to be fetched. Required.
-        :type policy_name: str
-        :param operation_id: Operation ID which represents an operation whose status needs to be
-         fetched. Required.
+        :param operation_id: OperationID which represents the operation. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -86,42 +116,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
-            policy_name=policy_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}/operations/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_points_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_points_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -76,15 +76,14 @@
         :type fabric_name: str
         :param container_name: Container name associated with the backed up item. Required.
         :type container_name: str
         :param protected_item_name: Backed up item whose backup copies are to be fetched. Required.
         :type protected_item_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RecoveryPointResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -100,76 +99,71 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     fabric_name=fabric_name,
                     container_name=container_name,
                     protected_item_name=protected_item_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RecoveryPointResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints"
-    }
-
     @distributed_trace_async
     async def get(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
@@ -192,15 +186,14 @@
         :type container_name: str
         :param protected_item_name: Backed up item name whose backup data needs to be fetched.
          Required.
         :type protected_item_name: str
         :param recovery_point_id: RecoveryPointID represents the backed up data to be fetched.
          Required.
         :type recovery_point_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RecoveryPointResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -211,44 +204,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.RecoveryPointResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("RecoveryPointResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_points_recommended_for_move_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_points_recommended_for_move_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -31,15 +31,15 @@
 from ...operations._recovery_points_recommended_for_move_operations import build_list_request
 from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class RecoveryPointsRecommendedForMoveOperations:
+class RecoveryPointsRecommendedForMoveOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
         :attr:`recovery_points_recommended_for_move` attribute.
@@ -82,15 +82,14 @@
         :type protected_item_name: str
         :param parameters: List Recovery points Recommended for Move Request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ListRecoveryPointsRecommendedForMoveRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RecoveryPointResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
@@ -98,15 +97,15 @@
     def list(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncIterable["_models.RecoveryPointResource"]:
         """Lists the recovery points recommended for move to another tier.
 
         :param vault_name: The name of the recovery services vault. Required.
@@ -117,19 +116,18 @@
         :param fabric_name: Required.
         :type fabric_name: str
         :param container_name: Required.
         :type container_name: str
         :param protected_item_name: Required.
         :type protected_item_name: str
         :param parameters: List Recovery points Recommended for Move Request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RecoveryPointResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
@@ -137,15 +135,15 @@
     def list(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: Union[_models.ListRecoveryPointsRecommendedForMoveRequest, IO],
+        parameters: Union[_models.ListRecoveryPointsRecommendedForMoveRequest, IO[bytes]],
         **kwargs: Any
     ) -> AsyncIterable["_models.RecoveryPointResource"]:
         """Lists the recovery points recommended for move to another tier.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
@@ -154,22 +152,18 @@
         :param fabric_name: Required.
         :type fabric_name: str
         :param container_name: Required.
         :type container_name: str
         :param protected_item_name: Required.
         :type protected_item_name: str
         :param parameters: List Recovery points Recommended for Move Request. Is either a
-         ListRecoveryPointsRecommendedForMoveRequest type or a IO type. Required.
+         ListRecoveryPointsRecommendedForMoveRequest type or a IO[bytes] type. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ListRecoveryPointsRecommendedForMoveRequest
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         or IO[bytes]
         :return: An iterator like instance of either RecoveryPointResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
@@ -193,70 +187,65 @@
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ListRecoveryPointsRecommendedForMoveRequest")
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     fabric_name=fabric_name,
                     container_name=container_name,
                     protected_item_name=protected_item_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
                     content_type=content_type,
                     json=_json,
                     content=_content,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RecoveryPointResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPointsRecommendedForMove"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_recovery_services_backup_client_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_services_backup_client_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -14,51 +14,194 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._recovery_services_backup_client_operations import (
-    build_bms_prepare_data_move_request,
-    build_bms_trigger_data_move_request,
-    build_get_operation_status_request,
-    build_move_recovery_point_request,
-)
-from .._vendor import RecoveryServicesBackupClientMixinABC
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_get_operation_status_request(
+    vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/operationStatus/{operationId}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_bms_prepare_data_move_request(
+    vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/prepareDataMove",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_bms_trigger_data_move_request(
+    vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/triggerDataMove",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_move_recovery_point_request(
+    vault_name: str,
+    resource_group_name: str,
+    fabric_name: str,
+    container_name: str,
+    protected_item_name: str,
+    recovery_point_id: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/move",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "fabricName": _SERIALIZER.url("fabric_name", fabric_name, "str"),
+        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
+        "protectedItemName": _SERIALIZER.url("protected_item_name", protected_item_name, "str"),
+        "recoveryPointId": _SERIALIZER.url("recovery_point_id", recovery_point_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-class RecoveryServicesBackupClientOperationsMixin(RecoveryServicesBackupClientMixinABC):
-    @distributed_trace_async
-    async def get_operation_status(
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class RecoveryServicesBackupClientOperationsMixin(  # pylint: disable=name-too-long
+    RecoveryServicesBackupClientMixinABC
+):
+    @distributed_trace
+    def get_operation_status(
         self, vault_name: str, resource_group_name: str, operation_id: str, **kwargs: Any
     ) -> _models.OperationStatus:
         """Fetches operation status for data move operation on vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -69,55 +212,50 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_operation_status_request(
+        _request = build_get_operation_status_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    get_operation_status.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/operationStatus/{operationId}"
-    }
-
-    async def _bms_prepare_data_move_initial(  # pylint: disable=inconsistent-return-statements
+    def _bms_prepare_data_move_initial(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.PrepareDataMoveRequest, IO],
+        parameters: Union[_models.PrepareDataMoveRequest, IO[bytes]],
         **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -135,203 +273,167 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "PrepareDataMoveRequest")
 
-        request = build_bms_prepare_data_move_request(
+        _request = build_bms_prepare_data_move_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._bms_prepare_data_move_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _bms_prepare_data_move_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/prepareDataMove"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
-    async def begin_bms_prepare_data_move(
+    def begin_bms_prepare_data_move(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.PrepareDataMoveRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Prepares source vault for Data Move operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Prepare data move request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrepareDataMoveRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_bms_prepare_data_move(
+    def begin_bms_prepare_data_move(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Prepares source vault for Data Move operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Prepare data move request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_bms_prepare_data_move(
+    @distributed_trace
+    def begin_bms_prepare_data_move(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.PrepareDataMoveRequest, IO],
+        parameters: Union[_models.PrepareDataMoveRequest, IO[bytes]],
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Prepares source vault for Data Move operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param parameters: Prepare data move request. Is either a PrepareDataMoveRequest type or a IO
-         type. Required.
+        :param parameters: Prepare data move request. Is either a PrepareDataMoveRequest type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrepareDataMoveRequest
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+         or IO[bytes]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._bms_prepare_data_move_initial(  # type: ignore
+            raw_result = self._bms_prepare_data_move_initial(  # type: ignore
                 vault_name=vault_name,
                 resource_group_name=resource_group_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_bms_prepare_data_move.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/prepareDataMove"
-    }
-
-    async def _bms_trigger_data_move_initial(  # pylint: disable=inconsistent-return-statements
+    def _bms_trigger_data_move_initial(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.TriggerDataMoveRequest, IO],
+        parameters: Union[_models.TriggerDataMoveRequest, IO[bytes]],
         **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -349,207 +451,171 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "TriggerDataMoveRequest")
 
-        request = build_bms_trigger_data_move_request(
+        _request = build_bms_trigger_data_move_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._bms_trigger_data_move_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _bms_trigger_data_move_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/triggerDataMove"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
-    async def begin_bms_trigger_data_move(
+    def begin_bms_trigger_data_move(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.TriggerDataMoveRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Triggers Data Move Operation on target vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Trigger data move request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TriggerDataMoveRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_bms_trigger_data_move(
+    def begin_bms_trigger_data_move(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Triggers Data Move Operation on target vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Trigger data move request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_bms_trigger_data_move(
+    @distributed_trace
+    def begin_bms_trigger_data_move(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.TriggerDataMoveRequest, IO],
+        parameters: Union[_models.TriggerDataMoveRequest, IO[bytes]],
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Triggers Data Move Operation on target vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param parameters: Trigger data move request. Is either a TriggerDataMoveRequest type or a IO
-         type. Required.
+        :param parameters: Trigger data move request. Is either a TriggerDataMoveRequest type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TriggerDataMoveRequest
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+         or IO[bytes]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._bms_trigger_data_move_initial(  # type: ignore
+            raw_result = self._bms_trigger_data_move_initial(  # type: ignore
                 vault_name=vault_name,
                 resource_group_name=resource_group_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_bms_trigger_data_move.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/triggerDataMove"
-    }
-
-    async def _move_recovery_point_initial(  # pylint: disable=inconsistent-return-statements
+    def _move_recovery_point_initial(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: Union[_models.MoveRPAcrossTiersRequest, IO],
+        parameters: Union[_models.MoveRPAcrossTiersRequest, IO[bytes]],
         **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -567,65 +633,60 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "MoveRPAcrossTiersRequest")
 
-        request = build_move_recovery_point_request(
+        _request = build_move_recovery_point_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._move_recovery_point_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _move_recovery_point_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/move"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
-    async def begin_move_recovery_point(
+    def begin_move_recovery_point(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
         parameters: _models.MoveRPAcrossTiersRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Move recovery point from one datastore to another store.
 
         Move recovery point from one datastore to another store.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
@@ -641,41 +702,33 @@
         :type recovery_point_id: str
         :param parameters: Move Resource Across Tiers Request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.MoveRPAcrossTiersRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_move_recovery_point(
+    def begin_move_recovery_point(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Move recovery point from one datastore to another store.
 
         Move recovery point from one datastore to another store.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
@@ -686,43 +739,35 @@
         :param container_name: Required.
         :type container_name: str
         :param protected_item_name: Required.
         :type protected_item_name: str
         :param recovery_point_id: Required.
         :type recovery_point_id: str
         :param parameters: Move Resource Across Tiers Request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_move_recovery_point(
+    @distributed_trace
+    def begin_move_recovery_point(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: Union[_models.MoveRPAcrossTiersRequest, IO],
+        parameters: Union[_models.MoveRPAcrossTiersRequest, IO[bytes]],
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Move recovery point from one datastore to another store.
 
         Move recovery point from one datastore to another store.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
@@ -733,43 +778,32 @@
         :param container_name: Required.
         :type container_name: str
         :param protected_item_name: Required.
         :type protected_item_name: str
         :param recovery_point_id: Required.
         :type recovery_point_id: str
         :param parameters: Move Resource Across Tiers Request. Is either a MoveRPAcrossTiersRequest
-         type or a IO type. Required.
+         type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.MoveRPAcrossTiersRequest or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.MoveRPAcrossTiersRequest or IO[bytes]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._move_recovery_point_initial(  # type: ignore
+            raw_result = self._move_recovery_point_initial(  # type: ignore
                 vault_name=vault_name,
                 resource_group_name=resource_group_name,
                 fabric_name=fabric_name,
                 container_name=container_name,
                 protected_item_name=protected_item_name,
                 recovery_point_id=recovery_point_id,
                 parameters=parameters,
@@ -780,27 +814,23 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_move_recovery_point.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/move"
-    }
+        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_resource_guard_proxies_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_jobs_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,147 +1,144 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
-import urllib.parse
+from typing import Any, Callable, Dict, Optional, TypeVar
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._resource_guard_proxies_operations import build_get_request
-from .._vendor import RecoveryServicesBackupClientMixinABC
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
 
-class ResourceGuardProxiesOperations:
+
+def build_export_request(
+    vault_name: str, resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobsExport",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
-        :attr:`resource_guard_proxies` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
+        :attr:`jobs` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def get(
-        self, vault_name: str, resource_group_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.ResourceGuardProxyBaseResource"]:
-        """List the ResourceGuardProxies under vault.
+    def export(  # pylint: disable=inconsistent-return-statements
+        self, vault_name: str, resource_group_name: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> None:
+        """Triggers export of jobs specified by filters and returns an OperationID to track.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ResourceGuardProxyBaseResource or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource]
+        :param filter: OData filter options. Default value is None.
+        :type filter: str
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ResourceGuardProxyBaseResourceList] = kwargs.pop("cls", None)
-
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                request = build_get_request(
-                    vault_name=vault_name,
-                    resource_group_name=resource_group_name,
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.get.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("ResourceGuardProxyBaseResourceList", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
-
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-            return pipeline_response
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        return AsyncItemPaged(get_next, extract_data)
+        _request = build_export_request(
+            vault_name=vault_name,
+            resource_group_name=resource_group_name,
+            subscription_id=self._config.subscription_id,
+            filter=filter,
+            api_version=api_version,
+            headers=_headers,
+            params=_params,
+        )
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies"
-    }
+        if cls:
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_resource_guard_proxy_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_resource_guard_proxy_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -66,15 +66,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ResourceGuardProxyBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -85,48 +84,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ResourceGuardProxyBaseResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             resource_guard_proxy_name=resource_guard_proxy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ResourceGuardProxyBaseResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def put(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
@@ -147,27 +141,26 @@
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ResourceGuardProxyBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def put(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ResourceGuardProxyBaseResource:
         """Add or Update ResourceGuardProxy under vault
         Secures vault critical operations.
 
@@ -175,51 +168,47 @@
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ResourceGuardProxyBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def put(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
-        parameters: Union[_models.ResourceGuardProxyBaseResource, IO],
+        parameters: Union[_models.ResourceGuardProxyBaseResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.ResourceGuardProxyBaseResource:
         """Add or Update ResourceGuardProxy under vault
         Secures vault critical operations.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Is either a ResourceGuardProxyBaseResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource or
+         IO[bytes]
         :return: ResourceGuardProxyBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -239,66 +228,60 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ResourceGuardProxyBaseResource")
 
-        request = build_put_request(
+        _request = build_put_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             resource_guard_proxy_name=resource_guard_proxy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ResourceGuardProxyBaseResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    put.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}"
-    }
+        return deserialized  # type: ignore
 
     @distributed_trace_async
     async def delete(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, resource_guard_proxy_name: str, **kwargs: Any
     ) -> None:
         """Delete ResourceGuardProxy under vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -309,44 +292,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             resource_guard_proxy_name=resource_guard_proxy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
     async def unlock_delete(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
@@ -365,77 +343,71 @@
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: UnlockDeleteResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def unlock_delete(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.UnlockDeleteResponse:
         """Secures delete ResourceGuardProxy operations.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: UnlockDeleteResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def unlock_delete(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
-        parameters: Union[_models.UnlockDeleteRequest, IO],
+        parameters: Union[_models.UnlockDeleteRequest, IO[bytes]],
         **kwargs: Any
     ) -> _models.UnlockDeleteResponse:
         """Secures delete ResourceGuardProxy operations.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
-        :param parameters: Request body for operation. Is either a UnlockDeleteRequest type or a IO
-         type. Required.
+        :param parameters: Request body for operation. Is either a UnlockDeleteRequest type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteRequest or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         IO[bytes]
         :return: UnlockDeleteResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -455,44 +427,39 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "UnlockDeleteRequest")
 
-        request = build_unlock_delete_request(
+        _request = build_unlock_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             resource_guard_proxy_name=resource_guard_proxy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.unlock_delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("UnlockDeleteResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    unlock_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}/unlockDelete"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_restores_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_restores_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -58,15 +58,16 @@
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: Union[_models.RestoreRequestResource, IO],
+        parameters: Union[_models.RestoreRequestResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -84,61 +85,58 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RestoreRequestResource")
 
-        request = build_trigger_request(
+        _request = build_trigger_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._trigger_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _trigger_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/restore"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
     async def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
         parameters: _models.RestoreRequestResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Restores the specified backed up data. This is an asynchronous operation. To know the status of
         this API call, use
         GetProtectedItemOperationResult API.
@@ -155,40 +153,35 @@
         :param protected_item_name: Backed up item to be restored. Required.
         :type protected_item_name: str
         :param recovery_point_id: Recovery point ID which represents the backed up data to be restored.
          Required.
         :type recovery_point_id: str
         :param parameters: resource restore request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.RestoreRequestResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Restores the specified backed up data. This is an asynchronous operation. To know the status of
         this API call, use
         GetProtectedItemOperationResult API.
@@ -204,41 +197,36 @@
         :type container_name: str
         :param protected_item_name: Backed up item to be restored. Required.
         :type protected_item_name: str
         :param recovery_point_id: Recovery point ID which represents the backed up data to be restored.
          Required.
         :type recovery_point_id: str
         :param parameters: resource restore request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: Union[_models.RestoreRequestResource, IO],
+        parameters: Union[_models.RestoreRequestResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Restores the specified backed up data. This is an asynchronous operation. To know the status of
         this API call, use
         GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
@@ -251,29 +239,20 @@
         :param container_name: Container name associated with the backed up items. Required.
         :type container_name: str
         :param protected_item_name: Backed up item to be restored. Required.
         :type protected_item_name: str
         :param recovery_point_id: Recovery point ID which represents the backed up data to be restored.
          Required.
         :type recovery_point_id: str
-        :param parameters: resource restore request. Is either a RestoreRequestResource type or a IO
-         type. Required.
+        :param parameters: resource restore request. Is either a RestoreRequestResource type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.RestoreRequestResource
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
+         or IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -288,38 +267,35 @@
                 vault_name=vault_name,
                 resource_group_name=resource_group_name,
                 fabric_name=fabric_name,
                 container_name=container_name,
                 protected_item_name=protected_item_name,
                 recovery_point_id=recovery_point_id,
                 parameters=parameters,
+                x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return AsyncLROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/restore"
-    }
+        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_security_pins_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_security_pins_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -53,87 +53,91 @@
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @overload
     async def get(
         self,
         vault_name: str,
         resource_group_name: str,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         parameters: Optional[_models.SecurityPinBase] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.TokenInformation:
         """Get the security PIN.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :param parameters: security pin request. Default value is None.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.SecurityPinBase
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: TokenInformation or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TokenInformation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def get(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Optional[IO] = None,
+        x_ms_authorization_auxiliary: Optional[str] = None,
+        parameters: Optional[IO[bytes]] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.TokenInformation:
         """Get the security PIN.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :param parameters: security pin request. Default value is None.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: TokenInformation or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TokenInformation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def get(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Optional[Union[_models.SecurityPinBase, IO]] = None,
+        x_ms_authorization_auxiliary: Optional[str] = None,
+        parameters: Optional[Union[_models.SecurityPinBase, IO[bytes]]] = None,
         **kwargs: Any
     ) -> _models.TokenInformation:
         """Get the security PIN.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param parameters: security pin request. Is either a SecurityPinBase type or a IO type. Default
-         value is None.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.SecurityPinBase or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
+        :param parameters: security pin request. Is either a SecurityPinBase type or a IO[bytes] type.
          Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.SecurityPinBase or
+         IO[bytes]
         :return: TokenInformation or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TokenInformation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -156,43 +160,39 @@
             _content = parameters
         else:
             if parameters is not None:
                 _json = self._serialize.body(parameters, "SecurityPinBase")
             else:
                 _json = None
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("TokenInformation", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupSecurityPIN"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_tiering_cost_operation_status_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_tiering_cost_operation_status_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -60,15 +60,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -79,41 +78,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             resource_group_name=resource_group_name,
             vault_name=vault_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/operationsStatus/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -14,55 +14,91 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._validate_operation_operations import build_trigger_request
-from .._vendor import RecoveryServicesBackupClientMixinABC
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_trigger_request(
+    vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTriggerValidateOperation",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class ValidateOperationOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
         :attr:`validate_operation` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _trigger_initial(  # pylint: disable=inconsistent-return-statements
+    def _trigger_initial(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.ValidateOperationRequestResource, IO],
+        parameters: Union[_models.ValidateOperationRequestResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -80,193 +116,158 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ValidateOperationRequestResource")
 
-        request = build_trigger_request(
+        _request = build_trigger_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._trigger_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _trigger_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTriggerValidateOperation"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
-    async def begin_trigger(
+    def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.ValidateOperationRequestResource,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Validate operation for specified backed up item in the form of an asynchronous operation.
         Returns tracking headers which can be tracked using GetValidateOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_trigger(
+    def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Validate operation for specified backed up item in the form of an asynchronous operation.
         Returns tracking headers which can be tracked using GetValidateOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_trigger(
+    @distributed_trace
+    def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.ValidateOperationRequestResource, IO],
+        parameters: Union[_models.ValidateOperationRequestResource, IO[bytes]],
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Validate operation for specified backed up item in the form of an asynchronous operation.
         Returns tracking headers which can be tracked using GetValidateOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Is either a
-         ValidateOperationRequestResource type or a IO type. Required.
+         ValidateOperationRequestResource type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource or
+         IO[bytes]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._trigger_initial(  # type: ignore
+            raw_result = self._trigger_initial(  # type: ignore
                 vault_name=vault_name,
                 resource_group_name=resource_group_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTriggerValidateOperation"
-    }
+        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_results_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -61,15 +61,14 @@
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param operation_id: OperationID which represents the operation whose result needs to be
          fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidateOperationsResponse or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationsResponse or
          None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
@@ -81,43 +80,38 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Optional[_models.ValidateOperationsResponse]] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("ValidateOperationsResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_statuses_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_statuses_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -65,15 +65,14 @@
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param operation_id: OperationID represents the operation whose status needs to be fetched.
          Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -84,41 +83,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperationsStatuses/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/models/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/models/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -336,14 +336,15 @@
 from ._recovery_services_backup_client_enums import EncryptionAtRestType
 from ._recovery_services_backup_client_enums import EnhancedSecurityState
 from ._recovery_services_backup_client_enums import FabricName
 from ._recovery_services_backup_client_enums import HealthState
 from ._recovery_services_backup_client_enums import HealthStatus
 from ._recovery_services_backup_client_enums import HttpStatusCode
 from ._recovery_services_backup_client_enums import IAASVMPolicyType
+from ._recovery_services_backup_client_enums import IaasVMSnapshotConsistencyType
 from ._recovery_services_backup_client_enums import InfrastructureEncryptionState
 from ._recovery_services_backup_client_enums import InquiryStatus
 from ._recovery_services_backup_client_enums import IntentItemType
 from ._recovery_services_backup_client_enums import JobOperationType
 from ._recovery_services_backup_client_enums import JobStatus
 from ._recovery_services_backup_client_enums import JobSupportedAction
 from ._recovery_services_backup_client_enums import LastBackupStatus
@@ -723,14 +724,15 @@
     "EncryptionAtRestType",
     "EnhancedSecurityState",
     "FabricName",
     "HealthState",
     "HealthStatus",
     "HttpStatusCode",
     "IAASVMPolicyType",
+    "IaasVMSnapshotConsistencyType",
     "InfrastructureEncryptionState",
     "InquiryStatus",
     "IntentItemType",
     "JobOperationType",
     "JobStatus",
     "JobSupportedAction",
     "LastBackupStatus",
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_models_py3.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_models_py3.py`

 * *Files 0% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 
 class FeatureSupportRequest(_serialization.Model):
     """Base class for feature request.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureBackupGoalFeatureSupportRequest, AzureVMResourceFeatureSupportRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar feature_type: backup support feature type. Required.
     :vartype feature_type: str
     """
 
     _validation = {
         "feature_type": {"required": True},
@@ -49,15 +49,15 @@
         super().__init__(**kwargs)
         self.feature_type: Optional[str] = None
 
 
 class AzureBackupGoalFeatureSupportRequest(FeatureSupportRequest):
     """Azure backup goal feature specific request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar feature_type: backup support feature type. Required.
     :vartype feature_type: str
     """
 
     _validation = {
         "feature_type": {"required": True},
@@ -77,15 +77,15 @@
     """Base class for container with backup items. Containers with specific workloads are derived from
     this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureSqlContainer, AzureWorkloadContainer, DpmContainer, GenericContainer, IaaSVMContainer,
     AzureStorageContainer, MabContainer
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -176,15 +176,15 @@
 
 class DpmContainer(ProtectionContainer):  # pylint: disable=too-many-instance-attributes
     """DPM workload-specific protection container.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureBackupServerContainer
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -322,15 +322,15 @@
         self.protection_status = protection_status
         self.extended_info = extended_info
 
 
 class AzureBackupServerContainer(DpmContainer):  # pylint: disable=too-many-instance-attributes
     """AzureBackupServer (DPMVenus) workload-specific protection container.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -469,15 +469,15 @@
 
 class BackupEngineBase(_serialization.Model):  # pylint: disable=too-many-instance-attributes
     """The base backup engine class. All workload specific backup engines derive from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureBackupServerEngine, DpmBackupEngine
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the backup engine.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the backup engine. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -604,15 +604,15 @@
         self.is_dpm_upgrade_available = is_dpm_upgrade_available
         self.extended_info = extended_info
 
 
 class AzureBackupServerEngine(BackupEngineBase):  # pylint: disable=too-many-instance-attributes
     """Backup engine type when Azure Backup Server is used to manage the backups.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the backup engine.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the backup engine. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -737,15 +737,15 @@
 
 class BackupRequest(_serialization.Model):
     """Base class for backup request. Workload-specific backup requests are derived from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureFileShareBackupRequest, AzureWorkloadBackupRequest, IaasVMBackupRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -769,15 +769,15 @@
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
 
 
 class AzureFileShareBackupRequest(BackupRequest):
     """AzureFileShare workload-specific backup request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_expiry_time_in_utc: Backup copy will expire after the time specified
      (UTC).
     :vartype recovery_point_expiry_time_in_utc: ~datetime.datetime
@@ -805,15 +805,15 @@
 
 class WorkloadProtectableItem(_serialization.Model):
     """Base class for backup item. Workload-specific backup items are derived from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureFileShareProtectableItem, AzureVmWorkloadProtectableItem, IaaSVMProtectableItem
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -873,15 +873,15 @@
         self.friendly_name = friendly_name
         self.protection_state = protection_state
 
 
 class AzureFileShareProtectableItem(WorkloadProtectableItem):
     """Protectable item for Azure Fileshare workloads.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -970,15 +970,15 @@
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureFileshareProtectedItem, AzureIaaSVMProtectedItem, AzureVmWorkloadProtectedItem,
     DPMProtectedItem, GenericProtectedItem, MabFileFolderProtectedItem, AzureSqlProtectedItem
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -1152,15 +1152,15 @@
 
 
 class AzureFileshareProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """Azure File Share workload-specific backup item.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -1440,15 +1440,15 @@
 class ProtectionPolicy(_serialization.Model):
     """Base class for backup policy. Workload-specific backup policies are derived from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureIaaSVMProtectionPolicy, AzureSqlProtectionPolicy, AzureFileShareProtectionPolicy,
     AzureVmWorkloadProtectionPolicy, GenericProtectionPolicy, MabProtectionPolicy
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_items_count: Number of items associated with this policy.
     :vartype protected_items_count: int
     :ivar backup_management_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype backup_management_type: str
     :ivar resource_guard_operation_requests: ResourceGuard Operation Requests.
@@ -1494,15 +1494,15 @@
         self.backup_management_type: Optional[str] = None
         self.resource_guard_operation_requests = resource_guard_operation_requests
 
 
 class AzureFileShareProtectionPolicy(ProtectionPolicy):
     """AzureStorage backup policy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_items_count: Number of items associated with this policy.
     :vartype protected_items_count: int
     :ivar backup_management_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype backup_management_type: str
     :ivar resource_guard_operation_requests: ResourceGuard Operation Requests.
@@ -1594,15 +1594,15 @@
 
 class ILRRequest(_serialization.Model):
     """Parameters to Provision ILR API.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureFileShareProvisionILRRequest, IaasVMILRRegistrationRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -1625,15 +1625,15 @@
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
 
 
 class AzureFileShareProvisionILRRequest(ILRRequest):
     """Update snapshot Uri with the correct friendly Name of the source Azure file share.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_id: Recovery point ID.
     :vartype recovery_point_id: str
     :ivar source_resource_id: Source Storage account ARM Id.
@@ -1668,15 +1668,15 @@
 class RecoveryPoint(_serialization.Model):
     """Base class for backup copies. Workload-specific backup copies are derived from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureFileShareRecoveryPoint, AzureWorkloadRecoveryPoint, GenericRecoveryPoint,
     IaasVMRecoveryPoint
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -1701,15 +1701,15 @@
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
 
 
 class AzureFileShareRecoveryPoint(RecoveryPoint):
     """Azure File Share workload specific backup copy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_type: Type of the backup copy. Specifies whether it is a crash consistent
      backup or app consistent.
     :vartype recovery_point_type: str
@@ -1772,51 +1772,63 @@
 
 class RestoreRequest(_serialization.Model):
     """Base class for restore request. Workload-specific restore requests are derived from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureFileShareRestoreRequest, AzureWorkloadRestoreRequest, IaasVMRestoreRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     """
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
     }
 
     _subtype_map = {
         "object_type": {
             "AzureFileShareRestoreRequest": "AzureFileShareRestoreRequest",
             "AzureWorkloadRestoreRequest": "AzureWorkloadRestoreRequest",
             "IaasVMRestoreRequest": "IaasVMRestoreRequest",
         }
     }
 
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
+    def __init__(self, *, resource_guard_operation_requests: Optional[List[str]] = None, **kwargs: Any) -> None:
+        """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
+        """
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
+        self.resource_guard_operation_requests = resource_guard_operation_requests
 
 
 class AzureFileShareRestoreRequest(RestoreRequest):
     """AzureFileShare Restore Request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Source storage account ARM Id.
     :vartype source_resource_id: str
     :ivar copy_options: Options to resolve copy conflicts. Known values are: "Invalid",
@@ -1837,34 +1849,39 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "copy_options": {"key": "copyOptions", "type": "str"},
         "restore_request_type": {"key": "restoreRequestType", "type": "str"},
         "restore_file_specs": {"key": "restoreFileSpecs", "type": "[RestoreFileSpecs]"},
         "target_details": {"key": "targetDetails", "type": "TargetAFSRestoreInfo"},
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         copy_options: Optional[Union[str, "_models.CopyOptions"]] = None,
         restore_request_type: Optional[Union[str, "_models.RestoreRequestType"]] = None,
         restore_file_specs: Optional[List["_models.RestoreFileSpecs"]] = None,
         target_details: Optional["_models.TargetAFSRestoreInfo"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Source storage account ARM Id.
         :paramtype source_resource_id: str
         :keyword copy_options: Options to resolve copy conflicts. Known values are: "Invalid",
@@ -1879,15 +1896,15 @@
          TargetFolderPath details.
         :paramtype restore_file_specs:
          list[~azure.mgmt.recoveryservicesbackup.activestamp.models.RestoreFileSpecs]
         :keyword target_details: Target File Share Details.
         :paramtype target_details:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.TargetAFSRestoreInfo
         """
-        super().__init__(**kwargs)
+        super().__init__(resource_guard_operation_requests=resource_guard_operation_requests, **kwargs)
         self.object_type: str = "AzureFileShareRestoreRequest"
         self.recovery_type = recovery_type
         self.source_resource_id = source_resource_id
         self.copy_options = copy_options
         self.restore_request_type = restore_request_type
         self.restore_file_specs = restore_file_specs
         self.target_details = target_details
@@ -1895,15 +1912,15 @@
 
 class IaaSVMContainer(ProtectionContainer):
     """IaaS VM workload-specific container.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureIaaSClassicComputeVMContainer, AzureIaaSComputeVMContainer
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -2013,15 +2030,15 @@
         self.virtual_machine_version = virtual_machine_version
         self.resource_group = resource_group
 
 
 class AzureIaaSClassicComputeVMContainer(IaaSVMContainer):
     """IaaS VM workload-specific backup item representing a classic virtual machine.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -2127,15 +2144,15 @@
 
 class IaaSVMProtectableItem(WorkloadProtectableItem):
     """IaaS VM workload-specific backup item.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureIaaSClassicComputeVMProtectableItem, AzureIaaSComputeVMProtectableItem
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -2219,15 +2236,15 @@
         self.virtual_machine_version = virtual_machine_version
         self.resource_group = resource_group
 
 
 class AzureIaaSClassicComputeVMProtectableItem(IaaSVMProtectableItem):
     """IaaS VM workload-specific backup item representing the Classic Compute VM.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -2309,15 +2326,15 @@
     """IaaS VM workload-specific backup item.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureIaaSClassicComputeVMProtectedItem, AzureIaaSComputeVMProtectedItem
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -2576,15 +2593,15 @@
 
 
 class AzureIaaSClassicComputeVMProtectedItem(AzureIaaSVMProtectedItem):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload-specific backup item representing the Classic Compute VM.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -2829,15 +2846,15 @@
         )
         self.protected_item_type: str = "Microsoft.ClassicCompute/virtualMachines"
 
 
 class AzureIaaSComputeVMContainer(IaaSVMContainer):
     """IaaS VM workload-specific backup item representing an Azure Resource Manager virtual machine.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -2940,15 +2957,15 @@
         )
         self.container_type: str = "Microsoft.Compute/virtualMachines"
 
 
 class AzureIaaSComputeVMProtectableItem(IaaSVMProtectableItem):
     """IaaS VM workload-specific backup item representing the Azure Resource Manager VM.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -3027,15 +3044,15 @@
 
 
 class AzureIaaSComputeVMProtectedItem(AzureIaaSVMProtectedItem):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload-specific backup item representing the Azure Resource Manager VM.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -3368,40 +3385,22 @@
     :vartype title: str
     :ivar message: Health Message.
     :vartype message: str
     :ivar recommendations: Health Recommended Actions.
     :vartype recommendations: list[str]
     """
 
-    _validation = {
-        "code": {"readonly": True},
-        "title": {"readonly": True},
-        "message": {"readonly": True},
-        "recommendations": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "code": {"key": "code", "type": "int"},
-        "title": {"key": "title", "type": "str"},
-        "message": {"key": "message", "type": "str"},
-        "recommendations": {"key": "recommendations", "type": "[str]"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-
 
 class Job(_serialization.Model):
     """Defines workload agnostic properties for a job.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureIaaSVMJob, AzureIaaSVMJobV2, AzureStorageJob, AzureWorkloadJob, DpmJob, MabJob, VaultJob
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -3490,15 +3489,15 @@
         self.activity_id = activity_id
         self.job_type: Optional[str] = None
 
 
 class AzureIaaSVMJob(Job):  # pylint: disable=too-many-instance-attributes
     """Azure IaaS VM workload-specific job object.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -3774,15 +3773,15 @@
         self.progress_percentage = progress_percentage
         self.task_execution_details = task_execution_details
 
 
 class AzureIaaSVMJobV2(Job):  # pylint: disable=too-many-instance-attributes
     """Azure IaaS VM workload-specific job object.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -3978,18 +3977,18 @@
         self.oldest_recovery_point_in_vault = oldest_recovery_point_in_vault
         self.oldest_recovery_point_in_archive = oldest_recovery_point_in_archive
         self.newest_recovery_point_in_archive = newest_recovery_point_in_archive
         self.recovery_point_count = recovery_point_count
         self.policy_inconsistent = policy_inconsistent
 
 
-class AzureIaaSVMProtectionPolicy(ProtectionPolicy):
+class AzureIaaSVMProtectionPolicy(ProtectionPolicy):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload-specific backup policy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_items_count: Number of items associated with this policy.
     :vartype protected_items_count: int
     :ivar backup_management_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype backup_management_type: str
     :ivar resource_guard_operation_requests: ResourceGuard Operation Requests.
@@ -4011,14 +4010,17 @@
     :vartype instant_rp_retention_range_in_days: int
     :ivar time_zone: TimeZone optional input as string. For example: TimeZone = "Pacific Standard
      Time".
     :vartype time_zone: str
     :ivar policy_type: Known values are: "Invalid", "V1", and "V2".
     :vartype policy_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.IAASVMPolicyType
+    :ivar snapshot_consistency_type: "OnlyCrashConsistent"
+    :vartype snapshot_consistency_type: str or
+     ~azure.mgmt.recoveryservicesbackup.activestamp.models.IaasVMSnapshotConsistencyType
     """
 
     _validation = {
         "backup_management_type": {"required": True},
     }
 
     _attribute_map = {
@@ -4028,28 +4030,30 @@
         "instant_rp_details": {"key": "instantRPDetails", "type": "InstantRPAdditionalDetails"},
         "schedule_policy": {"key": "schedulePolicy", "type": "SchedulePolicy"},
         "retention_policy": {"key": "retentionPolicy", "type": "RetentionPolicy"},
         "tiering_policy": {"key": "tieringPolicy", "type": "{TieringPolicy}"},
         "instant_rp_retention_range_in_days": {"key": "instantRpRetentionRangeInDays", "type": "int"},
         "time_zone": {"key": "timeZone", "type": "str"},
         "policy_type": {"key": "policyType", "type": "str"},
+        "snapshot_consistency_type": {"key": "snapshotConsistencyType", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         protected_items_count: Optional[int] = None,
         resource_guard_operation_requests: Optional[List[str]] = None,
         instant_rp_details: Optional["_models.InstantRPAdditionalDetails"] = None,
         schedule_policy: Optional["_models.SchedulePolicy"] = None,
         retention_policy: Optional["_models.RetentionPolicy"] = None,
         tiering_policy: Optional[Dict[str, "_models.TieringPolicy"]] = None,
         instant_rp_retention_range_in_days: Optional[int] = None,
         time_zone: Optional[str] = None,
         policy_type: Optional[Union[str, "_models.IAASVMPolicyType"]] = None,
+        snapshot_consistency_type: Optional[Union[str, "_models.IaasVMSnapshotConsistencyType"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword protected_items_count: Number of items associated with this policy.
         :paramtype protected_items_count: int
         :keyword resource_guard_operation_requests: ResourceGuard Operation Requests.
         :paramtype resource_guard_operation_requests: list[str]
@@ -4071,38 +4075,42 @@
         :paramtype instant_rp_retention_range_in_days: int
         :keyword time_zone: TimeZone optional input as string. For example: TimeZone = "Pacific
          Standard Time".
         :paramtype time_zone: str
         :keyword policy_type: Known values are: "Invalid", "V1", and "V2".
         :paramtype policy_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.IAASVMPolicyType
+        :keyword snapshot_consistency_type: "OnlyCrashConsistent"
+        :paramtype snapshot_consistency_type: str or
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.IaasVMSnapshotConsistencyType
         """
         super().__init__(
             protected_items_count=protected_items_count,
             resource_guard_operation_requests=resource_guard_operation_requests,
             **kwargs
         )
         self.backup_management_type: str = "AzureIaasVM"
         self.instant_rp_details = instant_rp_details
         self.schedule_policy = schedule_policy
         self.retention_policy = retention_policy
         self.tiering_policy = tiering_policy
         self.instant_rp_retention_range_in_days = instant_rp_retention_range_in_days
         self.time_zone = time_zone
         self.policy_type = policy_type
+        self.snapshot_consistency_type = snapshot_consistency_type
 
 
 class ProtectionIntent(_serialization.Model):
     """Base class for backup ProtectionIntent.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureResourceProtectionIntent, AzureWorkloadContainerAutoProtectionIntent,
     AzureRecoveryServiceVaultProtectionIntent
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protection_intent_item_type: backup protectionIntent type. Required. Known values are:
      "Invalid", "AzureResourceItem", "RecoveryServiceVaultItem",
      "AzureWorkloadContainerAutoProtectionIntent", "AzureWorkloadAutoProtectionIntent", and
      "AzureWorkloadSQLAutoProtectionIntent".
     :vartype protection_intent_item_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentItemType
@@ -4178,21 +4186,21 @@
         self.backup_management_type = backup_management_type
         self.source_resource_id = source_resource_id
         self.item_id = item_id
         self.policy_id = policy_id
         self.protection_state = protection_state
 
 
-class AzureRecoveryServiceVaultProtectionIntent(ProtectionIntent):
+class AzureRecoveryServiceVaultProtectionIntent(ProtectionIntent):  # pylint: disable=name-too-long
     """Azure Recovery Services Vault specific protection intent item.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadAutoProtectionIntent
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protection_intent_item_type: backup protectionIntent type. Required. Known values are:
      "Invalid", "AzureResourceItem", "RecoveryServiceVaultItem",
      "AzureWorkloadContainerAutoProtectionIntent", "AzureWorkloadAutoProtectionIntent", and
      "AzureWorkloadSQLAutoProtectionIntent".
     :vartype protection_intent_item_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentItemType
@@ -4269,15 +4277,15 @@
         )
         self.protection_intent_item_type: str = "RecoveryServiceVaultItem"
 
 
 class AzureResourceProtectionIntent(ProtectionIntent):
     """IaaS VM specific backup protection intent item.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protection_intent_item_type: backup protectionIntent type. Required. Known values are:
      "Invalid", "AzureResourceItem", "RecoveryServiceVaultItem",
      "AzureWorkloadContainerAutoProtectionIntent", "AzureWorkloadAutoProtectionIntent", and
      "AzureWorkloadSQLAutoProtectionIntent".
     :vartype protection_intent_item_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentItemType
@@ -4360,15 +4368,15 @@
 
 class AzureWorkloadContainer(ProtectionContainer):  # pylint: disable=too-many-instance-attributes
     """Container for the workloads running inside Azure Compute or Classic Compute.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureSQLAGWorkloadContainerProtectionContainer, AzureVMAppContainerProtectionContainer
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -4503,18 +4511,18 @@
         self.extended_info = extended_info
         self.workload_type = workload_type
         self.operation_type = operation_type
 
 
 class AzureSQLAGWorkloadContainerProtectionContainer(
     AzureWorkloadContainer
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Container for SQL workloads under SQL Availability Group.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -4643,15 +4651,15 @@
         )
         self.container_type: str = "SQLAGWorkLoadContainer"
 
 
 class AzureSqlContainer(ProtectionContainer):
     """Azure Sql workload-specific container.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -4731,15 +4739,15 @@
 
 
 class AzureSqlProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """Azure SQL workload-specific backup item.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -4969,15 +4977,15 @@
         self.recovery_point_count = recovery_point_count
         self.policy_state = policy_state
 
 
 class AzureSqlProtectionPolicy(ProtectionPolicy):
     """Azure SQL workload-specific backup policy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_items_count: Number of items associated with this policy.
     :vartype protected_items_count: int
     :ivar backup_management_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype backup_management_type: str
     :ivar resource_guard_operation_requests: ResourceGuard Operation Requests.
@@ -5023,15 +5031,15 @@
         self.backup_management_type: str = "AzureSql"
         self.retention_policy = retention_policy
 
 
 class AzureStorageContainer(ProtectionContainer):  # pylint: disable=too-many-instance-attributes
     """Azure Storage Account workload-specific container.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -5187,15 +5195,15 @@
         self.error_string = error_string
         self.recommendations = recommendations
 
 
 class AzureStorageJob(Job):  # pylint: disable=too-many-instance-attributes
     """Azure storage specific job.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -5401,15 +5409,15 @@
 
 class ProtectableContainer(_serialization.Model):
     """Protectable Container Class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureStorageProtectableContainer, AzureVMAppContainerProtectableContainer
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -5480,15 +5488,15 @@
         self.health_status = health_status
         self.container_id = container_id
 
 
 class AzureStorageProtectableContainer(ProtectableContainer):
     """Azure Storage-specific protectable containers.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -5554,15 +5562,15 @@
         )
         self.protectable_container_type: str = "StorageContainer"
 
 
 class AzureVMAppContainerProtectableContainer(ProtectableContainer):
     """Azure workload-specific container.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -5628,15 +5636,15 @@
         )
         self.protectable_container_type: str = "VMAppContainer"
 
 
 class AzureVMAppContainerProtectionContainer(AzureWorkloadContainer):  # pylint: disable=too-many-instance-attributes
     """Container for SQL workloads under Azure Virtual Machines.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -5765,15 +5773,15 @@
         )
         self.container_type: str = "VMAppContainer"
 
 
 class AzureVMResourceFeatureSupportRequest(FeatureSupportRequest):
     """AzureResource(IaaS VM) Specific feature support request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar feature_type: backup support feature type. Required.
     :vartype feature_type: str
     :ivar vm_size: Size of the resource: VM size(A/D series etc) in case of IaasVM.
     :vartype vm_size: str
     :ivar vm_sku: SKUs (Premium/Managed etc) in case of IaasVM.
     :vartype vm_sku: str
@@ -5828,15 +5836,15 @@
 
 class WorkloadItem(_serialization.Model):
     """Base class for backup item. Workload-specific backup items are derived from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureVmWorkloadItem
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar workload_item_type: Type of the backup item. Required.
     :vartype workload_item_type: str
@@ -5895,15 +5903,15 @@
     """Azure VM workload-specific workload item.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureVmWorkloadSAPAseDatabaseWorkloadItem, AzureVmWorkloadSAPAseSystemWorkloadItem,
     AzureVmWorkloadSAPHanaDatabaseWorkloadItem, AzureVmWorkloadSAPHanaSystemWorkloadItem,
     AzureVmWorkloadSQLDatabaseWorkloadItem, AzureVmWorkloadSQLInstanceWorkloadItem
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar workload_item_type: Type of the backup item. Required.
     :vartype workload_item_type: str
@@ -6010,15 +6018,15 @@
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureVmWorkloadSAPHanaHSRProtectableItem, AzureVmWorkloadSAPAseSystemProtectableItem,
     AzureVmWorkloadSAPHanaDBInstance, AzureVmWorkloadSAPHanaDatabaseProtectableItem,
     AzureVmWorkloadSAPHanaSystemProtectableItem,
     AzureVmWorkloadSQLAvailabilityGroupProtectableItem, AzureVmWorkloadSQLDatabaseProtectableItem,
     AzureVmWorkloadSQLInstanceProtectableItem
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -6160,15 +6168,15 @@
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureVmWorkloadSAPAseDatabaseProtectedItem, AzureVmWorkloadSAPHanaDBInstanceProtectedItem,
     AzureVmWorkloadSAPHanaDatabaseProtectedItem, AzureVmWorkloadSQLDatabaseProtectedItem
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -6535,15 +6543,15 @@
         self.policy_state = policy_state
         self.recovery_model = recovery_model
 
 
 class AzureVmWorkloadProtectionPolicy(ProtectionPolicy):
     """Azure VM (Mercury) workload-specific backup policy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_items_count: Number of items associated with this policy.
     :vartype protected_items_count: int
     :ivar backup_management_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype backup_management_type: str
     :ivar resource_guard_operation_requests: ResourceGuard Operation Requests.
@@ -6619,20 +6627,20 @@
         self.settings = settings
         self.sub_protection_policy = sub_protection_policy
         self.make_policy_consistent = make_policy_consistent
 
 
 class AzureVmWorkloadSAPAseDatabaseProtectedItem(
     AzureVmWorkloadProtectedItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protected item representing SAP ASE Database.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -6906,18 +6914,18 @@
             kpis_healths=kpis_healths,
             nodes_list=nodes_list,
             **kwargs
         )
         self.protected_item_type: str = "AzureVmWorkloadSAPAseDatabase"
 
 
-class AzureVmWorkloadSAPAseDatabaseWorkloadItem(AzureVmWorkloadItem):
+class AzureVmWorkloadSAPAseDatabaseWorkloadItem(AzureVmWorkloadItem):  # pylint: disable=name-too-long
     """Azure VM workload-specific workload item representing SAP ASE Database.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar workload_item_type: Type of the backup item. Required.
     :vartype workload_item_type: str
@@ -7005,18 +7013,18 @@
             **kwargs
         )
         self.workload_item_type: str = "SAPAseDatabase"
 
 
 class AzureVmWorkloadSAPAseSystemProtectableItem(
     AzureVmWorkloadProtectableItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protectable item representing SAP ASE System.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -7139,15 +7147,15 @@
         )
         self.protectable_item_type: str = "SAPAseSystem"
 
 
 class AzureVmWorkloadSAPAseSystemWorkloadItem(AzureVmWorkloadItem):
     """Azure VM workload-specific workload item representing SAP ASE System.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar workload_item_type: Type of the backup item. Required.
     :vartype workload_item_type: str
@@ -7235,18 +7243,18 @@
             **kwargs
         )
         self.workload_item_type: str = "SAPAseSystem"
 
 
 class AzureVmWorkloadSAPHanaDatabaseProtectableItem(
     AzureVmWorkloadProtectableItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protectable item representing SAP HANA Database.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -7368,20 +7376,20 @@
             **kwargs
         )
         self.protectable_item_type: str = "SAPHanaDatabase"
 
 
 class AzureVmWorkloadSAPHanaDatabaseProtectedItem(
     AzureVmWorkloadProtectedItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protected item representing SAP HANA Database.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -7655,18 +7663,18 @@
             kpis_healths=kpis_healths,
             nodes_list=nodes_list,
             **kwargs
         )
         self.protected_item_type: str = "AzureVmWorkloadSAPHanaDatabase"
 
 
-class AzureVmWorkloadSAPHanaDatabaseWorkloadItem(AzureVmWorkloadItem):
+class AzureVmWorkloadSAPHanaDatabaseWorkloadItem(AzureVmWorkloadItem):  # pylint: disable=name-too-long
     """Azure VM workload-specific workload item representing SAP HANA Database.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar workload_item_type: Type of the backup item. Required.
     :vartype workload_item_type: str
@@ -7755,15 +7763,15 @@
         )
         self.workload_item_type: str = "SAPHanaDatabase"
 
 
 class AzureVmWorkloadSAPHanaDBInstance(AzureVmWorkloadProtectableItem):  # pylint: disable=too-many-instance-attributes
     """Azure VM workload-specific protectable item representing SAP HANA Dbinstance.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -7885,20 +7893,20 @@
             **kwargs
         )
         self.protectable_item_type: str = "SAPHanaDBInstance"
 
 
 class AzureVmWorkloadSAPHanaDBInstanceProtectedItem(
     AzureVmWorkloadProtectedItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protected item representing SAP HANA DBInstance.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -8177,15 +8185,15 @@
 
 
 class AzureVmWorkloadSAPHanaHSRProtectableItem(
     AzureVmWorkloadProtectableItem
 ):  # pylint: disable=too-many-instance-attributes
     """Azure VM workload-specific protectable item representing HANA HSR.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -8307,18 +8315,18 @@
             **kwargs
         )
         self.protectable_item_type: str = "HanaHSRContainer"
 
 
 class AzureVmWorkloadSAPHanaSystemProtectableItem(
     AzureVmWorkloadProtectableItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protectable item representing SAP HANA System.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -8441,15 +8449,15 @@
         )
         self.protectable_item_type: str = "SAPHanaSystem"
 
 
 class AzureVmWorkloadSAPHanaSystemWorkloadItem(AzureVmWorkloadItem):
     """Azure VM workload-specific workload item representing SAP HANA System.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar workload_item_type: Type of the backup item. Required.
     :vartype workload_item_type: str
@@ -8537,18 +8545,18 @@
             **kwargs
         )
         self.workload_item_type: str = "SAPHanaSystem"
 
 
 class AzureVmWorkloadSQLAvailabilityGroupProtectableItem(
     AzureVmWorkloadProtectableItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protectable item representing SQL Availability Group.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -8679,18 +8687,18 @@
         )
         self.protectable_item_type: str = "SQLAvailabilityGroupContainer"
         self.nodes_list = nodes_list
 
 
 class AzureVmWorkloadSQLDatabaseProtectableItem(
     AzureVmWorkloadProtectableItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protectable item representing SQL Database.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -8817,15 +8825,15 @@
 class AzureVmWorkloadSQLDatabaseProtectedItem(
     AzureVmWorkloadProtectedItem
 ):  # pylint: disable=too-many-instance-attributes
     """Azure VM workload-specific protected item representing SQL Database.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -9102,15 +9110,15 @@
         )
         self.protected_item_type: str = "AzureVmWorkloadSQLDatabase"
 
 
 class AzureVmWorkloadSQLDatabaseWorkloadItem(AzureVmWorkloadItem):
     """Azure VM workload-specific workload item representing SQL Database.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar workload_item_type: Type of the backup item. Required.
     :vartype workload_item_type: str
@@ -9198,18 +9206,18 @@
             **kwargs
         )
         self.workload_item_type: str = "SQLDataBase"
 
 
 class AzureVmWorkloadSQLInstanceProtectableItem(
     AzureVmWorkloadProtectableItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protectable item representing SQL Instance.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar protectable_item_type: Type of the backup item. Required.
     :vartype protectable_item_type: str
@@ -9332,15 +9340,15 @@
         )
         self.protectable_item_type: str = "SQLInstance"
 
 
 class AzureVmWorkloadSQLInstanceWorkloadItem(AzureVmWorkloadItem):  # pylint: disable=too-many-instance-attributes
     """Azure VM workload-specific workload item representing SQL Instance.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Type of backup management to backup an item.
     :vartype backup_management_type: str
     :ivar workload_type: Type of workload for the backup management.
     :vartype workload_type: str
     :ivar workload_item_type: Type of the backup item. Required.
     :vartype workload_item_type: str
@@ -9441,15 +9449,15 @@
 
 class AzureWorkloadAutoProtectionIntent(AzureRecoveryServiceVaultProtectionIntent):
     """Azure Recovery Services Vault specific protection intent item.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSQLAutoProtectionIntent
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protection_intent_item_type: backup protectionIntent type. Required. Known values are:
      "Invalid", "AzureResourceItem", "RecoveryServiceVaultItem",
      "AzureWorkloadContainerAutoProtectionIntent", "AzureWorkloadAutoProtectionIntent", and
      "AzureWorkloadSQLAutoProtectionIntent".
     :vartype protection_intent_item_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentItemType
@@ -9526,15 +9534,15 @@
         )
         self.protection_intent_item_type: str = "AzureWorkloadAutoProtectionIntent"
 
 
 class AzureWorkloadBackupRequest(BackupRequest):
     """AzureWorkload workload-specific backup request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar backup_type: Type of backup, viz. Full, Differential, Log or CopyOnlyFull. Known values
      are: "Invalid", "Full", "Differential", "Log", "CopyOnlyFull", "Incremental", "SnapshotFull",
      and "SnapshotCopyOnlyFull".
@@ -9579,18 +9587,18 @@
         super().__init__(**kwargs)
         self.object_type: str = "AzureWorkloadBackupRequest"
         self.backup_type = backup_type
         self.enable_compression = enable_compression
         self.recovery_point_expiry_time_in_utc = recovery_point_expiry_time_in_utc
 
 
-class AzureWorkloadContainerAutoProtectionIntent(ProtectionIntent):
+class AzureWorkloadContainerAutoProtectionIntent(ProtectionIntent):  # pylint: disable=name-too-long
     """Azure workload specific protection intent item.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protection_intent_item_type: backup protectionIntent type. Required. Known values are:
      "Invalid", "AzureResourceItem", "RecoveryServiceVaultItem",
      "AzureWorkloadContainerAutoProtectionIntent", "AzureWorkloadAutoProtectionIntent", and
      "AzureWorkloadSQLAutoProtectionIntent".
     :vartype protection_intent_item_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentItemType
@@ -9759,15 +9767,15 @@
         self.recommendations = recommendations
         self.additional_details = additional_details
 
 
 class AzureWorkloadJob(Job):  # pylint: disable=too-many-instance-attributes
     """Azure storage specific job.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -9958,15 +9966,15 @@
 class AzureWorkloadRecoveryPoint(RecoveryPoint):
     """Workload specific recovery point, specifically encapsulates full/diff recovery point.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadPointInTimeRecoveryPoint, AzureWorkloadSAPHanaRecoveryPoint,
     AzureWorkloadSQLRecoveryPoint
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -10044,15 +10052,15 @@
 
 class AzureWorkloadPointInTimeRecoveryPoint(AzureWorkloadRecoveryPoint):
     """Recovery point specific to PointInTime.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSAPHanaPointInTimeRecoveryPoint
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -10131,26 +10139,29 @@
             recovery_point_properties=recovery_point_properties,
             **kwargs
         )
         self.object_type: str = "AzureWorkloadPointInTimeRecoveryPoint"
         self.time_ranges = time_ranges
 
 
-class AzureWorkloadRestoreRequest(RestoreRequest):
+class AzureWorkloadRestoreRequest(RestoreRequest):  # pylint: disable=too-many-instance-attributes
     """AzureWorkload-specific restore.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadPointInTimeRestoreRequest, AzureWorkloadSAPHanaRestoreRequest,
     AzureWorkloadSQLRestoreRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -10181,14 +10192,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -10206,26 +10218,30 @@
             "AzureWorkloadSQLRestoreRequest": "AzureWorkloadSQLRestoreRequest",
         }
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
         snapshot_restore_parameters: Optional["_models.SnapshotRestoreParameters"] = None,
         target_virtual_machine_id: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -10249,15 +10265,15 @@
         :paramtype snapshot_restore_parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.SnapshotRestoreParameters
         :keyword target_virtual_machine_id: This is the complete ARM Id of the target VM
          For e.g.
          /subscriptions/{subId}/resourcegroups/{rg}/provider/Microsoft.Compute/virtualmachines/{vm}.
         :paramtype target_virtual_machine_id: str
         """
-        super().__init__(**kwargs)
+        super().__init__(resource_guard_operation_requests=resource_guard_operation_requests, **kwargs)
         self.object_type: str = "AzureWorkloadRestoreRequest"
         self.recovery_type = recovery_type
         self.source_resource_id = source_resource_id
         self.property_bag = property_bag
         self.target_info = target_info
         self.recovery_mode = recovery_mode
         self.target_resource_group_name = target_resource_group_name
@@ -10267,19 +10283,22 @@
 
 
 class AzureWorkloadPointInTimeRestoreRequest(
     AzureWorkloadRestoreRequest
 ):  # pylint: disable=too-many-instance-attributes
     """AzureWorkload SAP Hana -specific restore. Specifically for PointInTime/Log restore.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -10312,14 +10331,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -10330,27 +10350,31 @@
         "target_virtual_machine_id": {"key": "targetVirtualMachineId", "type": "str"},
         "point_in_time": {"key": "pointInTime", "type": "iso-8601"},
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
         snapshot_restore_parameters: Optional["_models.SnapshotRestoreParameters"] = None,
         target_virtual_machine_id: Optional[str] = None,
         point_in_time: Optional[datetime.datetime] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -10377,14 +10401,15 @@
          For e.g.
          /subscriptions/{subId}/resourcegroups/{rg}/provider/Microsoft.Compute/virtualmachines/{vm}.
         :paramtype target_virtual_machine_id: str
         :keyword point_in_time: PointInTime value.
         :paramtype point_in_time: ~datetime.datetime
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             property_bag=property_bag,
             target_info=target_info,
             recovery_mode=recovery_mode,
             target_resource_group_name=target_resource_group_name,
             user_assigned_managed_identity_details=user_assigned_managed_identity_details,
@@ -10392,18 +10417,20 @@
             target_virtual_machine_id=target_virtual_machine_id,
             **kwargs
         )
         self.object_type: str = "AzureWorkloadPointInTimeRestoreRequest"
         self.point_in_time = point_in_time
 
 
-class AzureWorkloadSAPHanaPointInTimeRecoveryPoint(AzureWorkloadPointInTimeRecoveryPoint):
+class AzureWorkloadSAPHanaPointInTimeRecoveryPoint(
+    AzureWorkloadPointInTimeRecoveryPoint
+):  # pylint: disable=name-too-long
     """Recovery point specific to PointInTime in SAPHana.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -10478,25 +10505,28 @@
             recovery_point_properties=recovery_point_properties,
             time_ranges=time_ranges,
             **kwargs
         )
         self.object_type: str = "AzureWorkloadSAPHanaPointInTimeRecoveryPoint"
 
 
-class AzureWorkloadSAPHanaRestoreRequest(AzureWorkloadRestoreRequest):
+class AzureWorkloadSAPHanaRestoreRequest(AzureWorkloadRestoreRequest):  # pylint: disable=too-many-instance-attributes
     """AzureWorkload SAP Hana-specific restore.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSAPHanaPointInTimeRestoreRequest, AzureWorkloadSAPHanaRestoreWithRehydrateRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -10527,14 +10557,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -10551,26 +10582,30 @@
             "AzureWorkloadSAPHanaRestoreWithRehydrateRequest": "AzureWorkloadSAPHanaRestoreWithRehydrateRequest",
         }
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
         snapshot_restore_parameters: Optional["_models.SnapshotRestoreParameters"] = None,
         target_virtual_machine_id: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -10595,14 +10630,15 @@
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.SnapshotRestoreParameters
         :keyword target_virtual_machine_id: This is the complete ARM Id of the target VM
          For e.g.
          /subscriptions/{subId}/resourcegroups/{rg}/provider/Microsoft.Compute/virtualmachines/{vm}.
         :paramtype target_virtual_machine_id: str
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             property_bag=property_bag,
             target_info=target_info,
             recovery_mode=recovery_mode,
             target_resource_group_name=target_resource_group_name,
             user_assigned_managed_identity_details=user_assigned_managed_identity_details,
@@ -10611,25 +10647,28 @@
             **kwargs
         )
         self.object_type: str = "AzureWorkloadSAPHanaRestoreRequest"
 
 
 class AzureWorkloadSAPHanaPointInTimeRestoreRequest(
     AzureWorkloadSAPHanaRestoreRequest
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """AzureWorkload SAP Hana -specific restore. Specifically for PointInTime/Log restore.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -10662,14 +10701,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -10686,27 +10726,31 @@
             "AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest": "AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest"
         }
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
         snapshot_restore_parameters: Optional["_models.SnapshotRestoreParameters"] = None,
         target_virtual_machine_id: Optional[str] = None,
         point_in_time: Optional[datetime.datetime] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -10733,14 +10777,15 @@
          For e.g.
          /subscriptions/{subId}/resourcegroups/{rg}/provider/Microsoft.Compute/virtualmachines/{vm}.
         :paramtype target_virtual_machine_id: str
         :keyword point_in_time: PointInTime value.
         :paramtype point_in_time: ~datetime.datetime
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             property_bag=property_bag,
             target_info=target_info,
             recovery_mode=recovery_mode,
             target_resource_group_name=target_resource_group_name,
             user_assigned_managed_identity_details=user_assigned_managed_identity_details,
@@ -10750,22 +10795,25 @@
         )
         self.object_type: str = "AzureWorkloadSAPHanaPointInTimeRestoreRequest"
         self.point_in_time = point_in_time
 
 
 class AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest(
     AzureWorkloadSAPHanaPointInTimeRestoreRequest
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """AzureWorkload SAP Hana-specific restore with integrated rehydration of recovery point.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -10801,14 +10849,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -10823,28 +10872,32 @@
             "type": "RecoveryPointRehydrationInfo",
         },
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
         snapshot_restore_parameters: Optional["_models.SnapshotRestoreParameters"] = None,
         target_virtual_machine_id: Optional[str] = None,
         point_in_time: Optional[datetime.datetime] = None,
         recovery_point_rehydration_info: Optional["_models.RecoveryPointRehydrationInfo"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -10874,14 +10927,15 @@
         :keyword point_in_time: PointInTime value.
         :paramtype point_in_time: ~datetime.datetime
         :keyword recovery_point_rehydration_info: RP Rehydration Info.
         :paramtype recovery_point_rehydration_info:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointRehydrationInfo
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             property_bag=property_bag,
             target_info=target_info,
             recovery_mode=recovery_mode,
             target_resource_group_name=target_resource_group_name,
             user_assigned_managed_identity_details=user_assigned_managed_identity_details,
@@ -10893,15 +10947,15 @@
         self.object_type: str = "AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest"
         self.recovery_point_rehydration_info = recovery_point_rehydration_info
 
 
 class AzureWorkloadSAPHanaRecoveryPoint(AzureWorkloadRecoveryPoint):
     """SAPHana specific recoverypoint, specifically encapsulates full/diff recoverypoints.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -10969,22 +11023,25 @@
             **kwargs
         )
         self.object_type: str = "AzureWorkloadSAPHanaRecoveryPoint"
 
 
 class AzureWorkloadSAPHanaRestoreWithRehydrateRequest(
     AzureWorkloadSAPHanaRestoreRequest
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """AzureWorkload SAP Hana-specific restore with integrated rehydration of recovery point.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -11018,14 +11075,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -11039,27 +11097,31 @@
             "type": "RecoveryPointRehydrationInfo",
         },
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
         snapshot_restore_parameters: Optional["_models.SnapshotRestoreParameters"] = None,
         target_virtual_machine_id: Optional[str] = None,
         recovery_point_rehydration_info: Optional["_models.RecoveryPointRehydrationInfo"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -11087,14 +11149,15 @@
          /subscriptions/{subId}/resourcegroups/{rg}/provider/Microsoft.Compute/virtualmachines/{vm}.
         :paramtype target_virtual_machine_id: str
         :keyword recovery_point_rehydration_info: RP Rehydration Info.
         :paramtype recovery_point_rehydration_info:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointRehydrationInfo
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             property_bag=property_bag,
             target_info=target_info,
             recovery_mode=recovery_mode,
             target_resource_group_name=target_resource_group_name,
             user_assigned_managed_identity_details=user_assigned_managed_identity_details,
@@ -11105,15 +11168,15 @@
         self.object_type: str = "AzureWorkloadSAPHanaRestoreWithRehydrateRequest"
         self.recovery_point_rehydration_info = recovery_point_rehydration_info
 
 
 class AzureWorkloadSQLAutoProtectionIntent(AzureWorkloadAutoProtectionIntent):
     """Azure Workload SQL Auto Protection intent item.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protection_intent_item_type: backup protectionIntent type. Required. Known values are:
      "Invalid", "AzureResourceItem", "RecoveryServiceVaultItem",
      "AzureWorkloadContainerAutoProtectionIntent", "AzureWorkloadAutoProtectionIntent", and
      "AzureWorkloadSQLAutoProtectionIntent".
     :vartype protection_intent_item_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentItemType
@@ -11203,15 +11266,15 @@
 class AzureWorkloadSQLRecoveryPoint(AzureWorkloadRecoveryPoint):
     """SQL specific recoverypoint, specifically encapsulates full/diff recoverypoint along with
     extended info.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSQLPointInTimeRecoveryPoint
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -11299,15 +11362,15 @@
         self.object_type: str = "AzureWorkloadSQLRecoveryPoint"
         self.extended_info = extended_info
 
 
 class AzureWorkloadSQLPointInTimeRecoveryPoint(AzureWorkloadSQLRecoveryPoint):
     """Recovery point specific to PointInTime.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -11403,19 +11466,22 @@
 
 class AzureWorkloadSQLRestoreRequest(AzureWorkloadRestoreRequest):  # pylint: disable=too-many-instance-attributes
     """AzureWorkload SQL -specific restore. Specifically for full/diff restore.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSQLPointInTimeRestoreRequest, AzureWorkloadSQLRestoreWithRehydrateRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -11455,14 +11521,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -11482,14 +11549,15 @@
             "AzureWorkloadSQLRestoreWithRehydrateRequest": "AzureWorkloadSQLRestoreWithRehydrateRequest",
         }
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
@@ -11497,14 +11565,17 @@
         target_virtual_machine_id: Optional[str] = None,
         should_use_alternate_target_location: Optional[bool] = None,
         is_non_recoverable: Optional[bool] = None,
         alternate_directory_paths: Optional[List["_models.SQLDataDirectoryMapping"]] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -11538,14 +11609,15 @@
          restore operation is tried.
         :paramtype is_non_recoverable: bool
         :keyword alternate_directory_paths: Data directory details.
         :paramtype alternate_directory_paths:
          list[~azure.mgmt.recoveryservicesbackup.activestamp.models.SQLDataDirectoryMapping]
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             property_bag=property_bag,
             target_info=target_info,
             recovery_mode=recovery_mode,
             target_resource_group_name=target_resource_group_name,
             user_assigned_managed_identity_details=user_assigned_managed_identity_details,
@@ -11557,25 +11629,28 @@
         self.should_use_alternate_target_location = should_use_alternate_target_location
         self.is_non_recoverable = is_non_recoverable
         self.alternate_directory_paths = alternate_directory_paths
 
 
 class AzureWorkloadSQLPointInTimeRestoreRequest(
     AzureWorkloadSQLRestoreRequest
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """AzureWorkload SQL -specific restore. Specifically for PointInTime/Log restore.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -11617,14 +11692,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -11644,14 +11720,15 @@
             "AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest": "AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest"
         }
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
@@ -11660,14 +11737,17 @@
         should_use_alternate_target_location: Optional[bool] = None,
         is_non_recoverable: Optional[bool] = None,
         alternate_directory_paths: Optional[List["_models.SQLDataDirectoryMapping"]] = None,
         point_in_time: Optional[datetime.datetime] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -11703,14 +11783,15 @@
         :keyword alternate_directory_paths: Data directory details.
         :paramtype alternate_directory_paths:
          list[~azure.mgmt.recoveryservicesbackup.activestamp.models.SQLDataDirectoryMapping]
         :keyword point_in_time: PointInTime value.
         :paramtype point_in_time: ~datetime.datetime
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             property_bag=property_bag,
             target_info=target_info,
             recovery_mode=recovery_mode,
             target_resource_group_name=target_resource_group_name,
             user_assigned_managed_identity_details=user_assigned_managed_identity_details,
@@ -11723,22 +11804,25 @@
         )
         self.object_type: str = "AzureWorkloadSQLPointInTimeRestoreRequest"
         self.point_in_time = point_in_time
 
 
 class AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest(
     AzureWorkloadSQLPointInTimeRestoreRequest
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """AzureWorkload SQL-specific restore with integrated rehydration of recovery point.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -11783,14 +11867,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -11808,14 +11893,15 @@
             "type": "RecoveryPointRehydrationInfo",
         },
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
@@ -11825,14 +11911,17 @@
         is_non_recoverable: Optional[bool] = None,
         alternate_directory_paths: Optional[List["_models.SQLDataDirectoryMapping"]] = None,
         point_in_time: Optional[datetime.datetime] = None,
         recovery_point_rehydration_info: Optional["_models.RecoveryPointRehydrationInfo"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -11871,14 +11960,15 @@
         :keyword point_in_time: PointInTime value.
         :paramtype point_in_time: ~datetime.datetime
         :keyword recovery_point_rehydration_info: RP Rehydration Info.
         :paramtype recovery_point_rehydration_info:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointRehydrationInfo
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             property_bag=property_bag,
             target_info=target_info,
             recovery_mode=recovery_mode,
             target_resource_group_name=target_resource_group_name,
             user_assigned_managed_identity_details=user_assigned_managed_identity_details,
@@ -11890,15 +11980,15 @@
             point_in_time=point_in_time,
             **kwargs
         )
         self.object_type: str = "AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest"
         self.recovery_point_rehydration_info = recovery_point_rehydration_info
 
 
-class AzureWorkloadSQLRecoveryPointExtendedInfo(_serialization.Model):
+class AzureWorkloadSQLRecoveryPointExtendedInfo(_serialization.Model):  # pylint: disable=name-too-long
     """Extended info class details.
 
     :ivar data_directory_time_in_utc: UTC time at which data directory info was captured.
     :vartype data_directory_time_in_utc: ~datetime.datetime
     :ivar data_directory_paths: List of data directory paths during restore operation.
     :vartype data_directory_paths:
      list[~azure.mgmt.recoveryservicesbackup.activestamp.models.SQLDataDirectory]
@@ -11926,22 +12016,25 @@
         super().__init__(**kwargs)
         self.data_directory_time_in_utc = data_directory_time_in_utc
         self.data_directory_paths = data_directory_paths
 
 
 class AzureWorkloadSQLRestoreWithRehydrateRequest(
     AzureWorkloadSQLRestoreRequest
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """AzureWorkload SQL-specific restore with integrated rehydration of recovery point.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM on which workload that was running
      is being recovered.
     :vartype source_resource_id: str
@@ -11984,14 +12077,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "property_bag": {"key": "propertyBag", "type": "{str}"},
         "target_info": {"key": "targetInfo", "type": "TargetRestoreInfo"},
         "recovery_mode": {"key": "recoveryMode", "type": "str"},
         "target_resource_group_name": {"key": "targetResourceGroupName", "type": "str"},
         "user_assigned_managed_identity_details": {
@@ -12008,14 +12102,15 @@
             "type": "RecoveryPointRehydrationInfo",
         },
     }
 
     def __init__(
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         property_bag: Optional[Dict[str, str]] = None,
         target_info: Optional["_models.TargetRestoreInfo"] = None,
         recovery_mode: Optional[Union[str, "_models.RecoveryMode"]] = None,
         target_resource_group_name: Optional[str] = None,
         user_assigned_managed_identity_details: Optional["_models.UserAssignedManagedIdentityDetails"] = None,
@@ -12024,14 +12119,17 @@
         should_use_alternate_target_location: Optional[bool] = None,
         is_non_recoverable: Optional[bool] = None,
         alternate_directory_paths: Optional[List["_models.SQLDataDirectoryMapping"]] = None,
         recovery_point_rehydration_info: Optional["_models.RecoveryPointRehydrationInfo"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM on which workload that was
          running is being recovered.
         :paramtype source_resource_id: str
@@ -12068,14 +12166,15 @@
         :paramtype alternate_directory_paths:
          list[~azure.mgmt.recoveryservicesbackup.activestamp.models.SQLDataDirectoryMapping]
         :keyword recovery_point_rehydration_info: RP Rehydration Info.
         :paramtype recovery_point_rehydration_info:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointRehydrationInfo
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             property_bag=property_bag,
             target_info=target_info,
             recovery_mode=recovery_mode,
             target_resource_group_name=target_resource_group_name,
             user_assigned_managed_identity_details=user_assigned_managed_identity_details,
@@ -12765,15 +12864,15 @@
             infrastructure_encryption_state=infrastructure_encryption_state,
             **kwargs
         )
         self.user_assigned_identity = user_assigned_identity
         self.use_system_assigned_identity = use_system_assigned_identity
 
 
-class BackupResourceEncryptionConfigExtendedResource(Resource):
+class BackupResourceEncryptionConfigExtendedResource(Resource):  # pylint: disable=name-too-long
     """BackupResourceEncryptionConfigExtendedResource.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Resource Id represents the complete path to the resource.
     :vartype id: str
     :ivar name: Resource name associated with the resource.
@@ -13335,15 +13434,15 @@
         super().__init__(**kwargs)
         self.type = type
 
 
 class BMSContainerQueryObject(_serialization.Model):
     """The query filters that can be used with the list containers API.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar backup_management_type: Backup management type for this container. Required. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupManagementType
     :ivar container_type: Type of container for filter. Known values are: "Invalid", "Unknown",
@@ -14275,15 +14374,15 @@
         self.error_detail = error_detail
         self.source_resource_id = source_resource_id
 
 
 class DpmBackupEngine(BackupEngineBase):  # pylint: disable=too-many-instance-attributes
     """Data Protection Manager (DPM) specific backup engine.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the backup engine.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the backup engine. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -14453,15 +14552,15 @@
         self.error_string = error_string
         self.recommendations = recommendations
 
 
 class DpmJob(Job):  # pylint: disable=too-many-instance-attributes
     """DPM workload-specific job object.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -14698,15 +14797,15 @@
 
 
 class DPMProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """Additional information on Backup engine specific backup item.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -15136,15 +15235,15 @@
 
 class OperationResultInfoBase(_serialization.Model):
     """Base class for operation result info.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     ExportJobsOperationResultInfo, OperationResultInfo
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -15167,15 +15266,15 @@
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
 
 
 class ExportJobsOperationResultInfo(OperationResultInfoBase):
     """This class is used to send blob details after exporting jobs.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar blob_url: URL of the blob into which the serialized string of list of jobs is exported.
     :vartype blob_url: str
     :ivar blob_sas_key: SAS key to access the blob. It expires in 15 mins.
@@ -15290,15 +15389,15 @@
     """Base class for tiering cost request.
     Specific cost request types are derived from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     FetchTieringCostInfoForRehydrationRequest, FetchTieringCostSavingsInfoForPolicyRequest,
     FetchTieringCostSavingsInfoForProtectedItemRequest, FetchTieringCostSavingsInfoForVaultRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar source_tier_type: Source tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
     :vartype source_tier_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointTierType
     :ivar target_tier_type: target tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
@@ -15349,18 +15448,18 @@
         """
         super().__init__(**kwargs)
         self.source_tier_type = source_tier_type
         self.target_tier_type = target_tier_type
         self.object_type: Optional[str] = None
 
 
-class FetchTieringCostInfoForRehydrationRequest(FetchTieringCostInfoRequest):
+class FetchTieringCostInfoForRehydrationRequest(FetchTieringCostInfoRequest):  # pylint: disable=name-too-long
     """Request parameters for fetching cost info of rehydration.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar source_tier_type: Source tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
     :vartype source_tier_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointTierType
     :ivar target_tier_type: target tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
@@ -15438,18 +15537,18 @@
         self.object_type: str = "FetchTieringCostInfoForRehydrationRequest"
         self.container_name = container_name
         self.protected_item_name = protected_item_name
         self.recovery_point_id = recovery_point_id
         self.rehydration_priority = rehydration_priority
 
 
-class FetchTieringCostSavingsInfoForPolicyRequest(FetchTieringCostInfoRequest):
+class FetchTieringCostSavingsInfoForPolicyRequest(FetchTieringCostInfoRequest):  # pylint: disable=name-too-long
     """Request parameters for tiering cost info for policy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar source_tier_type: Source tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
     :vartype source_tier_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointTierType
     :ivar target_tier_type: target tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
@@ -15499,18 +15598,18 @@
         :paramtype policy_name: str
         """
         super().__init__(source_tier_type=source_tier_type, target_tier_type=target_tier_type, **kwargs)
         self.object_type: str = "FetchTieringCostSavingsInfoForPolicyRequest"
         self.policy_name = policy_name
 
 
-class FetchTieringCostSavingsInfoForProtectedItemRequest(FetchTieringCostInfoRequest):
+class FetchTieringCostSavingsInfoForProtectedItemRequest(FetchTieringCostInfoRequest):  # pylint: disable=name-too-long
     """Request parameters for tiering cost info for protected item.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar source_tier_type: Source tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
     :vartype source_tier_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointTierType
     :ivar target_tier_type: target tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
@@ -15566,18 +15665,18 @@
         """
         super().__init__(source_tier_type=source_tier_type, target_tier_type=target_tier_type, **kwargs)
         self.object_type: str = "FetchTieringCostSavingsInfoForProtectedItemRequest"
         self.container_name = container_name
         self.protected_item_name = protected_item_name
 
 
-class FetchTieringCostSavingsInfoForVaultRequest(FetchTieringCostInfoRequest):
+class FetchTieringCostSavingsInfoForVaultRequest(FetchTieringCostInfoRequest):  # pylint: disable=name-too-long
     """Request parameters for tiering cost info for vault.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar source_tier_type: Source tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
     :vartype source_tier_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointTierType
     :ivar target_tier_type: target tier for the request. Required. Known values are: "Invalid",
      "InstantRP", "HardenedRP", and "ArchivedRP".
@@ -15620,15 +15719,15 @@
         super().__init__(source_tier_type=source_tier_type, target_tier_type=target_tier_type, **kwargs)
         self.object_type: str = "FetchTieringCostSavingsInfoForVaultRequest"
 
 
 class GenericContainer(ProtectionContainer):
     """Base class for generic container of backup items.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -15765,15 +15864,15 @@
 
 
 class GenericProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """Base class for backup items.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -15984,15 +16083,15 @@
         self.source_associations = source_associations
         self.fabric_name = fabric_name
 
 
 class GenericProtectionPolicy(ProtectionPolicy):
     """Azure VM (Mercury) workload-specific backup policy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_items_count: Number of items associated with this policy.
     :vartype protected_items_count: int
     :ivar backup_management_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype backup_management_type: str
     :ivar resource_guard_operation_requests: ResourceGuard Operation Requests.
@@ -16056,15 +16155,15 @@
         self.time_zone = time_zone
         self.fabric_name = fabric_name
 
 
 class GenericRecoveryPoint(RecoveryPoint):
     """Generic backup copy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar friendly_name: Friendly name of the backup copy.
     :vartype friendly_name: str
     :ivar recovery_point_type: Type of the backup copy.
@@ -16184,15 +16283,15 @@
         self.schedule_window_start_time = schedule_window_start_time
         self.schedule_window_duration = schedule_window_duration
 
 
 class IaasVMBackupRequest(BackupRequest):
     """IaaS VM workload-specific backup request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_expiry_time_in_utc: Backup copy will expire after the time specified
      (UTC).
     :vartype recovery_point_expiry_time_in_utc: ~datetime.datetime
@@ -16217,15 +16316,15 @@
         self.object_type: str = "IaasVMBackupRequest"
         self.recovery_point_expiry_time_in_utc = recovery_point_expiry_time_in_utc
 
 
 class IaasVMILRRegistrationRequest(ILRRequest):
     """Restore files/folders from a backup copy of IaaS VM.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_id: ID of the IaaS VM backup copy from where the files/folders have to be
      restored.
     :vartype recovery_point_id: str
@@ -16280,15 +16379,15 @@
         self.initiator_name = initiator_name
         self.renew_existing_registration = renew_existing_registration
 
 
 class IaasVMRecoveryPoint(RecoveryPoint):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload specific backup copy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_type: Type of the backup copy.
     :vartype recovery_point_type: str
     :ivar recovery_point_time: Time at which this backup copy was created.
@@ -16476,19 +16575,22 @@
 
 class IaasVMRestoreRequest(RestoreRequest):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload-specific restore.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     IaasVMRestoreWithRehydrationRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_point_id: ID of the backup copy to be recovered.
     :vartype recovery_point_id: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM which is being recovered.
@@ -16563,14 +16665,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_point_id": {"key": "recoveryPointId", "type": "str"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "target_virtual_machine_id": {"key": "targetVirtualMachineId", "type": "str"},
         "target_resource_group_id": {"key": "targetResourceGroupId", "type": "str"},
         "storage_account_id": {"key": "storageAccountId", "type": "str"},
         "virtual_network_id": {"key": "virtualNetworkId", "type": "str"},
@@ -16596,14 +16699,15 @@
     }
 
     _subtype_map = {"object_type": {"IaasVMRestoreWithRehydrationRequest": "IaasVMRestoreWithRehydrationRequest"}}
 
     def __init__(  # pylint: disable=too-many-locals
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_point_id: Optional[str] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         target_virtual_machine_id: Optional[str] = None,
         target_resource_group_id: Optional[str] = None,
         storage_account_id: Optional[str] = None,
         virtual_network_id: Optional[str] = None,
@@ -16622,14 +16726,17 @@
         identity_based_restore_details: Optional["_models.IdentityBasedRestoreDetails"] = None,
         extended_location: Optional["_models.ExtendedLocation"] = None,
         secured_vm_details: Optional["_models.SecuredVMDetails"] = None,
         target_disk_network_access_settings: Optional["_models.TargetDiskNetworkAccessSettings"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_point_id: ID of the backup copy to be recovered.
         :paramtype recovery_point_id: str
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM which is being recovered.
@@ -16698,15 +16805,15 @@
         :paramtype secured_vm_details:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.SecuredVMDetails
         :keyword target_disk_network_access_settings: Specifies target network access settings for
          disks of VM to be restored,.
         :paramtype target_disk_network_access_settings:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.TargetDiskNetworkAccessSettings
         """
-        super().__init__(**kwargs)
+        super().__init__(resource_guard_operation_requests=resource_guard_operation_requests, **kwargs)
         self.object_type: str = "IaasVMRestoreRequest"
         self.recovery_point_id = recovery_point_id
         self.recovery_type = recovery_type
         self.source_resource_id = source_resource_id
         self.target_virtual_machine_id = target_virtual_machine_id
         self.target_resource_group_id = target_resource_group_id
         self.storage_account_id = storage_account_id
@@ -16728,19 +16835,22 @@
         self.secured_vm_details = secured_vm_details
         self.target_disk_network_access_settings = target_disk_network_access_settings
 
 
 class IaasVMRestoreWithRehydrationRequest(IaasVMRestoreRequest):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload-specific restore with integrated rehydration of recovery point.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
+    :ivar resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will
+     be performed.
+    :vartype resource_guard_operation_requests: list[str]
     :ivar recovery_point_id: ID of the backup copy to be recovered.
     :vartype recovery_point_id: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
     :ivar source_resource_id: Fully qualified ARM ID of the VM which is being recovered.
@@ -16818,14 +16928,15 @@
 
     _validation = {
         "object_type": {"required": True},
     }
 
     _attribute_map = {
         "object_type": {"key": "objectType", "type": "str"},
+        "resource_guard_operation_requests": {"key": "resourceGuardOperationRequests", "type": "[str]"},
         "recovery_point_id": {"key": "recoveryPointId", "type": "str"},
         "recovery_type": {"key": "recoveryType", "type": "str"},
         "source_resource_id": {"key": "sourceResourceId", "type": "str"},
         "target_virtual_machine_id": {"key": "targetVirtualMachineId", "type": "str"},
         "target_resource_group_id": {"key": "targetResourceGroupId", "type": "str"},
         "storage_account_id": {"key": "storageAccountId", "type": "str"},
         "virtual_network_id": {"key": "virtualNetworkId", "type": "str"},
@@ -16853,14 +16964,15 @@
             "type": "RecoveryPointRehydrationInfo",
         },
     }
 
     def __init__(  # pylint: disable=too-many-locals
         self,
         *,
+        resource_guard_operation_requests: Optional[List[str]] = None,
         recovery_point_id: Optional[str] = None,
         recovery_type: Optional[Union[str, "_models.RecoveryType"]] = None,
         source_resource_id: Optional[str] = None,
         target_virtual_machine_id: Optional[str] = None,
         target_resource_group_id: Optional[str] = None,
         storage_account_id: Optional[str] = None,
         virtual_network_id: Optional[str] = None,
@@ -16880,14 +16992,17 @@
         extended_location: Optional["_models.ExtendedLocation"] = None,
         secured_vm_details: Optional["_models.SecuredVMDetails"] = None,
         target_disk_network_access_settings: Optional["_models.TargetDiskNetworkAccessSettings"] = None,
         recovery_point_rehydration_info: Optional["_models.RecoveryPointRehydrationInfo"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check
+         will be performed.
+        :paramtype resource_guard_operation_requests: list[str]
         :keyword recovery_point_id: ID of the backup copy to be recovered.
         :paramtype recovery_point_id: str
         :keyword recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
          "AlternateLocation", "RestoreDisks", and "Offline".
         :paramtype recovery_type: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryType
         :keyword source_resource_id: Fully qualified ARM ID of the VM which is being recovered.
@@ -16960,14 +17075,15 @@
         :paramtype target_disk_network_access_settings:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.TargetDiskNetworkAccessSettings
         :keyword recovery_point_rehydration_info: RP Rehydration Info.
         :paramtype recovery_point_rehydration_info:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointRehydrationInfo
         """
         super().__init__(
+            resource_guard_operation_requests=resource_guard_operation_requests,
             recovery_point_id=recovery_point_id,
             recovery_type=recovery_type,
             source_resource_id=source_resource_id,
             target_virtual_machine_id=target_virtual_machine_id,
             target_resource_group_id=target_resource_group_id,
             storage_account_id=storage_account_id,
             virtual_network_id=virtual_network_id,
@@ -17549,15 +17665,15 @@
          list[~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceHealthDetails]
         """
         super().__init__(**kwargs)
         self.resource_health_status = resource_health_status
         self.resource_health_details = resource_health_details
 
 
-class ListRecoveryPointsRecommendedForMoveRequest(_serialization.Model):
+class ListRecoveryPointsRecommendedForMoveRequest(_serialization.Model):  # pylint: disable=name-too-long
     """ListRecoveryPointsRecommendedForMoveRequest Request.
 
     :ivar object_type: Gets the class type.
     :vartype object_type: str
     :ivar excluded_rp_list: List of Recovery Points excluded from Move.
     :vartype excluded_rp_list: list[str]
     """
@@ -17583,15 +17699,15 @@
 
 class SchedulePolicy(_serialization.Model):
     """Base class for backup schedule.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     LogSchedulePolicy, LongTermSchedulePolicy, SimpleSchedulePolicy, SimpleSchedulePolicyV2
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar schedule_policy_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype schedule_policy_type: str
     """
 
     _validation = {
@@ -17616,15 +17732,15 @@
         super().__init__(**kwargs)
         self.schedule_policy_type: Optional[str] = None
 
 
 class LogSchedulePolicy(SchedulePolicy):
     """Log policy schedule.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar schedule_policy_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype schedule_policy_type: str
     :ivar schedule_frequency_in_mins: Frequency of the log schedule operation of this policy in
      minutes.
     :vartype schedule_frequency_in_mins: int
@@ -17652,15 +17768,15 @@
 
 class RetentionPolicy(_serialization.Model):
     """Base class for retention policy.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     LongTermRetentionPolicy, SimpleRetentionPolicy
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar retention_policy_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype retention_policy_type: str
     """
 
     _validation = {
@@ -17683,15 +17799,15 @@
         super().__init__(**kwargs)
         self.retention_policy_type: Optional[str] = None
 
 
 class LongTermRetentionPolicy(RetentionPolicy):
     """Long term retention policy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar retention_policy_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype retention_policy_type: str
     :ivar daily_schedule: Daily retention schedule of the protection policy.
     :vartype daily_schedule:
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.DailyRetentionSchedule
@@ -17748,15 +17864,15 @@
         self.monthly_schedule = monthly_schedule
         self.yearly_schedule = yearly_schedule
 
 
 class LongTermSchedulePolicy(SchedulePolicy):
     """Long term policy schedule.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar schedule_policy_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype schedule_policy_type: str
     """
 
     _validation = {
@@ -17772,15 +17888,15 @@
         super().__init__(**kwargs)
         self.schedule_policy_type: str = "LongTermSchedulePolicy"
 
 
 class MabContainer(ProtectionContainer):  # pylint: disable=too-many-instance-attributes
     """Container with items backed up using MAB backup engine.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar friendly_name: Friendly name of the container.
     :vartype friendly_name: str
     :ivar backup_management_type: Type of backup management for the container. Known values are:
      "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -18048,15 +18164,15 @@
 
 
 class MabFileFolderProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """MAB workload-specific backup item.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -18305,15 +18421,15 @@
         self.oldest_recovery_point = oldest_recovery_point
         self.recovery_point_count = recovery_point_count
 
 
 class MabJob(Job):  # pylint: disable=too-many-instance-attributes
     """MAB workload-specific job.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -18557,15 +18673,15 @@
         self.duration = duration
         self.status = status
 
 
 class MabProtectionPolicy(ProtectionPolicy):
     """Mab container-specific backup policy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_items_count: Number of items associated with this policy.
     :vartype protected_items_count: int
     :ivar backup_management_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype backup_management_type: str
     :ivar resource_guard_operation_requests: ResourceGuard Operation Requests.
@@ -18819,15 +18935,15 @@
         self.details = None
         self.additional_info = None
 
 
 class OperationResultInfo(OperationResultInfoBase):
     """Operation result info.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar job_list: List of jobs created by this operation.
     :vartype job_list: list[str]
     """
@@ -18859,16 +18975,16 @@
      "ResetContent", "PartialContent", "MultipleChoices", "Ambiguous", "MovedPermanently", "Moved",
      "Found", "Redirect", "SeeOther", "RedirectMethod", "NotModified", "UseProxy", "Unused",
      "TemporaryRedirect", "RedirectKeepVerb", "BadRequest", "Unauthorized", "PaymentRequired",
      "Forbidden", "NotFound", "MethodNotAllowed", "NotAcceptable", "ProxyAuthenticationRequired",
      "RequestTimeout", "Conflict", "Gone", "LengthRequired", "PreconditionFailed",
      "RequestEntityTooLarge", "RequestUriTooLong", "UnsupportedMediaType",
      "RequestedRangeNotSatisfiable", "ExpectationFailed", "UpgradeRequired", "InternalServerError",
-     "NotImplemented", "BadGateway", "ServiceUnavailable", "GatewayTimeout",
-     "HttpVersionNotSupported", and "Continue".
+     "NotImplemented", "BadGateway", "ServiceUnavailable", "GatewayTimeout", and
+     "HttpVersionNotSupported".
     :vartype status_code: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.HttpStatusCode
     :ivar headers: HTTP headers associated with this operation.
     :vartype headers: dict[str, list[str]]
     """
 
     _attribute_map = {
@@ -18889,16 +19005,16 @@
          "ResetContent", "PartialContent", "MultipleChoices", "Ambiguous", "MovedPermanently", "Moved",
          "Found", "Redirect", "SeeOther", "RedirectMethod", "NotModified", "UseProxy", "Unused",
          "TemporaryRedirect", "RedirectKeepVerb", "BadRequest", "Unauthorized", "PaymentRequired",
          "Forbidden", "NotFound", "MethodNotAllowed", "NotAcceptable", "ProxyAuthenticationRequired",
          "RequestTimeout", "Conflict", "Gone", "LengthRequired", "PreconditionFailed",
          "RequestEntityTooLarge", "RequestUriTooLong", "UnsupportedMediaType",
          "RequestedRangeNotSatisfiable", "ExpectationFailed", "UpgradeRequired", "InternalServerError",
-         "NotImplemented", "BadGateway", "ServiceUnavailable", "GatewayTimeout",
-         "HttpVersionNotSupported", and "Continue".
+         "NotImplemented", "BadGateway", "ServiceUnavailable", "GatewayTimeout", and
+         "HttpVersionNotSupported".
         :paramtype status_code: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.HttpStatusCode
         :keyword headers: HTTP headers associated with this operation.
         :paramtype headers: dict[str, list[str]]
         """
         super().__init__(**kwargs)
         self.status_code = status_code
@@ -18913,16 +19029,16 @@
      "ResetContent", "PartialContent", "MultipleChoices", "Ambiguous", "MovedPermanently", "Moved",
      "Found", "Redirect", "SeeOther", "RedirectMethod", "NotModified", "UseProxy", "Unused",
      "TemporaryRedirect", "RedirectKeepVerb", "BadRequest", "Unauthorized", "PaymentRequired",
      "Forbidden", "NotFound", "MethodNotAllowed", "NotAcceptable", "ProxyAuthenticationRequired",
      "RequestTimeout", "Conflict", "Gone", "LengthRequired", "PreconditionFailed",
      "RequestEntityTooLarge", "RequestUriTooLong", "UnsupportedMediaType",
      "RequestedRangeNotSatisfiable", "ExpectationFailed", "UpgradeRequired", "InternalServerError",
-     "NotImplemented", "BadGateway", "ServiceUnavailable", "GatewayTimeout",
-     "HttpVersionNotSupported", and "Continue".
+     "NotImplemented", "BadGateway", "ServiceUnavailable", "GatewayTimeout", and
+     "HttpVersionNotSupported".
     :vartype status_code: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.HttpStatusCode
     :ivar headers: HTTP headers associated with this operation.
     :vartype headers: dict[str, list[str]]
     :ivar operation: OperationResultInfoBaseResource operation.
     :vartype operation:
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationResultInfoBase
@@ -18948,16 +19064,16 @@
          "ResetContent", "PartialContent", "MultipleChoices", "Ambiguous", "MovedPermanently", "Moved",
          "Found", "Redirect", "SeeOther", "RedirectMethod", "NotModified", "UseProxy", "Unused",
          "TemporaryRedirect", "RedirectKeepVerb", "BadRequest", "Unauthorized", "PaymentRequired",
          "Forbidden", "NotFound", "MethodNotAllowed", "NotAcceptable", "ProxyAuthenticationRequired",
          "RequestTimeout", "Conflict", "Gone", "LengthRequired", "PreconditionFailed",
          "RequestEntityTooLarge", "RequestUriTooLong", "UnsupportedMediaType",
          "RequestedRangeNotSatisfiable", "ExpectationFailed", "UpgradeRequired", "InternalServerError",
-         "NotImplemented", "BadGateway", "ServiceUnavailable", "GatewayTimeout",
-         "HttpVersionNotSupported", and "Continue".
+         "NotImplemented", "BadGateway", "ServiceUnavailable", "GatewayTimeout", and
+         "HttpVersionNotSupported".
         :paramtype status_code: str or
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.HttpStatusCode
         :keyword headers: HTTP headers associated with this operation.
         :paramtype headers: dict[str, list[str]]
         :keyword operation: OperationResultInfoBaseResource operation.
         :paramtype operation:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationResultInfoBase
@@ -19068,15 +19184,15 @@
 class OperationStatusExtendedInfo(_serialization.Model):
     """Base class for additional information of operation status.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     OperationStatusJobExtendedInfo, OperationStatusJobsExtendedInfo,
     OperationStatusProvisionILRExtendedInfo, OperationStatusValidateOperationExtendedInfo
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -19101,15 +19217,15 @@
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
 
 
 class OperationStatusJobExtendedInfo(OperationStatusExtendedInfo):
     """Operation status job extended info.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar job_id: ID of the job created for this protected item.
     :vartype job_id: str
     """
@@ -19132,15 +19248,15 @@
         self.object_type: str = "OperationStatusJobExtendedInfo"
         self.job_id = job_id
 
 
 class OperationStatusJobsExtendedInfo(OperationStatusExtendedInfo):
     """Operation status extended info for list of jobs.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar job_ids: IDs of the jobs created for the protected item.
     :vartype job_ids: list[str]
     :ivar failed_jobs_error: Stores all the failed jobs along with the corresponding error codes.
@@ -19172,15 +19288,15 @@
         self.job_ids = job_ids
         self.failed_jobs_error = failed_jobs_error
 
 
 class OperationStatusProvisionILRExtendedInfo(OperationStatusExtendedInfo):
     """Operation status extended info for ILR provision action.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_target: Target details for file / folder restore.
     :vartype recovery_target:
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.InstantItemRecoveryTarget
@@ -19202,18 +19318,18 @@
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.InstantItemRecoveryTarget
         """
         super().__init__(**kwargs)
         self.object_type: str = "OperationStatusProvisionILRExtendedInfo"
         self.recovery_target = recovery_target
 
 
-class OperationStatusValidateOperationExtendedInfo(OperationStatusExtendedInfo):
+class OperationStatusValidateOperationExtendedInfo(OperationStatusExtendedInfo):  # pylint: disable=name-too-long
     """Operation status extended info for ValidateOperation action.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar validate_operation_response: Gets the validation operation response.
     :vartype validate_operation_response:
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationResponse
@@ -19313,15 +19429,15 @@
         self.code = code
         self.message = message
 
 
 class PrepareDataMoveRequest(_serialization.Model):
     """Prepare DataMove Request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar target_resource_id: ARM Id of target vault. Required.
     :vartype target_resource_id: str
     :ivar target_region: Target Region. Required.
     :vartype target_region: str
     :ivar data_move_level: DataMove Level. Required. Known values are: "Invalid", "Vault", and
      "Container".
@@ -19377,21 +19493,21 @@
         self.target_resource_id = target_resource_id
         self.target_region = target_region
         self.data_move_level = data_move_level
         self.source_container_arm_ids = source_container_arm_ids
         self.ignore_moved = ignore_moved
 
 
-class VaultStorageConfigOperationResultResponse(_serialization.Model):
+class VaultStorageConfigOperationResultResponse(_serialization.Model):  # pylint: disable=name-too-long
     """Operation result response for Vault Storage Config.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     PrepareDataMoveResponse
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -19409,15 +19525,15 @@
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
 
 
 class PrepareDataMoveResponse(VaultStorageConfigOperationResultResponse):
     """Prepare DataMove Response.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar correlation_id: Co-relationId for move operation.
     :vartype correlation_id: str
     :ivar source_vault_properties: Source Vault Properties.
@@ -20765,42 +20881,14 @@
      "Deleted", and "Rehydrated".
     :vartype status: str or
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointTierStatus
     :ivar extended_info: Recovery point tier status.
     :vartype extended_info: dict[str, str]
     """
 
-    _attribute_map = {
-        "type": {"key": "type", "type": "str"},
-        "status": {"key": "status", "type": "str"},
-        "extended_info": {"key": "extendedInfo", "type": "{str}"},
-    }
-
-    def __init__(
-        self,
-        *,
-        type: Optional[Union[str, "_models.RecoveryPointTierType"]] = None,
-        status: Optional[Union[str, "_models.RecoveryPointTierStatus"]] = None,
-        extended_info: Optional[Dict[str, str]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword type: Recovery point tier type. Known values are: "Invalid", "InstantRP",
-         "HardenedRP", and "ArchivedRP".
-        :paramtype type: str or
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointTierType
-        :keyword status: Recovery point tier status. Known values are: "Invalid", "Valid", "Disabled",
-         "Deleted", and "Rehydrated".
-        :paramtype status: str or
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointTierStatus
-        :keyword extended_info: Recovery point tier status.
-        :paramtype extended_info: dict[str, str]
-        """
-        super().__init__(type=type, status=status, extended_info=extended_info, **kwargs)
-
 
 class ResourceGuardOperationDetail(_serialization.Model):
     """ResourceGuardOperationDetail.
 
     :ivar vault_critical_operation:
     :vartype vault_critical_operation: str
     :ivar default_resource_request:
@@ -20829,15 +20917,15 @@
         self.vault_critical_operation = vault_critical_operation
         self.default_resource_request = default_resource_request
 
 
 class ResourceGuardProxyBase(_serialization.Model):
     """ResourceGuardProxyBase.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar resource_guard_resource_id: Required.
     :vartype resource_guard_resource_id: str
     :ivar resource_guard_operation_details:
     :vartype resource_guard_operation_details:
      list[~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardOperationDetail]
     :ivar last_updated_time:
@@ -21210,15 +21298,15 @@
         self.issqlcompression = issqlcompression
         self.is_compression = is_compression
 
 
 class SimpleRetentionPolicy(RetentionPolicy):
     """Simple policy retention.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar retention_policy_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype retention_policy_type: str
     :ivar retention_duration: Retention duration of the protection policy.
     :vartype retention_duration:
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.RetentionDuration
@@ -21243,15 +21331,15 @@
         self.retention_policy_type: str = "SimpleRetentionPolicy"
         self.retention_duration = retention_duration
 
 
 class SimpleSchedulePolicy(SchedulePolicy):
     """Simple policy schedule.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar schedule_policy_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype schedule_policy_type: str
     :ivar schedule_run_frequency: Frequency of the schedule operation of this policy. Known values
      are: "Invalid", "Daily", "Weekly", and "Hourly".
     :vartype schedule_run_frequency: str or
@@ -21314,15 +21402,15 @@
         self.hourly_schedule = hourly_schedule
         self.schedule_weekly_frequency = schedule_weekly_frequency
 
 
 class SimpleSchedulePolicyV2(SchedulePolicy):
     """The V2 policy schedule for IaaS that supports hourly backups.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar schedule_policy_type: This property will be used as the discriminator for deciding the
      specific types in the polymorphic chain of types. Required.
     :vartype schedule_policy_type: str
     :ivar schedule_run_frequency: Frequency of the schedule operation of this policy. Known values
      are: "Invalid", "Daily", "Weekly", and "Hourly".
     :vartype schedule_run_frequency: str or
@@ -21738,15 +21826,15 @@
 
 class TieringCostInfo(_serialization.Model):
     """Base class for tiering cost response.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     TieringCostRehydrationInfo, TieringCostSavingInfo
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -21769,15 +21857,15 @@
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
 
 
 class TieringCostRehydrationInfo(TieringCostInfo):
     """Response parameters for tiering cost info for rehydration.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar rehydration_size_in_bytes: Rehydration size in bytes. Required.
     :vartype rehydration_size_in_bytes: int
     :ivar retail_rehydration_cost_per_gb_per_month: Source tier to target tier rehydration cost per
@@ -21812,15 +21900,15 @@
         self.rehydration_size_in_bytes = rehydration_size_in_bytes
         self.retail_rehydration_cost_per_gb_per_month = retail_rehydration_cost_per_gb_per_month
 
 
 class TieringCostSavingInfo(TieringCostInfo):
     """Response parameters for tiering cost info for savings.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar source_tier_size_reduction_in_bytes: Source tier size reduction in bytes after moving all
      the recommended backup points to target tier. Required.
     :vartype source_tier_size_reduction_in_bytes: int
@@ -21988,15 +22076,15 @@
         self.expiry_time_in_utc_ticks = expiry_time_in_utc_ticks
         self.security_pin = security_pin
 
 
 class TriggerDataMoveRequest(_serialization.Model):
     """Trigger DataMove Request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar source_resource_id: ARM Id of source vault. Required.
     :vartype source_resource_id: str
     :ivar source_region: Source Region. Required.
     :vartype source_region: str
     :ivar data_move_level: DataMove Level. Required. Known values are: "Invalid", "Vault", and
      "Container".
@@ -22188,15 +22276,15 @@
 
 class ValidateOperationRequest(_serialization.Model):
     """Base class for validate operation request.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     ValidateRestoreOperationRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -22217,15 +22305,15 @@
 
 class ValidateRestoreOperationRequest(ValidateOperationRequest):
     """AzureRestoreValidation request.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     ValidateIaasVMRestoreOperationRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar restore_request: Sets restore request to be validated.
     :vartype restore_request: ~azure.mgmt.recoveryservicesbackup.activestamp.models.RestoreRequest
     """
@@ -22251,15 +22339,15 @@
         self.object_type: str = "ValidateRestoreOperationRequest"
         self.restore_request = restore_request
 
 
 class ValidateIaasVMRestoreOperationRequest(ValidateRestoreOperationRequest):
     """AzureRestoreValidation request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar restore_request: Sets restore request to be validated.
     :vartype restore_request: ~azure.mgmt.recoveryservicesbackup.activestamp.models.RestoreRequest
     """
@@ -22282,15 +22370,15 @@
         super().__init__(restore_request=restore_request, **kwargs)
         self.object_type: str = "ValidateIaasVMRestoreOperationRequest"
 
 
 class ValidateOperationRequestResource(_serialization.Model):
     """Base class for validate operation request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar id: Recovery point ID. Required.
     :vartype id: str
     :ivar properties: ValidateOperationRequestResource properties. Required.
     :vartype properties:
      ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequest
     """
@@ -22369,15 +22457,15 @@
         super().__init__(**kwargs)
         self.validate_operation_response = validate_operation_response
 
 
 class VaultJob(Job):  # pylint: disable=too-many-instance-attributes
     """Vault level Job.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -22549,15 +22637,15 @@
         super().__init__(**kwargs)
         self.property_bag = property_bag
 
 
 class VaultRetentionPolicy(_serialization.Model):
     """Vault retention policy for AzureFileShare.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar vault_retention: Base class for retention policy. Required.
     :vartype vault_retention: ~azure.mgmt.recoveryservicesbackup.activestamp.models.RetentionPolicy
     :ivar snapshot_retention_in_days: Required.
     :vartype snapshot_retention_in_days: int
     """
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_recovery_services_backup_client_enums.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/models/_recovery_services_backup_client_enums.py`

 * *Files 2% similar despite different names*

```diff
@@ -211,15 +211,15 @@
     ACTION_SUGGESTED = "ActionSuggested"
     INVALID = "Invalid"
 
 
 class HttpStatusCode(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """HTTP Status Code of the operation."""
 
-    CONTINUE = "Continue"
+    CONTINUE_ENUM = "Continue"
     SWITCHING_PROTOCOLS = "SwitchingProtocols"
     OK = "OK"
     CREATED = "Created"
     ACCEPTED = "Accepted"
     NON_AUTHORITATIVE_INFORMATION = "NonAuthoritativeInformation"
     NO_CONTENT = "NoContent"
     RESET_CONTENT = "ResetContent"
@@ -258,25 +258,30 @@
     UPGRADE_REQUIRED = "UpgradeRequired"
     INTERNAL_SERVER_ERROR = "InternalServerError"
     NOT_IMPLEMENTED = "NotImplemented"
     BAD_GATEWAY = "BadGateway"
     SERVICE_UNAVAILABLE = "ServiceUnavailable"
     GATEWAY_TIMEOUT = "GatewayTimeout"
     HTTP_VERSION_NOT_SUPPORTED = "HttpVersionNotSupported"
-    CONTINUE_ENUM = "Continue"
 
 
 class IAASVMPolicyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """IAASVMPolicyType."""
 
     INVALID = "Invalid"
     V1 = "V1"
     V2 = "V2"
 
 
+class IaasVMSnapshotConsistencyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """IaasVMSnapshotConsistencyType."""
+
+    ONLY_CRASH_CONSISTENT = "OnlyCrashConsistent"
+
+
 class InfrastructureEncryptionState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """InfrastructureEncryptionState."""
 
     INVALID = "Invalid"
     DISABLED = "Disabled"
     ENABLED = "Enabled"
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_engines_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_engines_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -44,15 +44,15 @@
     filter: Optional[str] = None,
     skip_token: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEngines",
     )  # pylint: disable=line-too-long
@@ -86,15 +86,15 @@
     filter: Optional[str] = None,
     skip_token: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEngines/{backupEngineName}",
     )  # pylint: disable=line-too-long
@@ -156,15 +156,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either BackupEngineBaseResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupEngineBaseResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -180,74 +179,69 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("BackupEngineBaseResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEngines"
-    }
-
     @distributed_trace
     def get(
         self,
         vault_name: str,
         resource_group_name: str,
         backup_engine_name: str,
         filter: Optional[str] = None,
@@ -263,15 +257,14 @@
         :type resource_group_name: str
         :param backup_engine_name: Name of the backup management server. Required.
         :type backup_engine_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupEngineBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupEngineBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -282,43 +275,38 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupEngineBaseResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             backup_engine_name=backup_engine_name,
             subscription_id=self._config.subscription_id,
             filter=filter,
             skip_token=skip_token,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupEngineBaseResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEngines/{backupEngineName}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_jobs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protected_items_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -44,21 +44,21 @@
     filter: Optional[str] = None,
     skip_token: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectedItems",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
@@ -73,22 +73,22 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BackupJobsOperations:
+class BackupProtectedItemsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`backup_jobs` attribute.
+        :attr:`backup_protected_items` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -100,101 +100,96 @@
     def list(
         self,
         vault_name: str,
         resource_group_name: str,
         filter: Optional[str] = None,
         skip_token: Optional[str] = None,
         **kwargs: Any
-    ) -> Iterable["_models.JobResource"]:
-        """Provides a pageable list of jobs.
+    ) -> Iterable["_models.ProtectedItemResource"]:
+        """Provides a pageable list of all items that are backed up within a vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either JobResource or the result of cls(response)
+        :return: An iterator like instance of either ProtectedItemResource or the result of
+         cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.JobResource]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ProtectedItemResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("JobResourceList", pipeline_response)
+            deserialized = self._deserialize("ProtectedItemResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_get_tiering_cost_operation_result_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -31,125 +31,119 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(
-    vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, vault_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupOperationResults/{operationId}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "vaultName": _SERIALIZER.url(
+            "vault_name", vault_name, "str", max_length=50, min_length=2, pattern=r"^[A-Za-z][-A-Za-z0-9]*[A-Za-z0-9]$"
+        ),
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BackupOperationResultsOperations:
+class GetTieringCostOperationResultOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`backup_operation_results` attribute.
+        :attr:`get_tiering_cost_operation_result` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def get(  # pylint: disable=inconsistent-return-statements
-        self, vault_name: str, resource_group_name: str, operation_id: str, **kwargs: Any
-    ) -> None:
-        """Provides the status of the delete operations such as deleting backed up item. Once the
-        operation has started, the
-        status code in the response would be Accepted. It will continue to be in this state till it
-        reaches completion. On
-        successful completion, the status code will be OK. This method expects OperationID as an
-        argument. OperationID is
-        part of the Location header of the operation response.
+    def get(
+        self, resource_group_name: str, vault_name: str, operation_id: str, **kwargs: Any
+    ) -> _models.TieringCostInfo:
+        """Gets the result of async operation for tiering cost.
 
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param operation_id: OperationID which represents the operation. Required.
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
+        :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: TieringCostInfo or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[_models.TieringCostInfo] = kwargs.pop("cls", None)
 
-        request = build_get_request(
-            vault_name=vault_name,
+        _request = build_get_request(
             resource_group_name=resource_group_name,
+            vault_name=vault_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202, 204]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
+        deserialized = self._deserialize("TieringCostInfo", pipeline_response)
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupOperationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_operation_statuses_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_statuses_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,21 +36,21 @@
 
 def build_get_request(
     vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupOperations/{operationId}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperationsStatuses/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
@@ -62,22 +62,22 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BackupOperationStatusesOperations:
+class ValidateOperationStatusesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`backup_operation_statuses` attribute.
+        :attr:`validate_operation_statuses` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -85,28 +85,28 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def get(
         self, vault_name: str, resource_group_name: str, operation_id: str, **kwargs: Any
     ) -> _models.OperationStatus:
-        """Fetches the status of an operation such as triggering a backup, restore. The status can be in
-        progress, completed
-        or failed. You can refer to the OperationStatus enum for all the possible states of an
-        operation. Some operations
-        create jobs. This method returns the list of jobs when the operation is complete.
+        """Fetches the status of a triggered validate operation. The status can be in progress, completed
+        or failed. You can refer to the OperationStatus enum for all the possible states of the
+        operation.
+        If operation has completed, this method returns the list of errors obtained while validating
+        the operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param operation_id: OperationID which represents the operation. Required.
+        :param operation_id: OperationID represents the operation whose status needs to be fetched.
+         Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -117,41 +117,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupOperations/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_policies_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protection_intent_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -33,155 +33,163 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
-    vault_name: str, resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
+    vault_name: str,
+    resource_group_name: str,
+    subscription_id: str,
+    *,
+    filter: Optional[str] = None,
+    skip_token: Optional[str] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies",
+        "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectionIntents",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
+    if skip_token is not None:
+        _params["$skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BackupPoliciesOperations:
+class BackupProtectionIntentOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`backup_policies` attribute.
+        :attr:`backup_protection_intent` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(
-        self, vault_name: str, resource_group_name: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> Iterable["_models.ProtectionPolicyResource"]:
-        """Lists of backup policies associated with Recovery Services Vault. API provides pagination
-        parameters to fetch
-        scoped results.
+        self,
+        vault_name: str,
+        resource_group_name: str,
+        filter: Optional[str] = None,
+        skip_token: Optional[str] = None,
+        **kwargs: Any
+    ) -> Iterable["_models.ProtectionIntentResource"]:
+        """Provides a pageable list of all intents that are present within a vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ProtectionPolicyResource or the result of
+        :param skip_token: skipToken Filter. Default value is None.
+        :type skip_token: str
+        :return: An iterator like instance of either ProtectionIntentResource or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectionPolicyResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ProtectionIntentResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
+                    skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProtectionPolicyResourceList", pipeline_response)
+            deserialized = self._deserialize("ProtectionIntentResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protectable_items_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protectable_items_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -44,15 +44,15 @@
     filter: Optional[str] = None,
     skip_token: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectableItems",
     )  # pylint: disable=line-too-long
@@ -114,15 +114,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either WorkloadProtectableItemResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.WorkloadProtectableItemResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -138,66 +137,61 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("WorkloadProtectableItemResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectableItems"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protected_items_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_jobs_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -44,21 +44,21 @@
     filter: Optional[str] = None,
     skip_token: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectedItems",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
@@ -73,22 +73,22 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BackupProtectedItemsOperations:
+class BackupJobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`backup_protected_items` attribute.
+        :attr:`backup_jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -100,102 +100,95 @@
     def list(
         self,
         vault_name: str,
         resource_group_name: str,
         filter: Optional[str] = None,
         skip_token: Optional[str] = None,
         **kwargs: Any
-    ) -> Iterable["_models.ProtectedItemResource"]:
-        """Provides a pageable list of all items that are backed up within a vault.
+    ) -> Iterable["_models.JobResource"]:
+        """Provides a pageable list of jobs.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ProtectedItemResource or the result of
-         cls(response)
+        :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectedItemResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProtectedItemResourceList", pipeline_response)
+            deserialized = self._deserialize("JobResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectedItems"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protection_containers_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_policies_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -38,21 +38,21 @@
 
 def build_list_request(
     vault_name: str, resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectionContainers",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
@@ -65,121 +65,117 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BackupProtectionContainersOperations:
+class BackupPoliciesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`backup_protection_containers` attribute.
+        :attr:`backup_policies` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(
         self, vault_name: str, resource_group_name: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> Iterable["_models.ProtectionContainerResource"]:
-        """Lists the containers registered to Recovery Services Vault.
+    ) -> Iterable["_models.ProtectionPolicyResource"]:
+        """Lists of backup policies associated with Recovery Services Vault. API provides pagination
+        parameters to fetch
+        scoped results.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ProtectionContainerResource or the result of
+        :return: An iterator like instance of either ProtectionPolicyResource or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectionContainerResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ProtectionPolicyResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProtectionContainerResourceList", pipeline_response)
+            deserialized = self._deserialize("ProtectionPolicyResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectionContainers"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protection_intent_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_protected_items_crr_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -23,15 +23,15 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
-from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
+from .._vendor import _convert_request
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
@@ -44,21 +44,21 @@
     filter: Optional[str] = None,
     skip_token: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-11-15"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectionIntents",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectedItems/",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
@@ -73,22 +73,22 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BackupProtectionIntentOperations:
+class BackupProtectedItemsCrrOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`backup_protection_intent` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.RecoveryServicesBackupPassiveClient`'s
+        :attr:`backup_protected_items_crr` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -100,102 +100,97 @@
     def list(
         self,
         vault_name: str,
         resource_group_name: str,
         filter: Optional[str] = None,
         skip_token: Optional[str] = None,
         **kwargs: Any
-    ) -> Iterable["_models.ProtectionIntentResource"]:
-        """Provides a pageable list of all intents that are present within a vault.
+    ) -> Iterable["_models.ProtectedItemResource"]:
+        """Provides a pageable list of all items that are backed up within a vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ProtectionIntentResource or the result of
+        :return: An iterator like instance of either ProtectedItemResource or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.ProtectedItemResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectionIntentResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ProtectedItemResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProtectionIntentResourceList", pipeline_response)
+            deserialized = self._deserialize("ProtectedItemResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectionIntents"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_encryption_configs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_encryption_configs_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -35,15 +35,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEncryptionConfigs/backupResourceEncryptionConfig",
     )  # pylint: disable=line-too-long
@@ -64,15 +64,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEncryptionConfigs/backupResourceEncryptionConfig",
@@ -92,15 +92,15 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BackupResourceEncryptionConfigsOperations:
+class BackupResourceEncryptionConfigsOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
         :attr:`backup_resource_encryption_configs` attribute.
@@ -122,15 +122,14 @@
         """Fetches Vault Encryption config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceEncryptionConfigExtendedResource or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceEncryptionConfigExtendedResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
@@ -142,48 +141,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupResourceEncryptionConfigExtendedResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceEncryptionConfigExtendedResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEncryptionConfigs/backupResourceEncryptionConfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def update(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceEncryptionConfigResource,
@@ -200,72 +194,66 @@
         :type resource_group_name: str
         :param parameters: Vault encryption input config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceEncryptionConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> None:
         """Updates Vault encryption config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault encryption input config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceEncryptionConfigResource, IO],
+        parameters: Union[_models.BackupResourceEncryptionConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         """Updates Vault encryption config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault encryption input config request. Is either a
-         BackupResourceEncryptionConfigResource type or a IO type. Required.
+         BackupResourceEncryptionConfigResource type or a IO[bytes] type. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceEncryptionConfigResource or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         IO[bytes]
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -285,40 +273,35 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceEncryptionConfigResource")
 
-        request = build_update_request(
+        _request = build_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupEncryptionConfigs/backupResourceEncryptionConfig"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_storage_configs_non_crr_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_storage_configs_non_crr_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -35,15 +35,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig",
     )  # pylint: disable=line-too-long
@@ -64,15 +64,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig",
@@ -96,15 +96,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_patch_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig",
@@ -124,15 +124,15 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BackupResourceStorageConfigsNonCRROperations:
+class BackupResourceStorageConfigsNonCRROperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
         :attr:`backup_resource_storage_configs_non_crr` attribute.
@@ -152,15 +152,14 @@
         """Fetches resource storage config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -171,48 +170,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupResourceConfigResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def update(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceConfigResource,
@@ -229,71 +223,65 @@
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceConfigResource:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceConfigResource, IO],
+        parameters: Union[_models.BackupResourceConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.BackupResourceConfigResource:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Is either a BackupResourceConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource or IO[bytes]
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -313,51 +301,46 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceConfigResource")
 
-        request = build_update_request(
+        _request = build_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    update.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceConfigResource,
@@ -374,71 +357,65 @@
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> None:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceConfigResource, IO],
+        parameters: Union[_models.BackupResourceConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Is either a BackupResourceConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceConfigResource or IO[bytes]
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -458,40 +435,35 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceConfigResource")
 
-        request = build_patch_request(
+        _request = build_patch_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    patch.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_vault_configs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_resource_vault_configs_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -35,15 +35,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupconfig/vaultconfig",
     )  # pylint: disable=line-too-long
@@ -60,19 +60,26 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_update_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_update_request(
+    vault_name: str,
+    resource_group_name: str,
+    subscription_id: str,
+    *,
+    x_ms_authorization_auxiliary: Optional[str] = None,
+    **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupconfig/vaultconfig",
@@ -85,26 +92,37 @@
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if x_ms_authorization_auxiliary is not None:
+        _headers["x-ms-authorization-auxiliary"] = _SERIALIZER.header(
+            "x_ms_authorization_auxiliary", x_ms_authorization_auxiliary, "str"
+        )
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_put_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_put_request(
+    vault_name: str,
+    resource_group_name: str,
+    subscription_id: str,
+    *,
+    x_ms_authorization_auxiliary: Optional[str] = None,
+    **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupconfig/vaultconfig",
@@ -117,14 +135,18 @@
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if x_ms_authorization_auxiliary is not None:
+        _headers["x-ms-authorization-auxiliary"] = _SERIALIZER.header(
+            "x_ms_authorization_auxiliary", x_ms_authorization_auxiliary, "str"
+        )
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
@@ -154,15 +176,14 @@
         """Fetches resource vault config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -173,129 +194,128 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupResourceVaultConfigResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceVaultConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupconfig/vaultconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def update(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceVaultConfigResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceVaultConfigResource, IO],
+        parameters: Union[_models.BackupResourceVaultConfigResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Is either a BackupResourceVaultConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource or
+         IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -315,132 +335,132 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceVaultConfigResource")
 
-        request = build_update_request(
+        _request = build_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceVaultConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupconfig/vaultconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def put(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceVaultConfigResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def put(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def put(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceVaultConfigResource, IO],
+        parameters: Union[_models.BackupResourceVaultConfigResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> _models.BackupResourceVaultConfigResource:
         """Updates vault security config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource config request. Is either a BackupResourceVaultConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource or
+         IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :return: BackupResourceVaultConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupResourceVaultConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -460,44 +480,40 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceVaultConfigResource")
 
-        request = build_put_request(
+        _request = build_put_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceVaultConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    put.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupconfig/vaultconfig"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_status_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_status_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -35,15 +35,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(azure_region: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupStatus",
@@ -101,59 +101,53 @@
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Container Backup Status Request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupStatusResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def get(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
+        self, azure_region: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.BackupStatusResponse:
         """Get the container backup status.
 
         Get the container backup status.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Container Backup Status Request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupStatusResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def get(
-        self, azure_region: str, parameters: Union[_models.BackupStatusRequest, IO], **kwargs: Any
+        self, azure_region: str, parameters: Union[_models.BackupStatusRequest, IO[bytes]], **kwargs: Any
     ) -> _models.BackupStatusResponse:
         """Get the container backup status.
 
         Get the container backup status.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Container Backup Status Request. Is either a BackupStatusRequest type or a
-         IO type. Required.
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusRequest or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         IO[bytes]
         :return: BackupStatusResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupStatusResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -173,42 +167,37 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupStatusRequest")
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupStatusResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupStatus"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_usage_summaries_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_usage_summaries_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -44,15 +44,15 @@
     filter: Optional[str] = None,
     skip_token: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupUsageSummaries",
     )  # pylint: disable=line-too-long
@@ -112,15 +112,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either BackupManagementUsage or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupManagementUsage]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -136,66 +135,61 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("BackupManagementUsageList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupUsageSummaries"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_workload_items_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_workload_items_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -46,15 +46,15 @@
     filter: Optional[str] = None,
     skip_token: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/items",
     )  # pylint: disable=line-too-long
@@ -124,15 +124,14 @@
         :type fabric_name: str
         :param container_name: Name of the container. Required.
         :type container_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either WorkloadItemResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.WorkloadItemResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -148,68 +147,63 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     fabric_name=fabric_name,
                     container_name=container_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("WorkloadItemResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/items"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backups_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backups_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -43,15 +43,15 @@
     protected_item_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/backup",
@@ -126,29 +126,28 @@
         :param protected_item_name: Backup item for which backup needs to be triggered. Required.
         :type protected_item_name: str
         :param parameters: resource backup request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupRequestResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def trigger(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> None:
         """Triggers backup for specified backed up item. This is an asynchronous operation. To know the
         status of the
         operation, call GetProtectedItemOperationResult API.
@@ -161,33 +160,32 @@
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Backup item for which backup needs to be triggered. Required.
         :type protected_item_name: str
         :param parameters: resource backup request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def trigger(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: Union[_models.BackupRequestResource, IO],
+        parameters: Union[_models.BackupRequestResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         """Triggers backup for specified backed up item. This is an asynchronous operation. To know the
         status of the
         operation, call GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
@@ -197,22 +195,18 @@
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Backup item for which backup needs to be triggered. Required.
         :type protected_item_name: str
-        :param parameters: resource backup request. Is either a BackupRequestResource type or a IO
-         type. Required.
+        :param parameters: resource backup request. Is either a BackupRequestResource type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupRequestResource
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         or IO[bytes]
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -232,42 +226,37 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupRequestResource")
 
-        request = build_trigger_request(
+        _request = build_trigger_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.trigger.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/backup"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_bms_prepare_data_move_operation_result_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_bms_prepare_data_move_operation_result_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,15 +36,15 @@
 
 def build_get_request(
     vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
@@ -62,15 +62,15 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class BMSPrepareDataMoveOperationResultOperations:
+class BMSPrepareDataMoveOperationResultOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
         :attr:`bms_prepare_data_move_operation_result` attribute.
@@ -94,15 +94,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: VaultStorageConfigOperationResultResponse or None or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.VaultStorageConfigOperationResultResponse
          or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -115,44 +114,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Optional[_models.VaultStorageConfigOperationResultResponse]] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("VaultStorageConfigOperationResultResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_deleted_protection_containers_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_protection_containers_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -33,31 +33,31 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
-    resource_group_name: str, vault_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
+    vault_name: str, resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupDeletedProtectionContainers",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectionContainers",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if filter is not None:
@@ -65,47 +65,46 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class DeletedProtectionContainersOperations:
+class BackupProtectionContainersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`deleted_protection_containers` attribute.
+        :attr:`backup_protection_containers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(
-        self, resource_group_name: str, vault_name: str, filter: Optional[str] = None, **kwargs: Any
+        self, vault_name: str, resource_group_name: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.ProtectionContainerResource"]:
-        """Lists the soft deleted containers registered to Recovery Services Vault.
+        """Lists the containers registered to Recovery Services Vault.
 
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ProtectionContainerResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -121,65 +120,60 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
-                    resource_group_name=resource_group_name,
+                _request = build_list_request(
                     vault_name=vault_name,
+                    resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ProtectionContainerResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupDeletedProtectionContainers"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_export_jobs_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_backup_operation_results_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,21 +36,21 @@
 
 def build_get_request(
     vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/operationResults/{operationId}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupOperationResults/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
@@ -62,99 +62,88 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ExportJobsOperationResultsOperations:
+class BackupOperationResultsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`export_jobs_operation_results` attribute.
+        :attr:`backup_operation_results` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def get(
+    def get(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, operation_id: str, **kwargs: Any
-    ) -> _models.OperationResultInfoBaseResource:
-        """Gets the operation result of operation triggered by Export Jobs API. If the operation is
-        successful, then it also
-        contains URL of a Blob and a SAS key to access the same. The blob contains exported jobs in
-        JSON serialized format.
+    ) -> None:
+        """Provides the status of the delete operations such as deleting backed up item. Once the
+        operation has started, the
+        status code in the response would be Accepted. It will continue to be in this state till it
+        reaches completion. On
+        successful completion, the status code will be OK. This method expects OperationID as an
+        argument. OperationID is
+        part of the Location header of the operation response.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param operation_id: OperationID which represents the export job. Required.
+        :param operation_id: OperationID which represents the operation. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: OperationResultInfoBaseResource or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationResultInfoBaseResource
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.OperationResultInfoBaseResource] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 200:
-            deserialized = self._deserialize("OperationResultInfoBaseResource", pipeline_response)
-
-        if response.status_code == 202:
-            deserialized = self._deserialize("OperationResultInfoBaseResource", pipeline_response)
-
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/operationResults/{operationId}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_feature_support_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_feature_support_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -35,15 +35,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_validate_request(azure_region: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupValidateFeatures",
@@ -101,61 +101,55 @@
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Feature support request object. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.FeatureSupportRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AzureVMResourceFeatureSupportResponse or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.AzureVMResourceFeatureSupportResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
+        self, azure_region: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AzureVMResourceFeatureSupportResponse:
         """It will validate if given feature with resource properties is supported in service.
 
         It will validate if given feature with resource properties is supported in service.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Feature support request object. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AzureVMResourceFeatureSupportResponse or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.AzureVMResourceFeatureSupportResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate(
-        self, azure_region: str, parameters: Union[_models.FeatureSupportRequest, IO], **kwargs: Any
+        self, azure_region: str, parameters: Union[_models.FeatureSupportRequest, IO[bytes]], **kwargs: Any
     ) -> _models.AzureVMResourceFeatureSupportResponse:
         """It will validate if given feature with resource properties is supported in service.
 
         It will validate if given feature with resource properties is supported in service.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Feature support request object. Is either a FeatureSupportRequest type or a
-         IO type. Required.
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.FeatureSupportRequest
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         or IO[bytes]
         :return: AzureVMResourceFeatureSupportResponse or the result of cls(response)
         :rtype:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.AzureVMResourceFeatureSupportResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
@@ -176,42 +170,37 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "FeatureSupportRequest")
 
-        request = build_validate_request(
+        _request = build_validate_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AzureVMResourceFeatureSupportResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    validate.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupValidateFeatures"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_fetch_tiering_cost_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_recovery_points_operations.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,65 +1,74 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
-from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
-from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
+from .._vendor import _convert_request
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_post_request(resource_group_name: str, vault_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_get_access_token_request(
+    vault_name: str,
+    resource_group_name: str,
+    fabric_name: str,
+    container_name: str,
+    protected_item_name: str,
+    recovery_point_id: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-11-15"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/fetchTieringCost",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/accessToken",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "vaultName": _SERIALIZER.url(
-            "vault_name", vault_name, "str", max_length=50, min_length=2, pattern=r"^[A-Za-z][-A-Za-z0-9]*[A-Za-z0-9]$"
-        ),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "fabricName": _SERIALIZER.url("fabric_name", fabric_name, "str"),
+        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
+        "protectedItemName": _SERIALIZER.url("protected_item_name", protected_item_name, "str"),
+        "recoveryPointId": _SERIALIZER.url("recovery_point_id", recovery_point_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -67,263 +76,205 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class FetchTieringCostOperations:
+class RecoveryPointsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`fetch_tiering_cost` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.RecoveryServicesBackupPassiveClient`'s
+        :attr:`recovery_points` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    def _post_initial(
-        self,
-        resource_group_name: str,
-        vault_name: str,
-        parameters: Union[_models.FetchTieringCostInfoRequest, IO],
-        **kwargs: Any
-    ) -> Optional[_models.TieringCostInfo]:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.TieringCostInfo]] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(parameters, (IOBase, bytes)):
-            _content = parameters
-        else:
-            _json = self._serialize.body(parameters, "FetchTieringCostInfoRequest")
-
-        request = build_post_request(
-            resource_group_name=resource_group_name,
-            vault_name=vault_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._post_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = None
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("TieringCostInfo", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)
-
-        return deserialized
-
-    _post_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/fetchTieringCost"
-    }
-
     @overload
-    def begin_post(
+    def get_access_token(
         self,
-        resource_group_name: str,
         vault_name: str,
-        parameters: _models.FetchTieringCostInfoRequest,
+        resource_group_name: str,
+        fabric_name: str,
+        container_name: str,
+        protected_item_name: str,
+        recovery_point_id: str,
+        parameters: _models.AADPropertiesResource,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.TieringCostInfo]:
-        """Provides the details of the tiering related sizes and cost.
-        Status of the operation can be fetched using GetTieringCostOperationStatus API and result using
-        GetTieringCostOperationResult API.
+    ) -> _models.CrrAccessTokenResource:
+        """Returns the Access token for communication between BMS and Protection service.
+
+        Returns the Access token for communication between BMS and Protection service.
 
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
-        :param parameters: Fetch Tiering Cost Request. Required.
-        :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.FetchTieringCostInfoRequest
+        :param fabric_name: Fabric name associated with the container. Required.
+        :type fabric_name: str
+        :param container_name: Name of the container. Required.
+        :type container_name: str
+        :param protected_item_name: Name of the Protected Item. Required.
+        :type protected_item_name: str
+        :param recovery_point_id: Recovery Point Id. Required.
+        :type recovery_point_id: str
+        :param parameters: Get Access Token request. Required.
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.AADPropertiesResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either TieringCostInfo or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
+        :return: CrrAccessTokenResource or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrAccessTokenResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_post(
+    def get_access_token(
         self,
-        resource_group_name: str,
         vault_name: str,
-        parameters: IO,
+        resource_group_name: str,
+        fabric_name: str,
+        container_name: str,
+        protected_item_name: str,
+        recovery_point_id: str,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.TieringCostInfo]:
-        """Provides the details of the tiering related sizes and cost.
-        Status of the operation can be fetched using GetTieringCostOperationStatus API and result using
-        GetTieringCostOperationResult API.
+    ) -> _models.CrrAccessTokenResource:
+        """Returns the Access token for communication between BMS and Protection service.
+
+        Returns the Access token for communication between BMS and Protection service.
 
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
-        :param parameters: Fetch Tiering Cost Request. Required.
-        :type parameters: IO
+        :param fabric_name: Fabric name associated with the container. Required.
+        :type fabric_name: str
+        :param container_name: Name of the container. Required.
+        :type container_name: str
+        :param protected_item_name: Name of the Protected Item. Required.
+        :type protected_item_name: str
+        :param recovery_point_id: Recovery Point Id. Required.
+        :type recovery_point_id: str
+        :param parameters: Get Access Token request. Required.
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either TieringCostInfo or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
+        :return: CrrAccessTokenResource or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrAccessTokenResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
-    def begin_post(
+    def get_access_token(
         self,
-        resource_group_name: str,
         vault_name: str,
-        parameters: Union[_models.FetchTieringCostInfoRequest, IO],
+        resource_group_name: str,
+        fabric_name: str,
+        container_name: str,
+        protected_item_name: str,
+        recovery_point_id: str,
+        parameters: Union[_models.AADPropertiesResource, IO[bytes]],
         **kwargs: Any
-    ) -> LROPoller[_models.TieringCostInfo]:
-        """Provides the details of the tiering related sizes and cost.
-        Status of the operation can be fetched using GetTieringCostOperationStatus API and result using
-        GetTieringCostOperationResult API.
+    ) -> _models.CrrAccessTokenResource:
+        """Returns the Access token for communication between BMS and Protection service.
+
+        Returns the Access token for communication between BMS and Protection service.
 
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
-        :param parameters: Fetch Tiering Cost Request. Is either a FetchTieringCostInfoRequest type or
-         a IO type. Required.
-        :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.FetchTieringCostInfoRequest or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either TieringCostInfo or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
+        :param fabric_name: Fabric name associated with the container. Required.
+        :type fabric_name: str
+        :param container_name: Name of the container. Required.
+        :type container_name: str
+        :param protected_item_name: Name of the Protected Item. Required.
+        :type protected_item_name: str
+        :param recovery_point_id: Recovery Point Id. Required.
+        :type recovery_point_id: str
+        :param parameters: Get Access Token request. Is either a AADPropertiesResource type or a
+         IO[bytes] type. Required.
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.AADPropertiesResource
+         or IO[bytes]
+        :return: CrrAccessTokenResource or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrAccessTokenResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+            400: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.TieringCostInfo] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._post_initial(
-                resource_group_name=resource_group_name,
-                vault_name=vault_name,
-                parameters=parameters,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("TieringCostInfo", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+        cls: ClsType[_models.CrrAccessTokenResource] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(parameters, (IOBase, bytes)):
+            _content = parameters
         else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+            _json = self._serialize.body(parameters, "AADPropertiesResource")
 
-    begin_post.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/fetchTieringCost"
-    }
+        _request = build_get_access_token_request(
+            vault_name=vault_name,
+            resource_group_name=resource_group_name,
+            fabric_name=fabric_name,
+            container_name=container_name,
+            protected_item_name=protected_item_name,
+            recovery_point_id=recovery_point_id,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            headers=_headers,
+            params=_params,
+        )
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("CrrAccessTokenResource", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})  # type: ignore
+
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_get_tiering_cost_operation_result_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policy_operation_results_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -31,125 +31,122 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(
-    resource_group_name: str, vault_name: str, operation_id: str, subscription_id: str, **kwargs: Any
+    vault_name: str, resource_group_name: str, policy_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/operationResults/{operationId}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "vaultName": _SERIALIZER.url(
-            "vault_name", vault_name, "str", max_length=50, min_length=2, pattern=r"^[A-Za-z][-A-Za-z0-9]*[A-Za-z0-9]$"
-        ),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "policyName": _SERIALIZER.url("policy_name", policy_name, "str"),
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class GetTieringCostOperationResultOperations:
+class ProtectionPolicyOperationResultsOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`get_tiering_cost_operation_result` attribute.
+        :attr:`protection_policy_operation_results` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def get(
-        self, resource_group_name: str, vault_name: str, operation_id: str, **kwargs: Any
-    ) -> _models.TieringCostInfo:
-        """Gets the result of async operation for tiering cost.
+        self, vault_name: str, resource_group_name: str, policy_name: str, operation_id: str, **kwargs: Any
+    ) -> _models.ProtectionPolicyResource:
+        """Provides the result of an operation.
 
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
-        :param operation_id: Required.
+        :param policy_name: Backup policy name whose operation's result needs to be fetched. Required.
+        :type policy_name: str
+        :param operation_id: Operation ID which represents the operation whose result needs to be
+         fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: TieringCostInfo or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo
+        :return: ProtectionPolicyResource or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.TieringCostInfo] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ProtectionPolicyResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
-            resource_group_name=resource_group_name,
+        _request = build_get_request(
             vault_name=vault_name,
+            resource_group_name=resource_group_name,
+            policy_name=policy_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("TieringCostInfo", pipeline_response)
+        deserialized = self._deserialize("ProtectionPolicyResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_item_level_recovery_connections_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_recovery_points_crr_operations.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,109 +1,109 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from io import IOBase
-from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
-from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
+from .._vendor import _convert_request
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_provision_request(
+def build_list_request(
     vault_name: str,
     resource_group_name: str,
     fabric_name: str,
     container_name: str,
     protected_item_name: str,
-    recovery_point_id: str,
     subscription_id: str,
+    *,
+    filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-11-15"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/provisionInstantItemRecovery",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "fabricName": _SERIALIZER.url("fabric_name", fabric_name, "str"),
         "containerName": _SERIALIZER.url("container_name", container_name, "str"),
         "protectedItemName": _SERIALIZER.url("protected_item_name", protected_item_name, "str"),
-        "recoveryPointId": _SERIALIZER.url("recovery_point_id", recovery_point_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
 
     # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_revoke_request(
+def build_get_request(
     vault_name: str,
     resource_group_name: str,
     fabric_name: str,
     container_name: str,
     protected_item_name: str,
     recovery_point_id: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-11-15"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/revokeInstantItemRecovery",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "fabricName": _SERIALIZER.url("fabric_name", fabric_name, "str"),
         "containerName": _SERIALIZER.url("container_name", container_name, "str"),
@@ -115,312 +115,215 @@
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ItemLevelRecoveryConnectionsOperations:
+class RecoveryPointsCrrOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`item_level_recovery_connections` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.RecoveryServicesBackupPassiveClient`'s
+        :attr:`recovery_points_crr` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    @overload
-    def provision(  # pylint: disable=inconsistent-return-statements
-        self,
-        vault_name: str,
-        resource_group_name: str,
-        fabric_name: str,
-        container_name: str,
-        protected_item_name: str,
-        recovery_point_id: str,
-        parameters: _models.ILRRequestResource,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> None:
-        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
-        opens a file
-        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
-        To know the status of
-        provisioning, call GetProtectedItemOperationResult API.
-
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
-        :param resource_group_name: The name of the resource group where the recovery services vault is
-         present. Required.
-        :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up items. Required.
-        :type fabric_name: str
-        :param container_name: Container name associated with the backed up items. Required.
-        :type container_name: str
-        :param protected_item_name: Backed up item name whose files/folders are to be restored.
-         Required.
-        :type protected_item_name: str
-        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
-         will be provisioned
-         for this backed up data. Required.
-        :type recovery_point_id: str
-        :param parameters: resource ILR request. Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ILRRequestResource
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def provision(  # pylint: disable=inconsistent-return-statements
+    @distributed_trace
+    def list(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        recovery_point_id: str,
-        parameters: IO,
-        *,
-        content_type: str = "application/json",
+        filter: Optional[str] = None,
         **kwargs: Any
-    ) -> None:
-        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
-        opens a file
-        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
-        To know the status of
-        provisioning, call GetProtectedItemOperationResult API.
+    ) -> Iterable["_models.RecoveryPointResource"]:
+        """Lists the backup copies for the backed up item.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up items. Required.
+        :param fabric_name: Fabric name associated with the backed up item. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backed up items. Required.
+        :param container_name: Container name associated with the backed up item. Required.
         :type container_name: str
-        :param protected_item_name: Backed up item name whose files/folders are to be restored.
-         Required.
+        :param protected_item_name: Backed up item whose backup copies are to be fetched. Required.
         :type protected_item_name: str
-        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
-         will be provisioned
-         for this backed up data. Required.
-        :type recovery_point_id: str
-        :param parameters: resource ILR request. Required.
-        :type parameters: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :param filter: OData filter options. Default value is None.
+        :type filter: str
+        :return: An iterator like instance of either RecoveryPointResource or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    @distributed_trace
-    def provision(  # pylint: disable=inconsistent-return-statements
-        self,
-        vault_name: str,
-        resource_group_name: str,
-        fabric_name: str,
-        container_name: str,
-        protected_item_name: str,
-        recovery_point_id: str,
-        parameters: Union[_models.ILRRequestResource, IO],
-        **kwargs: Any
-    ) -> None:
-        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
-        opens a file
-        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
-        To know the status of
-        provisioning, call GetProtectedItemOperationResult API.
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.RecoveryPointResourceList] = kwargs.pop("cls", None)
 
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
-        :param resource_group_name: The name of the resource group where the recovery services vault is
-         present. Required.
-        :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up items. Required.
-        :type fabric_name: str
-        :param container_name: Container name associated with the backed up items. Required.
-        :type container_name: str
-        :param protected_item_name: Backed up item name whose files/folders are to be restored.
-         Required.
-        :type protected_item_name: str
-        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
-         will be provisioned
-         for this backed up data. Required.
-        :type recovery_point_id: str
-        :param parameters: resource ILR request. Is either a ILRRequestResource type or a IO type.
-         Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ILRRequestResource or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(parameters, (IOBase, bytes)):
-            _content = parameters
-        else:
-            _json = self._serialize.body(parameters, "ILRRequestResource")
-
-        request = build_provision_request(
-            vault_name=vault_name,
-            resource_group_name=resource_group_name,
-            fabric_name=fabric_name,
-            container_name=container_name,
-            protected_item_name=protected_item_name,
-            recovery_point_id=recovery_point_id,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self.provision.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        if response.status_code not in [202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                _request = build_list_request(
+                    vault_name=vault_name,
+                    resource_group_name=resource_group_name,
+                    fabric_name=fabric_name,
+                    container_name=container_name,
+                    protected_item_name=protected_item_name,
+                    subscription_id=self._config.subscription_id,
+                    filter=filter,
+                    api_version=api_version,
+                    headers=_headers,
+                    params=_params,
+                )
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                _request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
+
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("RecoveryPointResourceList", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, iter(list_of_elem)
+
+        def get_next(next_link=None):
+            _request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                _request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        if cls:
-            return cls(pipeline_response, None, {})
+            return pipeline_response
 
-    provision.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/provisionInstantItemRecovery"
-    }
+        return ItemPaged(get_next, extract_data)
 
     @distributed_trace
-    def revoke(  # pylint: disable=inconsistent-return-statements
+    def get(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
         **kwargs: Any
-    ) -> None:
-        """Revokes an iSCSI connection which can be used to download a script. Executing this script opens
-        a file explorer
-        displaying all recoverable files and folders. This is an asynchronous operation.
+    ) -> _models.RecoveryPointResource:
+        """Provides the information of the backed up data identified using RecoveryPointID.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the backed up items. Required.
+        :param fabric_name: Fabric name associated with backed up item. Required.
         :type fabric_name: str
-        :param container_name: Container name associated with the backed up items. Required.
+        :param container_name: Container name associated with backed up item. Required.
         :type container_name: str
-        :param protected_item_name: Backed up item name whose files/folders are to be restored.
+        :param protected_item_name: Backed up item name whose backup data needs to be fetched.
          Required.
         :type protected_item_name: str
-        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
-         will be revoked for
-         this backed up data. Required.
+        :param recovery_point_id: RecoveryPointID represents the backed up data to be fetched.
+         Required.
         :type recovery_point_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: RecoveryPointResource or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.RecoveryPointResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RecoveryPointResource] = kwargs.pop("cls", None)
 
-        request = build_revoke_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.revoke.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("RecoveryPointResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    revoke.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/revokeInstantItemRecovery"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_cancellations_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_cancellations_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,15 +36,15 @@
 
 def build_trigger_request(
     vault_name: str, resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/{jobName}/cancel",
     )  # pylint: disable=line-too-long
@@ -95,15 +95,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param job_name: Name of the job to cancel. Required.
         :type job_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -114,37 +113,32 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_trigger_request(
+        _request = build_trigger_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.trigger.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/{jobName}/cancel"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_details_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_details_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,15 +36,15 @@
 
 def build_get_request(
     vault_name: str, resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -92,15 +92,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param job_name: Name of the job whose details are to be fetched. Required.
         :type job_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -111,41 +110,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/{jobName}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_job_operation_results_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,15 +36,15 @@
 
 def build_get_request(
     vault_name: str, resource_group_name: str, job_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/{jobName}/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
@@ -98,15 +98,14 @@
          present. Required.
         :type resource_group_name: str
         :param job_name: Job name whose operation result has to be fetched. Required.
         :type job_name: str
         :param operation_id: OperationID which represents the operation whose result has to be fetched.
          Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -117,38 +116,33 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             job_name=job_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/{jobName}/operationResults/{operationId}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_jobs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_container_refresh_operation_results_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -30,80 +30,82 @@
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_export_request(
-    vault_name: str, resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
+def build_get_request(
+    vault_name: str, resource_group_name: str, fabric_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobsExport",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "fabricName": _SERIALIZER.url("fabric_name", fabric_name, "str"),
+        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-    if filter is not None:
-        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class JobsOperations:
+class ProtectionContainerRefreshOperationResultsOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`jobs` attribute.
+        :attr:`protection_container_refresh_operation_results` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def export(  # pylint: disable=inconsistent-return-statements
-        self, vault_name: str, resource_group_name: str, filter: Optional[str] = None, **kwargs: Any
+    def get(  # pylint: disable=inconsistent-return-statements
+        self, vault_name: str, resource_group_name: str, fabric_name: str, operation_id: str, **kwargs: Any
     ) -> None:
-        """Triggers export of jobs specified by filters and returns an OperationID to track.
+        """Provides the result of the refresh operation triggered by the BeginRefresh operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param filter: OData filter options. Default value is None.
-        :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+        :param fabric_name: Fabric name associated with the container. Required.
+        :type fabric_name: str
+        :param operation_id: Operation ID associated with the operation whose result needs to be
+         fetched. Required.
+        :type operation_id: str
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -114,37 +116,33 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_export_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
+            fabric_name=fabric_name,
+            operation_id=operation_id,
             subscription_id=self._config.subscription_id,
-            filter=filter,
             api_version=api_version,
-            template_url=self.export.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202]:
+        if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    export.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobsExport"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_operation_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_operation_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -37,15 +37,15 @@
 
 def build_validate_request(
     vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperation",
@@ -107,71 +107,66 @@
         :type resource_group_name: str
         :param parameters: resource validate operation request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidateOperationsResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationsResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ValidateOperationsResponse:
         """Validate operation for specified backed up item. This is a synchronous operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidateOperationsResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationsResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.ValidateOperationRequestResource, IO],
+        parameters: Union[_models.ValidateOperationRequestResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.ValidateOperationsResponse:
         """Validate operation for specified backed up item. This is a synchronous operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Is either a
-         ValidateOperationRequestResource type or a IO type. Required.
+         ValidateOperationRequestResource type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource or
+         IO[bytes]
         :return: ValidateOperationsResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationsResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -191,43 +186,38 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ValidateOperationRequestResource")
 
-        request = build_validate_request(
+        _request = build_validate_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ValidateOperationsResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    validate.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperation"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,15 +36,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.RecoveryServices/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -74,15 +74,14 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.ClientDiscoveryValueForSingleApi"]:
         """Returns the list of available operations.
 
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ClientDiscoveryValueForSingleApi or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ClientDiscoveryValueForSingleApi]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -98,59 +97,56 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ClientDiscoveryResponse", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {"url": "/providers/Microsoft.RecoveryServices/operations"}
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_private_endpoint_connection_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_private_endpoint_connection_operations.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -43,15 +43,15 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}",
     )  # pylint: disable=line-too-long
@@ -81,15 +81,15 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}",
@@ -122,15 +122,15 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}",
     )  # pylint: disable=line-too-long
@@ -182,15 +182,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: PrivateEndpointConnectionResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -201,56 +200,51 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnectionResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("PrivateEndpointConnectionResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
+        return deserialized  # type: ignore
 
     def _put_initial(
         self,
         vault_name: str,
         resource_group_name: str,
         private_endpoint_connection_name: str,
-        parameters: Union[_models.PrivateEndpointConnectionResource, IO],
+        parameters: Union[_models.PrivateEndpointConnectionResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.PrivateEndpointConnectionResource:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -268,33 +262,32 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "PrivateEndpointConnectionResource")
 
-        request = build_put_request(
+        _request = build_put_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._put_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -306,18 +299,14 @@
             deserialized = self._deserialize("PrivateEndpointConnectionResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
-    _put_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
-
     @overload
     def begin_put(
         self,
         vault_name: str,
         resource_group_name: str,
         private_endpoint_connection_name: str,
         parameters: _models.PrivateEndpointConnectionResource,
@@ -336,102 +325,76 @@
         :type private_endpoint_connection_name: str
         :param parameters: Request body for operation. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either PrivateEndpointConnectionResource or the
          result of cls(response)
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_put(
         self,
         vault_name: str,
         resource_group_name: str,
         private_endpoint_connection_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.PrivateEndpointConnectionResource]:
         """Approve or Reject Private Endpoint requests. This call is made by Backup Admin.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param parameters: Request body for operation. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either PrivateEndpointConnectionResource or the
          result of cls(response)
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_put(
         self,
         vault_name: str,
         resource_group_name: str,
         private_endpoint_connection_name: str,
-        parameters: Union[_models.PrivateEndpointConnectionResource, IO],
+        parameters: Union[_models.PrivateEndpointConnectionResource, IO[bytes]],
         **kwargs: Any
     ) -> LROPoller[_models.PrivateEndpointConnectionResource]:
         """Approve or Reject Private Endpoint requests. This call is made by Backup Admin.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param parameters: Request body for operation. Is either a PrivateEndpointConnectionResource
-         type or a IO type. Required.
+         type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource or
+         IO[bytes]
         :return: An instance of LROPoller that returns either PrivateEndpointConnectionResource or the
          result of cls(response)
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.PrivateEndpointConnectionResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
@@ -457,35 +420,33 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("PrivateEndpointConnectionResource", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, {})  # type: ignore
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return LROPoller[_models.PrivateEndpointConnectionResource].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_put.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
+        return LROPoller[_models.PrivateEndpointConnectionResource](
+            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
+        )
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, private_endpoint_connection_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -496,66 +457,53 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @distributed_trace
     def begin_delete(
         self, vault_name: str, resource_group_name: str, private_endpoint_connection_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Delete Private Endpoint requests. This call is made by Backup Admin.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -575,27 +523,23 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
             polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return LROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}"
-    }
+        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_private_endpoint_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_private_endpoint_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -41,15 +41,15 @@
     operation_id: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}/operationsStatus/{operationId}",
     )  # pylint: disable=line-too-long
@@ -111,15 +111,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param operation_id: Operation id. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -130,43 +129,38 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_operation_status_request(
+        _request = build_get_operation_status_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get_operation_status.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}/operationsStatus/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protectable_containers_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protectable_containers_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -44,15 +44,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectableContainers",
     )  # pylint: disable=line-too-long
@@ -106,15 +106,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Required.
         :type fabric_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ProtectableContainerResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectableContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -130,66 +129,61 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     fabric_name=fabric_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ProtectableContainerResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectableContainers"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_item_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_item_operation_results_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -43,15 +43,15 @@
     operation_id: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
@@ -118,15 +118,14 @@
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Backup item name whose details are to be fetched. Required.
         :type protected_item_name: str
         :param operation_id: OperationID which represents the operation whose result needs to be
          fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectedItemResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -137,46 +136,41 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Optional[_models.ProtectedItemResource]] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("ProtectedItemResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_item_operation_statuses_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_item_operation_statuses_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -43,15 +43,15 @@
     operation_id: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/operationsStatus/{operationId}",
     )  # pylint: disable=line-too-long
@@ -122,15 +122,14 @@
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Backup item name whose details are to be fetched. Required.
         :type protected_item_name: str
         :param operation_id: OperationID represents the operation whose status needs to be fetched.
          Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -141,44 +140,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/operationsStatus/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_items_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protected_items_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -45,15 +45,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}",
     )  # pylint: disable=line-too-long
@@ -82,20 +82,22 @@
 def build_create_or_update_request(
     vault_name: str,
     resource_group_name: str,
     fabric_name: str,
     container_name: str,
     protected_item_name: str,
     subscription_id: str,
+    *,
+    x_ms_authorization_auxiliary: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}",
@@ -111,14 +113,18 @@
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if x_ms_authorization_auxiliary is not None:
+        _headers["x-ms-authorization-auxiliary"] = _SERIALIZER.header(
+            "x_ms_authorization_auxiliary", x_ms_authorization_auxiliary, "str"
+        )
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
@@ -130,15 +136,15 @@
     protected_item_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}",
     )  # pylint: disable=line-too-long
@@ -205,15 +211,14 @@
         :type fabric_name: str
         :param container_name: Container name associated with the backed up item. Required.
         :type container_name: str
         :param protected_item_name: Backed up item name whose details are to be fetched. Required.
         :type protected_item_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectedItemResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -224,61 +229,57 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProtectedItemResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             subscription_id=self._config.subscription_id,
             filter=filter,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectedItemResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         parameters: _models.ProtectedItemResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ProtectedItemResource]:
         """Enables backup of an item or to modifies the backup policy information of an already backed up
         item. This is an
         asynchronous operation. To know the status of the operation, call the GetItemOperationResult
@@ -293,32 +294,34 @@
         :type fabric_name: str
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Item name to be backed up. Required.
         :type protected_item_name: str
         :param parameters: resource backed up item. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectedItemResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ProtectedItemResource]:
         """Enables backup of an item or to modifies the backup policy information of an already backed up
         item. This is an
         asynchronous operation. To know the status of the operation, call the GetItemOperationResult
@@ -332,33 +335,35 @@
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Item name to be backed up. Required.
         :type protected_item_name: str
         :param parameters: resource backed up item. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectedItemResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: Union[_models.ProtectedItemResource, IO],
+        parameters: Union[_models.ProtectedItemResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> Optional[_models.ProtectedItemResource]:
         """Enables backup of an item or to modifies the backup policy information of an already backed up
         item. This is an
         asynchronous operation. To know the status of the operation, call the GetItemOperationResult
         API.
 
@@ -369,22 +374,20 @@
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param container_name: Container name associated with the backup item. Required.
         :type container_name: str
         :param protected_item_name: Item name to be backed up. Required.
         :type protected_item_name: str
-        :param parameters: resource backed up item. Is either a ProtectedItemResource type or a IO
-         type. Required.
+        :param parameters: resource backed up item. Is either a ProtectedItemResource type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         or IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :return: ProtectedItemResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectedItemResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -404,55 +407,51 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ProtectedItemResource")
 
-        request = build_create_or_update_request(
+        _request = build_create_or_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("ProtectedItemResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}"
-    }
+        return deserialized  # type: ignore
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
@@ -471,15 +470,14 @@
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backed up item. Required.
         :type fabric_name: str
         :param container_name: Container name associated with the backed up item. Required.
         :type container_name: str
         :param protected_item_name: Backed up item to be deleted. Required.
         :type protected_item_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -490,39 +488,34 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_container_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_container_operation_results_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -42,15 +42,15 @@
     operation_id: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
@@ -70,15 +70,15 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ProtectionContainerOperationResultsOperations:
+class ProtectionContainerOperationResultsOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
         :attr:`protection_container_operation_results` attribute.
@@ -113,15 +113,14 @@
         :param fabric_name: Fabric name associated with the container. Required.
         :type fabric_name: str
         :param container_name: Container name whose information should be fetched. Required.
         :type container_name: str
         :param operation_id: Operation ID which represents the operation whose result needs to be
          fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionContainerResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource or
          None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
@@ -133,45 +132,40 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Optional[_models.ProtectionContainerResource]] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("ProtectionContainerResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_container_refresh_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_export_jobs_operation_results_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -31,124 +31,124 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(
-    vault_name: str, resource_group_name: str, fabric_name: str, operation_id: str, subscription_id: str, **kwargs: Any
+    vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/operationResults/{operationId}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupJobs/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "fabricName": _SERIALIZER.url("fabric_name", fabric_name, "str"),
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ProtectionContainerRefreshOperationResultsOperations:
+class ExportJobsOperationResultsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`protection_container_refresh_operation_results` attribute.
+        :attr:`export_jobs_operation_results` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def get(  # pylint: disable=inconsistent-return-statements
-        self, vault_name: str, resource_group_name: str, fabric_name: str, operation_id: str, **kwargs: Any
-    ) -> None:
-        """Provides the result of the refresh operation triggered by the BeginRefresh operation.
+    def get(
+        self, vault_name: str, resource_group_name: str, operation_id: str, **kwargs: Any
+    ) -> _models.OperationResultInfoBaseResource:
+        """Gets the operation result of operation triggered by Export Jobs API. If the operation is
+        successful, then it also
+        contains URL of a Blob and a SAS key to access the same. The blob contains exported jobs in
+        JSON serialized format.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the container. Required.
-        :type fabric_name: str
-        :param operation_id: Operation ID associated with the operation whose result needs to be
-         fetched. Required.
+        :param operation_id: OperationID which represents the export job. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: OperationResultInfoBaseResource or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationResultInfoBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[_models.OperationResultInfoBaseResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
-            fabric_name=fabric_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
+        if response.status_code == 200:
+            deserialized = self._deserialize("OperationResultInfoBaseResource", pipeline_response)
+
+        if response.status_code == 202:
+            deserialized = self._deserialize("OperationResultInfoBaseResource", pipeline_response)
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_containers_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_containers_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -44,15 +44,15 @@
     container_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}",
     )  # pylint: disable=line-too-long
@@ -82,15 +82,15 @@
     container_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}",
@@ -123,15 +123,15 @@
     container_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}",
     )  # pylint: disable=line-too-long
@@ -163,15 +163,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/inquire",
     )  # pylint: disable=line-too-long
@@ -204,15 +204,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/refreshContainers",
     )  # pylint: disable=line-too-long
@@ -266,15 +266,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Name of the fabric where the container belongs. Required.
         :type fabric_name: str
         :param container_name: Name of the container whose details need to be fetched. Required.
         :type container_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionContainerResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -285,57 +284,52 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProtectionContainerResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectionContainerResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}"
-    }
+        return deserialized  # type: ignore
 
     def _register_initial(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
-        parameters: Union[_models.ProtectionContainerResource, IO],
+        parameters: Union[_models.ProtectionContainerResource, IO[bytes]],
         **kwargs: Any
     ) -> Optional[_models.ProtectionContainerResource]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -353,54 +347,49 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ProtectionContainerResource")
 
-        request = build_register_request(
+        _request = build_register_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._register_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("ProtectionContainerResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    _register_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def begin_register(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
@@ -426,37 +415,29 @@
         :type container_name: str
         :param parameters: Request body for operation. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either ProtectionContainerResource or the result
          of cls(response)
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_register(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.ProtectionContainerResource]:
         """Registers the container with Recovery Services vault.
         This is an asynchronous operation. To track the operation status, use location header to call
         get latest status of
@@ -468,41 +449,33 @@
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the container. Required.
         :type fabric_name: str
         :param container_name: Name of the container to be registered. Required.
         :type container_name: str
         :param parameters: Request body for operation. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either ProtectionContainerResource or the result
          of cls(response)
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_register(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
-        parameters: Union[_models.ProtectionContainerResource, IO],
+        parameters: Union[_models.ProtectionContainerResource, IO[bytes]],
         **kwargs: Any
     ) -> LROPoller[_models.ProtectionContainerResource]:
         """Registers the container with Recovery Services vault.
         This is an asynchronous operation. To track the operation status, use location header to call
         get latest status of
         the operation.
 
@@ -512,28 +485,17 @@
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the container. Required.
         :type fabric_name: str
         :param container_name: Name of the container to be registered. Required.
         :type container_name: str
         :param parameters: Request body for operation. Is either a ProtectionContainerResource type or
-         a IO type. Required.
+         a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource or IO[bytes]
         :return: An instance of LROPoller that returns either ProtectionContainerResource or the result
          of cls(response)
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionContainerResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
@@ -560,35 +522,33 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("ProtectionContainerResource", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, {})  # type: ignore
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return LROPoller[_models.ProtectionContainerResource].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_register.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}"
-    }
+        return LROPoller[_models.ProtectionContainerResource](
+            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
+        )
 
     @distributed_trace
     def unregister(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, fabric_name: str, container_name: str, **kwargs: Any
     ) -> None:
         """Unregisters the given container from your Recovery Services Vault. This is an asynchronous
         operation. To determine
@@ -601,15 +561,14 @@
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Name of the fabric where the container belongs. Required.
         :type fabric_name: str
         :param container_name: Name of the container which needs to be unregistered from the Recovery
          Services Vault. Required.
         :type container_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -620,45 +579,40 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_unregister_request(
+        _request = build_unregister_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.unregister.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    unregister.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @distributed_trace
     def inquire(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
@@ -678,15 +632,14 @@
         :type resource_group_name: str
         :param fabric_name: Fabric Name associated with the container. Required.
         :type fabric_name: str
         :param container_name: Name of the container in which inquiry needs to be triggered. Required.
         :type container_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -697,46 +650,41 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_inquire_request(
+        _request = build_inquire_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             subscription_id=self._config.subscription_id,
             filter=filter,
             api_version=api_version,
-            template_url=self.inquire.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    inquire.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/inquire"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @distributed_trace
     def refresh(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, fabric_name: str, filter: Optional[str] = None, **kwargs: Any
     ) -> None:
         """Discovers all the containers in the subscription that can be backed up to Recovery Services
         Vault. This is an
@@ -748,15 +696,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated the container. Required.
         :type fabric_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -767,38 +714,33 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_refresh_request(
+        _request = build_refresh_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             subscription_id=self._config.subscription_id,
             filter=filter,
             api_version=api_version,
-            template_url=self.refresh.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    refresh.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/refreshContainers"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_intent_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_intent_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -35,15 +35,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_validate_request(azure_region: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupPreValidateProtection",
@@ -73,15 +73,15 @@
     intent_object_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/backupProtectionIntent/{intentObjectName}",
     )  # pylint: disable=line-too-long
@@ -111,15 +111,15 @@
     intent_object_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/backupProtectionIntent/{intentObjectName}",
@@ -151,15 +151,15 @@
     fabric_name: str,
     intent_object_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/backupProtectionIntent/{intentObjectName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
@@ -223,23 +223,22 @@
         :type azure_region: str
         :param parameters: Enable backup validation request on Virtual Machine. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: PreValidateEnableBackupResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
+        self, azure_region: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.PreValidateEnableBackupResponse:
         """It will validate followings
 
 
         #. Vault capacity
         #. VM is already protected
         #. Any VM related configuration passed in properties.
@@ -250,27 +249,26 @@
         #. Vault capacity
         #. VM is already protected
         #. Any VM related configuration passed in properties.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Enable backup validation request on Virtual Machine. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: PreValidateEnableBackupResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate(
-        self, azure_region: str, parameters: Union[_models.PreValidateEnableBackupRequest, IO], **kwargs: Any
+        self, azure_region: str, parameters: Union[_models.PreValidateEnableBackupRequest, IO[bytes]], **kwargs: Any
     ) -> _models.PreValidateEnableBackupResponse:
         """It will validate followings
 
 
         #. Vault capacity
         #. VM is already protected
         #. Any VM related configuration passed in properties.
@@ -281,21 +279,18 @@
         #. Vault capacity
         #. VM is already protected
         #. Any VM related configuration passed in properties.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Enable backup validation request on Virtual Machine. Is either a
-         PreValidateEnableBackupRequest type or a IO type. Required.
+         PreValidateEnableBackupRequest type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupRequest or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupRequest or
+         IO[bytes]
         :return: PreValidateEnableBackupResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.PreValidateEnableBackupResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -315,49 +310,44 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "PreValidateEnableBackupRequest")
 
-        request = build_validate_request(
+        _request = build_validate_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("PreValidateEnableBackupResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    validate.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupPreValidateProtection"
-    }
+        return deserialized  # type: ignore
 
     @distributed_trace
     def get(
         self, vault_name: str, resource_group_name: str, fabric_name: str, intent_object_name: str, **kwargs: Any
     ) -> _models.ProtectionIntentResource:
         """Provides the details of the protection intent up item. This is an asynchronous operation. To
         know the status of the operation,
@@ -368,15 +358,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backed up item. Required.
         :type fabric_name: str
         :param intent_object_name: Backed up item name whose details are to be fetched. Required.
         :type intent_object_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionIntentResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -387,49 +376,44 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProtectionIntentResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             intent_object_name=intent_object_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectionIntentResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/backupProtectionIntent/{intentObjectName}"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
@@ -452,28 +436,27 @@
         :type intent_object_name: str
         :param parameters: resource backed up item. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionIntentResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         intent_object_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ProtectionIntentResource:
         """Create Intent for Enabling backup of an item. This is a synchronous operation.
 
         :param vault_name: The name of the recovery services vault. Required.
@@ -482,53 +465,48 @@
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param intent_object_name: Intent object name. Required.
         :type intent_object_name: str
         :param parameters: resource backed up item. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionIntentResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         intent_object_name: str,
-        parameters: Union[_models.ProtectionIntentResource, IO],
+        parameters: Union[_models.ProtectionIntentResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.ProtectionIntentResource:
         """Create Intent for Enabling backup of an item. This is a synchronous operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the backup item. Required.
         :type fabric_name: str
         :param intent_object_name: Intent object name. Required.
         :type intent_object_name: str
-        :param parameters: resource backed up item. Is either a ProtectionIntentResource type or a IO
-         type. Required.
+        :param parameters: resource backed up item. Is either a ProtectionIntentResource type or a
+         IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource or IO[bytes]
         :return: ProtectionIntentResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionIntentResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -548,52 +526,47 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ProtectionIntentResource")
 
-        request = build_create_or_update_request(
+        _request = build_create_or_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             intent_object_name=intent_object_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectionIntentResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    create_or_update.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/backupProtectionIntent/{intentObjectName}"
-    }
+        return deserialized  # type: ignore
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, fabric_name: str, intent_object_name: str, **kwargs: Any
     ) -> None:
         """Used to remove intent from an item.
 
@@ -602,15 +575,14 @@
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param fabric_name: Fabric name associated with the intent. Required.
         :type fabric_name: str
         :param intent_object_name: Intent to be deleted. Required.
         :type intent_object_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -621,38 +593,33 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             intent_object_name=intent_object_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    delete.metadata = {
-        "url": "/Subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/backupProtectionIntent/{intentObjectName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policies_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policies_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -39,15 +39,15 @@
 
 def build_get_request(
     vault_name: str, resource_group_name: str, policy_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}",
     )  # pylint: disable=line-too-long
@@ -66,20 +66,26 @@
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(
-    vault_name: str, resource_group_name: str, policy_name: str, subscription_id: str, **kwargs: Any
+    vault_name: str,
+    resource_group_name: str,
+    policy_name: str,
+    subscription_id: str,
+    *,
+    x_ms_authorization_auxiliary: Optional[str] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}",
@@ -93,28 +99,32 @@
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if x_ms_authorization_auxiliary is not None:
+        _headers["x-ms-authorization-auxiliary"] = _SERIALIZER.header(
+            "x_ms_authorization_auxiliary", x_ms_authorization_auxiliary, "str"
+        )
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
     vault_name: str, resource_group_name: str, policy_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}",
     )  # pylint: disable=line-too-long
@@ -166,15 +176,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy information to be fetched. Required.
         :type policy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionPolicyResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -185,56 +194,52 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProtectionPolicyResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProtectionPolicyResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         policy_name: str,
         parameters: _models.ProtectionPolicyResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ProtectionPolicyResource]:
         """Creates or modifies a backup policy. This is an asynchronous operation. Status of the operation
         can be fetched
         using GetPolicyOperationResult API.
@@ -245,30 +250,32 @@
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy to be created. Required.
         :type policy_name: str
         :param parameters: resource backup policy. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionPolicyResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         policy_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ProtectionPolicyResource]:
         """Creates or modifies a backup policy. This is an asynchronous operation. Status of the operation
         can be fetched
         using GetPolicyOperationResult API.
@@ -277,52 +284,52 @@
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy to be created. Required.
         :type policy_name: str
         :param parameters: resource backup policy. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProtectionPolicyResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update(
         self,
         vault_name: str,
         resource_group_name: str,
         policy_name: str,
-        parameters: Union[_models.ProtectionPolicyResource, IO],
+        parameters: Union[_models.ProtectionPolicyResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> Optional[_models.ProtectionPolicyResource]:
         """Creates or modifies a backup policy. This is an asynchronous operation. Status of the operation
         can be fetched
         using GetPolicyOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy to be created. Required.
         :type policy_name: str
-        :param parameters: resource backup policy. Is either a ProtectionPolicyResource type or a IO
-         type. Required.
+        :param parameters: resource backup policy. Is either a ProtectionPolicyResource type or a
+         IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :return: ProtectionPolicyResource or None or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -342,53 +349,49 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ProtectionPolicyResource")
 
-        request = build_create_or_update_request(
+        _request = build_create_or_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("ProtectionPolicyResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}"
-    }
+        return deserialized  # type: ignore
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, policy_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -399,44 +402,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @distributed_trace
     def begin_delete(
         self, vault_name: str, resource_group_name: str, policy_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes specified backup policy from your Recovery Services Vault. This is an asynchronous
         operation. Status of the
@@ -445,22 +443,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param policy_name: Backup policy to be deleted. Required.
         :type policy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -480,27 +470,23 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
             polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return LROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}"
-    }
+        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policy_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policy_operation_statuses_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,21 +36,21 @@
 
 def build_get_request(
     vault_name: str, resource_group_name: str, policy_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}/operationResults/{operationId}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}/operations/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "policyName": _SERIALIZER.url("policy_name", policy_name, "str"),
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
@@ -63,96 +63,94 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ProtectionPolicyOperationResultsOperations:
+class ProtectionPolicyOperationStatusesOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`protection_policy_operation_results` attribute.
+        :attr:`protection_policy_operation_statuses` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def get(
         self, vault_name: str, resource_group_name: str, policy_name: str, operation_id: str, **kwargs: Any
-    ) -> _models.ProtectionPolicyResource:
-        """Provides the result of an operation.
+    ) -> _models.OperationStatus:
+        """Provides the status of the asynchronous operations like backup, restore. The status can be in
+        progress, completed
+        or failed. You can refer to the Operation Status enum for all the possible states of an
+        operation. Some operations
+        create jobs. This method returns the list of jobs associated with operation.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param policy_name: Backup policy name whose operation's result needs to be fetched. Required.
+        :param policy_name: Backup policy name whose operation's status needs to be fetched. Required.
         :type policy_name: str
-        :param operation_id: Operation ID which represents the operation whose result needs to be
+        :param operation_id: Operation ID which represents an operation whose status needs to be
          fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: ProtectionPolicyResource or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ProtectionPolicyResource
+        :return: OperationStatus or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectionPolicyResource] = kwargs.pop("cls", None)
+        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("ProtectionPolicyResource", pipeline_response)
+        deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}/operationResults/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_protection_policy_operation_statuses_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_tiering_cost_operation_status_operations.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -31,86 +31,79 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(
-    vault_name: str, resource_group_name: str, policy_name: str, operation_id: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, vault_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}/operations/{operationId}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/operationsStatus/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "policyName": _SERIALIZER.url("policy_name", policy_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "vaultName": _SERIALIZER.url(
+            "vault_name", vault_name, "str", max_length=50, min_length=2, pattern=r"^[A-Za-z][-A-Za-z0-9]*[A-Za-z0-9]$"
+        ),
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ProtectionPolicyOperationStatusesOperations:
+class TieringCostOperationStatusOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`protection_policy_operation_statuses` attribute.
+        :attr:`tiering_cost_operation_status` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def get(
-        self, vault_name: str, resource_group_name: str, policy_name: str, operation_id: str, **kwargs: Any
+        self, resource_group_name: str, vault_name: str, operation_id: str, **kwargs: Any
     ) -> _models.OperationStatus:
-        """Provides the status of the asynchronous operations like backup, restore. The status can be in
-        progress, completed
-        or failed. You can refer to the Operation Status enum for all the possible states of an
-        operation. Some operations
-        create jobs. This method returns the list of jobs associated with operation.
+        """Gets the status of async operations of tiering cost.
 
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param policy_name: Backup policy name whose operation's status needs to be fetched. Required.
-        :type policy_name: str
-        :param operation_id: Operation ID which represents an operation whose status needs to be
-         fetched. Required.
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
+        :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -121,42 +114,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
-            vault_name=vault_name,
+        _request = build_get_request(
             resource_group_name=resource_group_name,
-            policy_name=policy_name,
+            vault_name=vault_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupPolicies/{policyName}/operations/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_points_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_points_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -46,15 +46,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints",
     )  # pylint: disable=line-too-long
@@ -89,15 +89,15 @@
     recovery_point_id: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}",
     )  # pylint: disable=line-too-long
@@ -163,15 +163,14 @@
         :type fabric_name: str
         :param container_name: Container name associated with the backed up item. Required.
         :type container_name: str
         :param protected_item_name: Backed up item whose backup copies are to be fetched. Required.
         :type protected_item_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RecoveryPointResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -187,76 +186,71 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     fabric_name=fabric_name,
                     container_name=container_name,
                     protected_item_name=protected_item_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RecoveryPointResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints"
-    }
-
     @distributed_trace
     def get(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
@@ -279,15 +273,14 @@
         :type container_name: str
         :param protected_item_name: Backed up item name whose backup data needs to be fetched.
          Required.
         :type protected_item_name: str
         :param recovery_point_id: RecoveryPointID represents the backed up data to be fetched.
          Required.
         :type recovery_point_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RecoveryPointResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -298,44 +291,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.RecoveryPointResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("RecoveryPointResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_points_recommended_for_move_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_recovery_points_recommended_for_move_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -45,15 +45,15 @@
     protected_item_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPointsRecommendedForMove",
@@ -76,15 +76,15 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class RecoveryPointsRecommendedForMoveOperations:
+class RecoveryPointsRecommendedForMoveOperations:  # pylint: disable=name-too-long
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
         :attr:`recovery_points_recommended_for_move` attribute.
@@ -127,15 +127,14 @@
         :type protected_item_name: str
         :param parameters: List Recovery points Recommended for Move Request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ListRecoveryPointsRecommendedForMoveRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RecoveryPointResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
@@ -143,15 +142,15 @@
     def list(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Iterable["_models.RecoveryPointResource"]:
         """Lists the recovery points recommended for move to another tier.
 
         :param vault_name: The name of the recovery services vault. Required.
@@ -162,19 +161,18 @@
         :param fabric_name: Required.
         :type fabric_name: str
         :param container_name: Required.
         :type container_name: str
         :param protected_item_name: Required.
         :type protected_item_name: str
         :param parameters: List Recovery points Recommended for Move Request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RecoveryPointResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
@@ -182,15 +180,15 @@
     def list(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
-        parameters: Union[_models.ListRecoveryPointsRecommendedForMoveRequest, IO],
+        parameters: Union[_models.ListRecoveryPointsRecommendedForMoveRequest, IO[bytes]],
         **kwargs: Any
     ) -> Iterable["_models.RecoveryPointResource"]:
         """Lists the recovery points recommended for move to another tier.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
@@ -199,22 +197,18 @@
         :param fabric_name: Required.
         :type fabric_name: str
         :param container_name: Required.
         :type container_name: str
         :param protected_item_name: Required.
         :type protected_item_name: str
         :param parameters: List Recovery points Recommended for Move Request. Is either a
-         ListRecoveryPointsRecommendedForMoveRequest type or a IO type. Required.
+         ListRecoveryPointsRecommendedForMoveRequest type or a IO[bytes] type. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ListRecoveryPointsRecommendedForMoveRequest
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         or IO[bytes]
         :return: An iterator like instance of either RecoveryPointResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
@@ -238,70 +232,65 @@
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ListRecoveryPointsRecommendedForMoveRequest")
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     fabric_name=fabric_name,
                     container_name=container_name,
                     protected_item_name=protected_item_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
                     content_type=content_type,
                     json=_json,
                     content=_content,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RecoveryPointResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPointsRecommendedForMove"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_resource_guard_proxies_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_resource_guard_proxies_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,15 +36,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies",
     )  # pylint: disable=line-too-long
@@ -91,15 +91,14 @@
         """List the ResourceGuardProxies under vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ResourceGuardProxyBaseResource or the result of
          cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -115,64 +114,59 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_get_request(
+                _request = build_get_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.get.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ResourceGuardProxyBaseResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_resource_guard_proxy_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_resource_guard_proxy_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -37,15 +37,15 @@
 
 def build_get_request(
     vault_name: str, resource_group_name: str, resource_guard_proxy_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}",
     )  # pylint: disable=line-too-long
@@ -69,15 +69,15 @@
 
 def build_put_request(
     vault_name: str, resource_group_name: str, resource_guard_proxy_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}",
@@ -104,15 +104,15 @@
 
 def build_delete_request(
     vault_name: str, resource_group_name: str, resource_guard_proxy_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}",
     )  # pylint: disable=line-too-long
@@ -136,15 +136,15 @@
 
 def build_unlock_delete_request(
     vault_name: str, resource_group_name: str, resource_guard_proxy_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}/unlockDelete",
@@ -197,15 +197,14 @@
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ResourceGuardProxyBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -216,48 +215,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ResourceGuardProxyBaseResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             resource_guard_proxy_name=resource_guard_proxy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ResourceGuardProxyBaseResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def put(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
@@ -278,27 +272,26 @@
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ResourceGuardProxyBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def put(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ResourceGuardProxyBaseResource:
         """Add or Update ResourceGuardProxy under vault
         Secures vault critical operations.
 
@@ -306,51 +299,47 @@
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ResourceGuardProxyBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def put(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
-        parameters: Union[_models.ResourceGuardProxyBaseResource, IO],
+        parameters: Union[_models.ResourceGuardProxyBaseResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.ResourceGuardProxyBaseResource:
         """Add or Update ResourceGuardProxy under vault
         Secures vault critical operations.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Is either a ResourceGuardProxyBaseResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource or
+         IO[bytes]
         :return: ResourceGuardProxyBaseResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ResourceGuardProxyBaseResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -370,66 +359,60 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ResourceGuardProxyBaseResource")
 
-        request = build_put_request(
+        _request = build_put_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             resource_guard_proxy_name=resource_guard_proxy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ResourceGuardProxyBaseResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    put.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}"
-    }
+        return deserialized  # type: ignore
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self, vault_name: str, resource_group_name: str, resource_guard_proxy_name: str, **kwargs: Any
     ) -> None:
         """Delete ResourceGuardProxy under vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -440,44 +423,39 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        _request = build_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             resource_guard_proxy_name=resource_guard_proxy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
     def unlock_delete(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
@@ -496,77 +474,71 @@
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: UnlockDeleteResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def unlock_delete(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.UnlockDeleteResponse:
         """Secures delete ResourceGuardProxy operations.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
         :param parameters: Request body for operation. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: UnlockDeleteResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def unlock_delete(
         self,
         vault_name: str,
         resource_group_name: str,
         resource_guard_proxy_name: str,
-        parameters: Union[_models.UnlockDeleteRequest, IO],
+        parameters: Union[_models.UnlockDeleteRequest, IO[bytes]],
         **kwargs: Any
     ) -> _models.UnlockDeleteResponse:
         """Secures delete ResourceGuardProxy operations.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param resource_guard_proxy_name: Required.
         :type resource_guard_proxy_name: str
-        :param parameters: Request body for operation. Is either a UnlockDeleteRequest type or a IO
-         type. Required.
+        :param parameters: Request body for operation. Is either a UnlockDeleteRequest type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteRequest or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         IO[bytes]
         :return: UnlockDeleteResponse or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.UnlockDeleteResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -586,44 +558,39 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "UnlockDeleteRequest")
 
-        request = build_unlock_delete_request(
+        _request = build_unlock_delete_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             resource_guard_proxy_name=resource_guard_proxy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.unlock_delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("UnlockDeleteResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    unlock_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}/unlockDelete"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_restores_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_restores_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -41,20 +41,22 @@
     vault_name: str,
     resource_group_name: str,
     fabric_name: str,
     container_name: str,
     protected_item_name: str,
     recovery_point_id: str,
     subscription_id: str,
+    *,
+    x_ms_authorization_auxiliary: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/restore",
@@ -71,14 +73,18 @@
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if x_ms_authorization_auxiliary is not None:
+        _headers["x-ms-authorization-auxiliary"] = _SERIALIZER.header(
+            "x_ms_authorization_auxiliary", x_ms_authorization_auxiliary, "str"
+        )
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
@@ -105,15 +111,16 @@
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: Union[_models.RestoreRequestResource, IO],
+        parameters: Union[_models.RestoreRequestResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -131,61 +138,58 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RestoreRequestResource")
 
-        request = build_trigger_request(
+        _request = build_trigger_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._trigger_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _trigger_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/restore"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
     def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
         parameters: _models.RestoreRequestResource,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[None]:
         """Restores the specified backed up data. This is an asynchronous operation. To know the status of
         this API call, use
         GetProtectedItemOperationResult API.
@@ -202,40 +206,35 @@
         :param protected_item_name: Backed up item to be restored. Required.
         :type protected_item_name: str
         :param recovery_point_id: Recovery point ID which represents the backed up data to be restored.
          Required.
         :type recovery_point_id: str
         :param parameters: resource restore request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.RestoreRequestResource
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: IO,
+        parameters: IO[bytes],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[None]:
         """Restores the specified backed up data. This is an asynchronous operation. To know the status of
         this API call, use
         GetProtectedItemOperationResult API.
@@ -251,41 +250,36 @@
         :type container_name: str
         :param protected_item_name: Backed up item to be restored. Required.
         :type protected_item_name: str
         :param recovery_point_id: Recovery point ID which represents the backed up data to be restored.
          Required.
         :type recovery_point_id: str
         :param parameters: resource restore request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: Union[_models.RestoreRequestResource, IO],
+        parameters: Union[_models.RestoreRequestResource, IO[bytes]],
+        x_ms_authorization_auxiliary: Optional[str] = None,
         **kwargs: Any
     ) -> LROPoller[None]:
         """Restores the specified backed up data. This is an asynchronous operation. To know the status of
         this API call, use
         GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
@@ -298,29 +292,20 @@
         :param container_name: Container name associated with the backed up items. Required.
         :type container_name: str
         :param protected_item_name: Backed up item to be restored. Required.
         :type protected_item_name: str
         :param recovery_point_id: Recovery point ID which represents the backed up data to be restored.
          Required.
         :type recovery_point_id: str
-        :param parameters: resource restore request. Is either a RestoreRequestResource type or a IO
-         type. Required.
+        :param parameters: resource restore request. Is either a RestoreRequestResource type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.RestoreRequestResource
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
+         or IO[bytes]
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -335,38 +320,35 @@
                 vault_name=vault_name,
                 resource_group_name=resource_group_name,
                 fabric_name=fabric_name,
                 container_name=container_name,
                 protected_item_name=protected_item_name,
                 recovery_point_id=recovery_point_id,
                 parameters=parameters,
+                x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
             polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return LROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/restore"
-    }
+        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_security_pins_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_security_pins_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -31,19 +31,26 @@
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_get_request(vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_get_request(
+    vault_name: str,
+    resource_group_name: str,
+    subscription_id: str,
+    *,
+    x_ms_authorization_auxiliary: Optional[str] = None,
+    **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupSecurityPIN",
@@ -56,14 +63,18 @@
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if x_ms_authorization_auxiliary is not None:
+        _headers["x-ms-authorization-auxiliary"] = _SERIALIZER.header(
+            "x_ms_authorization_auxiliary", x_ms_authorization_auxiliary, "str"
+        )
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
@@ -87,87 +98,91 @@
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @overload
     def get(
         self,
         vault_name: str,
         resource_group_name: str,
+        x_ms_authorization_auxiliary: Optional[str] = None,
         parameters: Optional[_models.SecurityPinBase] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.TokenInformation:
         """Get the security PIN.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :param parameters: security pin request. Default value is None.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.SecurityPinBase
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: TokenInformation or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TokenInformation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def get(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Optional[IO] = None,
+        x_ms_authorization_auxiliary: Optional[str] = None,
+        parameters: Optional[IO[bytes]] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.TokenInformation:
         """Get the security PIN.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
         :param parameters: security pin request. Default value is None.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: TokenInformation or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TokenInformation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def get(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Optional[Union[_models.SecurityPinBase, IO]] = None,
+        x_ms_authorization_auxiliary: Optional[str] = None,
+        parameters: Optional[Union[_models.SecurityPinBase, IO[bytes]]] = None,
         **kwargs: Any
     ) -> _models.TokenInformation:
         """Get the security PIN.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param parameters: security pin request. Is either a SecurityPinBase type or a IO type. Default
-         value is None.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.SecurityPinBase or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+        :param x_ms_authorization_auxiliary: Default value is None.
+        :type x_ms_authorization_auxiliary: str
+        :param parameters: security pin request. Is either a SecurityPinBase type or a IO[bytes] type.
          Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.SecurityPinBase or
+         IO[bytes]
         :return: TokenInformation or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.TokenInformation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -190,43 +205,39 @@
             _content = parameters
         else:
             if parameters is not None:
                 _json = self._serialize.body(parameters, "SecurityPinBase")
             else:
                 _json = None
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
+            x_ms_authorization_auxiliary=x_ms_authorization_auxiliary,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("TokenInformation", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupSecurityPIN"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_tiering_cost_operation_status_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_results_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -31,125 +31,121 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(
-    resource_group_name: str, vault_name: str, operation_id: str, subscription_id: str, **kwargs: Any
+    vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/operationsStatus/{operationId}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperationResults/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "vaultName": _SERIALIZER.url(
-            "vault_name", vault_name, "str", max_length=50, min_length=2, pattern=r"^[A-Za-z][-A-Za-z0-9]*[A-Za-z0-9]$"
-        ),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class TieringCostOperationStatusOperations:
+class ValidateOperationResultsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`tiering_cost_operation_status` attribute.
+        :attr:`validate_operation_results` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def get(
-        self, resource_group_name: str, vault_name: str, operation_id: str, **kwargs: Any
-    ) -> _models.OperationStatus:
-        """Gets the status of async operations of tiering cost.
+        self, vault_name: str, resource_group_name: str, operation_id: str, **kwargs: Any
+    ) -> Optional[_models.ValidateOperationsResponse]:
+        """Fetches the result of a triggered validate operation.
 
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param vault_name: The name of the recovery services vault. Required.
-        :type vault_name: str
-        :param operation_id: Required.
+        :param operation_id: OperationID which represents the operation whose result needs to be
+         fetched. Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: OperationStatus or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
+        :return: ValidateOperationsResponse or None or the result of cls(response)
+        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationsResponse or
+         None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.ValidateOperationsResponse]] = kwargs.pop("cls", None)
 
-        request = build_get_request(
-            resource_group_name=resource_group_name,
+        _request = build_get_request(
             vault_name=vault_name,
+            resource_group_name=resource_group_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("OperationStatus", pipeline_response)
+        deserialized = None
+        if response.status_code == 200:
+            deserialized = self._deserialize("ValidateOperationsResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTieringCost/default/operationsStatus/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_validate_operation_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -14,91 +14,55 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
-from azure.core.polling import LROPoller, NoPolling, PollingMethod
+from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.arm_polling import ARMPolling
+from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._validate_operation_operations import build_trigger_request
+from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_trigger_request(
-    vault_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTriggerValidateOperation",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ValidateOperationOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
         :attr:`validate_operation` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    def _trigger_initial(  # pylint: disable=inconsistent-return-statements
+    async def _trigger_initial(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.ValidateOperationRequestResource, IO],
+        parameters: Union[_models.ValidateOperationRequestResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -116,193 +80,158 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ValidateOperationRequestResource")
 
-        request = build_trigger_request(
+        _request = build_trigger_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._trigger_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _trigger_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTriggerValidateOperation"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
-    def begin_trigger(
+    async def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.ValidateOperationRequestResource,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Validate operation for specified backed up item in the form of an asynchronous operation.
         Returns tracking headers which can be tracked using GetValidateOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_trigger(
+    async def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Validate operation for specified backed up item in the form of an asynchronous operation.
         Returns tracking headers which can be tracked using GetValidateOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def begin_trigger(
+    @distributed_trace_async
+    async def begin_trigger(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.ValidateOperationRequestResource, IO],
+        parameters: Union[_models.ValidateOperationRequestResource, IO[bytes]],
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Validate operation for specified backed up item in the form of an asynchronous operation.
         Returns tracking headers which can be tracked using GetValidateOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: resource validate operation request. Is either a
-         ValidateOperationRequestResource type or a IO type. Required.
+         ValidateOperationRequestResource type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationRequestResource or
+         IO[bytes]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._trigger_initial(  # type: ignore
+            raw_result = await self._trigger_initial(  # type: ignore
                 vault_name=vault_name,
                 resource_group_name=resource_group_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return AsyncLROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupTriggerValidateOperation"
-    }
+        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_protectable_items_operations.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,157 +1,154 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, Callable, Dict, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._backup_protectable_items_operations import build_list_request
+from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
 
-
-def build_get_request(
-    vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperationResults/{operationId}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-class ValidateOperationResultsOperations:
+class BackupProtectableItemsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`validate_operation_results` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
+        :attr:`backup_protectable_items` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def get(
-        self, vault_name: str, resource_group_name: str, operation_id: str, **kwargs: Any
-    ) -> Optional[_models.ValidateOperationsResponse]:
-        """Fetches the result of a triggered validate operation.
+    def list(
+        self,
+        vault_name: str,
+        resource_group_name: str,
+        filter: Optional[str] = None,
+        skip_token: Optional[str] = None,
+        **kwargs: Any
+    ) -> AsyncIterable["_models.WorkloadProtectableItemResource"]:
+        """Provides a pageable list of protectable objects within your subscription according to the query
+        filter and the
+        pagination parameters.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param operation_id: OperationID which represents the operation whose result needs to be
-         fetched. Required.
-        :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: ValidateOperationsResponse or None or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ValidateOperationsResponse or
-         None
+        :param filter: OData filter options. Default value is None.
+        :type filter: str
+        :param skip_token: skipToken Filter. Default value is None.
+        :type skip_token: str
+        :return: An iterator like instance of either WorkloadProtectableItemResource or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.WorkloadProtectableItemResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.WorkloadProtectableItemResourceList] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[Optional[_models.ValidateOperationsResponse]] = kwargs.pop("cls", None)
+                _request = build_list_request(
+                    vault_name=vault_name,
+                    resource_group_name=resource_group_name,
+                    subscription_id=self._config.subscription_id,
+                    filter=filter,
+                    skip_token=skip_token,
+                    api_version=api_version,
+                    headers=_headers,
+                    params=_params,
+                )
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                _request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("WorkloadProtectableItemResourceList", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            _request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                _request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+            return pipeline_response
 
-        request = build_get_request(
-            vault_name=vault_name,
-            resource_group_name=resource_group_name,
-            operation_id=operation_id,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = None
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateOperationsResponse", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperationResults/{operationId}"
-    }
+        return AsyncItemPaged(get_next, extract_data)
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/activestamp/operations/_validate_operation_statuses_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_protected_items_crr_operations.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,158 +1,152 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, Callable, Dict, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import RecoveryServicesBackupClientMixinABC, _convert_request
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._backup_protected_items_crr_operations import build_list_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
 
-
-def build_get_request(
-    vault_name: str, resource_group_name: str, operation_id: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperationsStatuses/{operationId}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-class ValidateOperationStatusesOperations:
+class BackupProtectedItemsCrrOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.RecoveryServicesBackupClient`'s
-        :attr:`validate_operation_statuses` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.aio.RecoveryServicesBackupPassiveClient`'s
+        :attr:`backup_protected_items_crr` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def get(
-        self, vault_name: str, resource_group_name: str, operation_id: str, **kwargs: Any
-    ) -> _models.OperationStatus:
-        """Fetches the status of a triggered validate operation. The status can be in progress, completed
-        or failed. You can refer to the OperationStatus enum for all the possible states of the
-        operation.
-        If operation has completed, this method returns the list of errors obtained while validating
-        the operation.
+    def list(
+        self,
+        vault_name: str,
+        resource_group_name: str,
+        filter: Optional[str] = None,
+        skip_token: Optional[str] = None,
+        **kwargs: Any
+    ) -> AsyncIterable["_models.ProtectedItemResource"]:
+        """Provides a pageable list of all items that are backed up within a vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param operation_id: OperationID represents the operation whose status needs to be fetched.
-         Required.
-        :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: OperationStatus or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.activestamp.models.OperationStatus
+        :param filter: OData filter options. Default value is None.
+        :type filter: str
+        :param skip_token: skipToken Filter. Default value is None.
+        :type skip_token: str
+        :return: An iterator like instance of either ProtectedItemResource or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.ProtectedItemResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ProtectedItemResourceList] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
+                _request = build_list_request(
+                    vault_name=vault_name,
+                    resource_group_name=resource_group_name,
+                    subscription_id=self._config.subscription_id,
+                    filter=filter,
+                    skip_token=skip_token,
+                    api_version=api_version,
+                    headers=_headers,
+                    params=_params,
+                )
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                _request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("ProtectedItemResourceList", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            _request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                _request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+            return pipeline_response
 
-        request = build_get_request(
-            vault_name=vault_name,
-            resource_group_name=resource_group_name,
-            operation_id=operation_id,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("OperationStatus", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupValidateOperationsStatuses/{operationId}"
-    }
+        return AsyncItemPaged(get_next, extract_data)
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_configuration.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,63 +4,62 @@
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, TYPE_CHECKING
 
-from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
-class RecoveryServicesBackupPassiveClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
+class RecoveryServicesBackupPassiveClientConfiguration:  # pylint: disable=too-many-instance-attributes,name-too-long
     """Configuration for RecoveryServicesBackupPassiveClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The subscription Id. Required.
     :type subscription_id: str
     :keyword api_version: Api Version. Default value is "2021-11-15". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
-        super(RecoveryServicesBackupPassiveClientConfiguration, self).__init__(**kwargs)
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         api_version: str = kwargs.pop("api_version", "2021-11-15")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
         self.subscription_id = subscription_id
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-recoveryservicesbackup/{}".format(VERSION))
+        self.polling_interval = kwargs.get("polling_interval", 30)
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_recovery_services_backup_passive_client.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_recovery_services_backup_passive_client.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,16 +5,18 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
 from typing import Any, TYPE_CHECKING
 
+from azure.core.pipeline import policies
 from azure.core.rest import HttpRequest, HttpResponse
 from azure.mgmt.core import ARMPipelineClient
+from azure.mgmt.core.policies import ARMAutoResourceProviderRegistrationPolicy
 
 from . import models as _models
 from ._configuration import RecoveryServicesBackupPassiveClientConfiguration
 from ._serialization import Deserializer, Serializer
 from .operations import (
     AadPropertiesOperations,
     BackupCrrJobDetailsOperations,
@@ -89,15 +91,33 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = RecoveryServicesBackupPassiveClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        _policies = kwargs.pop("policies", None)
+        if _policies is None:
+            _policies = [
+                policies.RequestIdPolicy(**kwargs),
+                self._config.headers_policy,
+                self._config.user_agent_policy,
+                self._config.proxy_policy,
+                policies.ContentDecodePolicy(**kwargs),
+                ARMAutoResourceProviderRegistrationPolicy(),
+                self._config.redirect_policy,
+                self._config.retry_policy,
+                self._config.authentication_policy,
+                self._config.custom_hook_policy,
+                self._config.logging_policy,
+                policies.DistributedTracingPolicy(**kwargs),
+                policies.SensitiveHeaderCleanupPolicy(**kwargs) if self._config.redirect_policy else None,
+                self._config.http_logging_policy,
+            ]
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, policies=_policies, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.backup_usage_summaries_crr = BackupUsageSummariesCRROperations(
             self._client, self._config, self._serialize, self._deserialize
@@ -123,15 +143,15 @@
         self.recovery_points_crr = RecoveryPointsCrrOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.backup_protected_items_crr = BackupProtectedItemsCrrOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
 
-    def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
+    def _send_request(self, request: HttpRequest, *, stream: bool = False, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
         >>> response = client._send_request(request)
         <HttpResponse: 200 OK>
@@ -143,15 +163,15 @@
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
-        return self._client.send_request(request_copy, **kwargs)
+        return self._client.send_request(request_copy, stream=stream, **kwargs)  # type: ignore
 
     def close(self) -> None:
         self._client.close()
 
     def __enter__(self) -> "RecoveryServicesBackupPassiveClient":
         self._client.__enter__()
         return self
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_serialization.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -59,16 +59,16 @@
     from urllib import quote  # type: ignore
 except ImportError:
     from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
 import isodate  # type: ignore
 
-from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
-from azure.core.serialization import NULL as AzureCoreNull
+from azure.core.exceptions import DeserializationError, SerializationError
+from azure.core.serialization import NULL as CoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
 ModelType = TypeVar("ModelType", bound="Model")
 JSON = MutableMapping[str, Any]
 
 
@@ -120,15 +120,15 @@
                     if isinstance(data, unicode):  # type: ignore
                         # If I'm Python 2.7 and unicode XML will scream if I try a "fromstring" on unicode string
                         data_as_str = data_as_str.encode(encoding="utf-8")  # type: ignore
                 except NameError:
                     pass
 
                 return ET.fromstring(data_as_str)  # nosec
-            except ET.ParseError:
+            except ET.ParseError as err:
                 # It might be because the server has an issue, and returned JSON with
                 # content-type XML....
                 # So let's try a JSON load, and if it's still broken
                 # let's flow the initial exception
                 def _json_attemp(data):
                     try:
                         return True, json.loads(data)
@@ -139,15 +139,15 @@
                 if success:
                     return json_result
                 # If i'm here, it's not JSON, it's not XML, let's scream
                 # and raise the last context in this block (the XML exception)
                 # The function hack is because Py2.7 messes up with exception
                 # context otherwise.
                 _LOGGER.critical("Wasn't XML not JSON, failing")
-                raise_with_traceback(DeserializationError, "XML is invalid")
+                raise DeserializationError("XML is invalid") from err
         raise DeserializationError("Cannot deserialize content-type: {}".format(content_type))
 
     @classmethod
     def deserialize_from_http_generics(cls, body_bytes: Optional[Union[AnyStr, IO]], headers: Mapping) -> Any:
         """Deserialize from HTTP response.
 
         Use bytes and headers to NOT use any requests/aiohttp or whatever
@@ -166,21 +166,14 @@
             content_type = "application/json"
 
         if body_bytes:
             return cls.deserialize_from_text(body_bytes, content_type)
         return None
 
 
-try:
-    basestring  # type: ignore
-    unicode_str = unicode  # type: ignore
-except NameError:
-    basestring = str
-    unicode_str = str
-
 _LOGGER = logging.getLogger(__name__)
 
 try:
     _long_type = long  # type: ignore
 except NameError:
     _long_type = int
 
@@ -291,15 +284,15 @@
     """
 
     _subtype_map: Dict[str, Dict[str, Any]] = {}
     _attribute_map: Dict[str, Dict[str, Any]] = {}
     _validation: Dict[str, Dict[str, Any]] = {}
 
     def __init__(self, **kwargs: Any) -> None:
-        self.additional_properties: Dict[str, Any] = {}
+        self.additional_properties: Optional[Dict[str, Any]] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
@@ -336,26 +329,26 @@
             xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
     def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
-        """Return the JSON that would be sent to azure from this model.
+        """Return the JSON that would be sent to server from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
-        return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
+        return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)  # type: ignore
 
     def as_dict(
         self,
         keep_readonly: bool = True,
         key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
         **kwargs: Any
     ) -> JSON:
@@ -386,15 +379,15 @@
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param function key_transformer: A key transformer function.
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
-        return serializer._serialize(self, key_transformer=key_transformer, keep_readonly=keep_readonly, **kwargs)
+        return serializer._serialize(self, key_transformer=key_transformer, keep_readonly=keep_readonly, **kwargs)  # type: ignore
 
     @classmethod
     def _infer_class_models(cls):
         try:
             str_models = cls.__module__.rsplit(".", 1)[0]
             models = sys.modules[str_models]
             client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
@@ -411,15 +404,15 @@
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        return deserializer(cls.__name__, data, content_type=content_type)
+        return deserializer(cls.__name__, data, content_type=content_type)  # type: ignore
 
     @classmethod
     def from_dict(
         cls: Type[ModelType],
         data: Any,
         key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
         content_type: Optional[str] = None,
@@ -441,15 +434,15 @@
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
-        return deserializer(cls.__name__, data, content_type=content_type)
+        return deserializer(cls.__name__, data, content_type=content_type)  # type: ignore
 
     @classmethod
     def _flatten_subtype(cls, key, objects):
         if "_subtype_map" not in cls.__dict__:
             return {}
         result = dict(cls._subtype_map[key])
         for valuetype in cls._subtype_map[key].values():
@@ -541,15 +534,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes: Optional[Mapping[str, type]] = None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -557,15 +550,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies: Dict[str, type] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -645,15 +638,15 @@
                                     new_attr.tag = "}".join([splitted_tag[0], xml_name])
                                 else:
                                     new_attr.tag = xml_name
                             serialized.append(new_attr)  # type: ignore
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
-                            local_node.text = unicode_str(new_attr)
+                            local_node.text = str(new_attr)
                             serialized.append(local_node)  # type: ignore
                     else:  # JSON
                         for k in reversed(keys):  # type: ignore
                             new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
@@ -664,15 +657,15 @@
                             _serialized = _serialized[k]
                 except ValueError as err:
                     if isinstance(err, SerializationError):
                         raise
 
         except (AttributeError, KeyError, TypeError) as err:
             msg = "Attribute {} in object {} cannot be serialized.\n{}".format(attr_name, class_name, str(target_obj))
-            raise_with_traceback(SerializationError, msg, err)
+            raise SerializationError(msg) from err
         else:
             return serialized
 
     def body(self, data, data_type, **kwargs):
         """Serialize data intended for a request body.
 
         :param data: The data to be serialized.
@@ -706,15 +699,15 @@
                     deserializer.key_extractors = [
                         rest_key_case_insensitive_extractor,
                         attribute_key_case_insensitive_extractor,
                         last_rest_key_case_insensitive_extractor,
                     ]
                 data = deserializer._deserialize(data_type, data)
             except DeserializationError as err:
-                raise_with_traceback(SerializationError, "Unable to build a model: " + str(err), err)
+                raise SerializationError("Unable to build a model: " + str(err)) from err
 
         return self._serialize(data, data_type, **kwargs)
 
     def url(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL path.
 
         :param data: The data to be serialized.
@@ -726,38 +719,39 @@
         try:
             output = self.serialize_data(data, data_type, **kwargs)
             if data_type == "bool":
                 output = json.dumps(output)
 
             if kwargs.get("skip_quote") is True:
                 output = str(output)
+                output = output.replace("{", quote("{")).replace("}", quote("}"))
             else:
                 output = quote(str(output), safe="")
         except SerializationError:
             raise TypeError("{} must be type {}.".format(name, data_type))
         else:
             return output
 
     def query(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL query.
 
         :param data: The data to be serialized.
         :param str data_type: The type to be serialized from.
         :keyword bool skip_quote: Whether to skip quote the serialized result.
         Defaults to False.
-        :rtype: str
+        :rtype: str, list
         :raises: TypeError if serialization fails.
         :raises: ValueError if data is None
         """
         try:
             # Treat the list aside, since we don't want to encode the div separator
             if data_type.startswith("["):
                 internal_data_type = data_type[1:-1]
                 do_quote = not kwargs.get("skip_quote", False)
-                return str(self.serialize_iter(data, internal_data_type, do_quote=do_quote, **kwargs))
+                return self.serialize_iter(data, internal_data_type, do_quote=do_quote, **kwargs)
 
             # Not a list, regular serialization
             output = self.serialize_data(data, data_type, **kwargs)
             if data_type == "bool":
                 output = json.dumps(output)
             if kwargs.get("skip_quote") is True:
                 output = str(output)
@@ -800,15 +794,15 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
-            if data is AzureCoreNull:
+            if data is CoreNull:
                 return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
@@ -820,15 +814,15 @@
 
             iter_type = data_type[0] + data_type[-1]
             if iter_type in self.serialize_type:
                 return self.serialize_type[iter_type](data, data_type[1:-1], **kwargs)
 
         except (ValueError, TypeError) as err:
             msg = "Unable to serialize value: {!r} as type: {!r}."
-            raise_with_traceback(SerializationError, msg.format(data, data_type), err)
+            raise SerializationError(msg.format(data, data_type)) from err
         else:
             return self._serialize(data, **kwargs)
 
     @classmethod
     def _get_custom_serializers(cls, data_type, **kwargs):
         custom_serializer = kwargs.get("basic_types_serializers", {}).get(data_type)
         if custom_serializer:
@@ -989,15 +983,15 @@
         if isinstance(attr, ET.Element):
             return attr
         obj_type = type(attr)
         if obj_type in self.basic_types:
             return self.serialize_basic(attr, self.basic_types[obj_type], **kwargs)
         if obj_type is _long_type:
             return self.serialize_long(attr)
-        if obj_type is unicode_str:
+        if obj_type is str:
             return self.serialize_unicode(attr)
         if obj_type is datetime.datetime:
             return self.serialize_iso(attr)
         if obj_type is datetime.date:
             return self.serialize_date(attr)
         if obj_type is datetime.time:
             return self.serialize_time(attr)
@@ -1166,18 +1160,18 @@
                 microseconds = "." + microseconds
             date = "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}".format(
                 utc.tm_year, utc.tm_mon, utc.tm_mday, utc.tm_hour, utc.tm_min, utc.tm_sec
             )
             return date + microseconds + "Z"
         except (ValueError, OverflowError) as err:
             msg = "Unable to serialize datetime object."
-            raise_with_traceback(SerializationError, msg, err)
+            raise SerializationError(msg) from err
         except AttributeError as err:
             msg = "ISO-8601 object must be valid Datetime object."
-            raise_with_traceback(TypeError, msg, err)
+            raise TypeError(msg) from err
 
     @staticmethod
     def serialize_unix(attr, **kwargs):
         """Serialize Datetime object into IntTime format.
         This is represented as seconds.
 
         :param Datetime attr: Object to be serialized.
@@ -1205,15 +1199,14 @@
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
-            # https://github.com/Azure/msrest-for-python/issues/197
             return None
         key = ".".join(dict_keys[1:])
 
     return working_data.get(key)
 
 
 def rest_key_case_insensitive_extractor(attr, attr_desc, data):
@@ -1226,15 +1219,14 @@
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = attribute_key_case_insensitive_extractor(working_key, None, working_data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
-            # https://github.com/Azure/msrest-for-python/issues/197
             return None
         key = ".".join(dict_keys[1:])
 
     if working_data:
         return attribute_key_case_insensitive_extractor(key, None, working_data)
 
 
@@ -1367,15 +1359,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes: Optional[Mapping[str, type]] = None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1387,15 +1379,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies: Dict[str, type] = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1440,15 +1432,15 @@
                     setattr(data, attr, self._deserialize(local_type, value))
                 return data
             except AttributeError:
                 return
 
         response, class_name = self._classify_target(target_obj, data)
 
-        if isinstance(response, basestring):
+        if isinstance(response, str):
             return self.deserialize_data(data, response)
         elif isinstance(response, type) and issubclass(response, Enum):
             return self.deserialize_enum(data, response)
 
         if data is None:
             return data
         try:
@@ -1477,15 +1469,15 @@
                             continue
                         raw_value = found_value
 
                 value = self.deserialize_data(raw_value, attr_desc["type"])
                 d_attrs[attr] = value
         except (AttributeError, TypeError, KeyError) as err:
             msg = "Unable to deserialize to object: " + class_name  # type: ignore
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             additional_properties = self._build_additional_properties(attributes, data)
             return self._instantiate_model(response, d_attrs, additional_properties)
 
     def _build_additional_properties(self, attribute_map, data):
         if not self.additional_properties_detection:
             return None
@@ -1511,22 +1503,22 @@
 
         :param str target: The target object type to deserialize to.
         :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
-        if isinstance(target, basestring):
+        if isinstance(target, str):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
-            target = target._classify(data, self.dependencies)
+            target = target._classify(data, self.dependencies)  # type: ignore
         except AttributeError:
             pass  # Target is not a Model, no classify
         return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
@@ -1574,15 +1566,15 @@
         if hasattr(raw_data, "body"):
             return RawDeserializer.deserialize_from_http_generics(raw_data.text(), raw_data.headers)
 
         # Assume this enough to recognize requests.Response without importing it.
         if hasattr(raw_data, "_content_consumed"):
             return RawDeserializer.deserialize_from_http_generics(raw_data.text, raw_data.headers)
 
-        if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, "read"):
+        if isinstance(raw_data, (str, bytes)) or hasattr(raw_data, "read"):
             return RawDeserializer.deserialize_from_text(raw_data, content_type)  # type: ignore
         return raw_data
 
     def _instantiate_model(self, response, attrs, additional_properties=None):
         """Instantiate a response model passing in deserialized args.
 
         :param response: The response model class.
@@ -1648,15 +1640,15 @@
                 if isinstance(data, ET.Element):
                     data = data.text
                 return self.deserialize_enum(data, obj_type)
 
         except (ValueError, TypeError, AttributeError) as err:
             msg = "Unable to deserialize response data."
             msg += " Data: {}, {}".format(data, data_type)
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return self._deserialize(obj_type, data)
 
     def deserialize_iter(self, attr, iter_type):
         """Deserialize an iterable.
 
         :param list attr: Iterable to be deserialized.
@@ -1696,15 +1688,15 @@
         :raises: TypeError if non-builtin datatype encountered.
         """
         if attr is None:
             return None
         if isinstance(attr, ET.Element):
             # Do no recurse on XML, just return the tree as-is
             return attr
-        if isinstance(attr, basestring):
+        if isinstance(attr, str):
             return self.deserialize_basic(attr, "str")
         obj_type = type(attr)
         if obj_type in self.basic_types:
             return self.deserialize_basic(attr, self.basic_types[obj_type])
         if obj_type is _long_type:
             return self.deserialize_long(attr)
 
@@ -1753,15 +1745,15 @@
                     # None or '', node <a/> with a strong type is None.
                     # Don't try to model "empty bool" or "empty int"
                     return None
 
         if data_type == "bool":
             if attr in [True, False, 1, 0]:
                 return bool(attr)
-            elif isinstance(attr, basestring):
+            elif isinstance(attr, str):
                 if attr.lower() in ["true", "1"]:
                     return True
                 elif attr.lower() in ["false", "0"]:
                     return False
             raise TypeError("Invalid boolean value: {}".format(attr))
 
         if data_type == "str":
@@ -1804,15 +1796,14 @@
         """
         if isinstance(data, enum_obj) or data is None:
             return data
         if isinstance(data, Enum):
             data = data.value
         if isinstance(data, int):
             # Workaround. We might consider remove it in the future.
-            # https://github.com/Azure/azure-rest-api-specs/issues/141
             try:
                 return list(enum_obj.__members__.values())[data]
             except IndexError:
                 error = "{!r} is not a valid index for enum {!r}"
                 raise DeserializationError(error.format(data, enum_obj))
         try:
             return enum_obj(str(data))
@@ -1858,18 +1849,18 @@
         :param str attr: response string to be deserialized.
         :rtype: Decimal
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            return decimal.Decimal(attr)  # type: ignore
+            return decimal.Decimal(str(attr))  # type: ignore
         except decimal.DecimalException as err:
             msg = "Invalid decimal {}".format(attr)
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
 
     @staticmethod
     def deserialize_long(attr):
         """Deserialize string into long (Py2) or int (Py3).
 
         :param str attr: response string to be deserialized.
         :rtype: long or int
@@ -1889,15 +1880,15 @@
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
             duration = isodate.parse_duration(attr)
         except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize duration object."
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return duration
 
     @staticmethod
     def deserialize_date(attr):
         """Deserialize ISO-8601 formatted string into Date object.
 
@@ -1906,15 +1897,15 @@
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         # This must NOT use defaultmonth/defaultday. Using None ensure this raises an exception.
-        return isodate.parse_date(attr, defaultmonth=None, defaultday=None)
+        return isodate.parse_date(attr, defaultmonth=0, defaultday=0)
 
     @staticmethod
     def deserialize_time(attr):
         """Deserialize ISO-8601 formatted string into time object.
 
         :param str attr: response string to be deserialized.
         :rtype: datetime.time
@@ -1941,15 +1932,15 @@
             date_obj = datetime.datetime(
                 *parsed_date[:6], tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0) / 60))
             )
             if not date_obj.tzinfo:
                 date_obj = date_obj.astimezone(tz=TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to rfc datetime object."
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return date_obj
 
     @staticmethod
     def deserialize_iso(attr):
         """Deserialize ISO-8601 formatted string into Datetime object.
 
@@ -1978,15 +1969,15 @@
 
             date_obj = isodate.parse_datetime(attr)
             test_utc = date_obj.utctimetuple()
             if test_utc.tm_year > 9999 or test_utc.tm_year < 1:
                 raise OverflowError("Hit max or min date")
         except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize datetime object."
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return date_obj
 
     @staticmethod
     def deserialize_unix(attr):
         """Serialize Datetime object into IntTime format.
         This is represented as seconds.
@@ -1994,13 +1985,14 @@
         :param int attr: Object to be serialized.
         :rtype: Datetime
         :raises: DeserializationError if format invalid
         """
         if isinstance(attr, ET.Element):
             attr = int(attr.text)  # type: ignore
         try:
+            attr = int(attr)
             date_obj = datetime.datetime.fromtimestamp(attr, TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to unix datetime object."
-            raise_with_traceback(DeserializationError, msg, err)
+            raise DeserializationError(msg) from err
         else:
             return date_obj
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/_vendor.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_vendor.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_configuration.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/_configuration.py`

 * *Files 14% similar despite different names*

```diff
@@ -4,63 +4,62 @@
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, TYPE_CHECKING
 
-from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
-class RecoveryServicesBackupPassiveClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
+class RecoveryServicesBackupPassiveClientConfiguration:  # pylint: disable=too-many-instance-attributes,name-too-long
     """Configuration for RecoveryServicesBackupPassiveClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The subscription Id. Required.
     :type subscription_id: str
     :keyword api_version: Api Version. Default value is "2021-11-15". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
-        super(RecoveryServicesBackupPassiveClientConfiguration, self).__init__(**kwargs)
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         api_version: str = kwargs.pop("api_version", "2021-11-15")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
         self.subscription_id = subscription_id
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-recoveryservicesbackup/{}".format(VERSION))
+        self.polling_interval = kwargs.get("polling_interval", 30)
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_recovery_services_backup_passive_client.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/_recovery_services_backup_passive_client.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,16 +5,18 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
 from typing import Any, Awaitable, TYPE_CHECKING
 
+from azure.core.pipeline import policies
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 from azure.mgmt.core import AsyncARMPipelineClient
+from azure.mgmt.core.policies import AsyncARMAutoResourceProviderRegistrationPolicy
 
 from .. import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import RecoveryServicesBackupPassiveClientConfiguration
 from .operations import (
     AadPropertiesOperations,
     BackupCrrJobDetailsOperations,
@@ -89,15 +91,33 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = RecoveryServicesBackupPassiveClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        _policies = kwargs.pop("policies", None)
+        if _policies is None:
+            _policies = [
+                policies.RequestIdPolicy(**kwargs),
+                self._config.headers_policy,
+                self._config.user_agent_policy,
+                self._config.proxy_policy,
+                policies.ContentDecodePolicy(**kwargs),
+                AsyncARMAutoResourceProviderRegistrationPolicy(),
+                self._config.redirect_policy,
+                self._config.retry_policy,
+                self._config.authentication_policy,
+                self._config.custom_hook_policy,
+                self._config.logging_policy,
+                policies.DistributedTracingPolicy(**kwargs),
+                policies.SensitiveHeaderCleanupPolicy(**kwargs) if self._config.redirect_policy else None,
+                self._config.http_logging_policy,
+            ]
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, policies=_policies, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.backup_usage_summaries_crr = BackupUsageSummariesCRROperations(
             self._client, self._config, self._serialize, self._deserialize
@@ -123,15 +143,17 @@
         self.recovery_points_crr = RecoveryPointsCrrOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.backup_protected_items_crr = BackupProtectedItemsCrrOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
 
-    def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
+    def _send_request(
+        self, request: HttpRequest, *, stream: bool = False, **kwargs: Any
+    ) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
         >>> response = await client._send_request(request)
         <AsyncHttpResponse: 200 OK>
@@ -143,15 +165,15 @@
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
         :rtype: ~azure.core.rest.AsyncHttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
-        return self._client.send_request(request_copy, **kwargs)
+        return self._client.send_request(request_copy, stream=stream, **kwargs)  # type: ignore
 
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "RecoveryServicesBackupPassiveClient":
         await self._client.__aenter__()
         return self
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_aad_properties_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_aad_properties_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -58,15 +58,14 @@
 
         Fetches the AAD properties from target region BCM stamp.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AADPropertiesResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.AADPropertiesResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -77,41 +76,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AADPropertiesResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             filter=filter,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AADPropertiesResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupAadProperties"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_crr_job_details_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_crr_job_details_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -14,49 +14,83 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._backup_crr_job_details_operations import build_get_request
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_get_request(azure_region: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-11-15"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrJob",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "azureRegion": _SERIALIZER.url("azure_region", azure_region, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class BackupCrrJobDetailsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.aio.RecoveryServicesBackupPassiveClient`'s
+        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.RecoveryServicesBackupPassiveClient`'s
         :attr:`backup_crr_job_details` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @overload
-    async def get(
+    def get(
         self,
         azure_region: str,
         parameters: _models.CrrJobRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.JobResource:
@@ -67,57 +101,53 @@
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: CRR Job request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def get(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
+    def get(
+        self, azure_region: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.JobResource:
         """Get CRR job details from target region.
 
         Get CRR job details from target region.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: CRR Job request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def get(
-        self, azure_region: str, parameters: Union[_models.CrrJobRequest, IO], **kwargs: Any
+    @distributed_trace
+    def get(
+        self, azure_region: str, parameters: Union[_models.CrrJobRequest, IO[bytes]], **kwargs: Any
     ) -> _models.JobResource:
         """Get CRR job details from target region.
 
         Get CRR job details from target region.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
-        :param parameters: CRR Job request. Is either a CrrJobRequest type or a IO type. Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+        :param parameters: CRR Job request. Is either a CrrJobRequest type or a IO[bytes] type.
+         Required.
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest or
+         IO[bytes]
         :return: JobResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -137,43 +167,38 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "CrrJobRequest")
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrJob"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_crr_jobs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_crr_jobs_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -75,80 +75,75 @@
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def list(
         self,
         azure_region: str,
-        parameters: IO,
+        parameters: IO[bytes],
         filter: Optional[str] = None,
         skip_token: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncIterable["_models.JobResource"]:
         """Gets the list of CRR jobs from the target region.
 
         Gets the list of CRR jobs from the target region.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Backup CRR Job request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def list(
         self,
         azure_region: str,
-        parameters: Union[_models.CrrJobRequest, IO],
+        parameters: Union[_models.CrrJobRequest, IO[bytes]],
         filter: Optional[str] = None,
         skip_token: Optional[str] = None,
         **kwargs: Any
     ) -> AsyncIterable["_models.JobResource"]:
         """Gets the list of CRR jobs from the target region.
 
         Gets the list of CRR jobs from the target region.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
-        :param parameters: Backup CRR Job request. Is either a CrrJobRequest type or a IO type.
+        :param parameters: Backup CRR Job request. Is either a CrrJobRequest type or a IO[bytes] type.
          Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest or IO
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest or
+         IO[bytes]
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -171,69 +166,64 @@
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "CrrJobRequest")
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     azure_region=azure_region,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
                     content_type=content_type,
                     json=_json,
                     content=_content,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("JobResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrJobs"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_protected_items_crr_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_usage_summaries_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -23,28 +23,29 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._backup_protected_items_crr_operations import build_list_request
+from ...operations._backup_usage_summaries_operations import build_list_request
+from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class BackupProtectedItemsCrrOperations:
+class BackupUsageSummariesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.aio.RecoveryServicesBackupPassiveClient`'s
-        :attr:`backup_protected_items_crr` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
+        :attr:`backup_usage_summaries` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -56,103 +57,96 @@
     def list(
         self,
         vault_name: str,
         resource_group_name: str,
         filter: Optional[str] = None,
         skip_token: Optional[str] = None,
         **kwargs: Any
-    ) -> AsyncIterable["_models.ProtectedItemResource"]:
-        """Provides a pageable list of all items that are backed up within a vault.
+    ) -> AsyncIterable["_models.BackupManagementUsage"]:
+        """Fetches the backup management usage summaries of the vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ProtectedItemResource or the result of
+        :return: An iterator like instance of either BackupManagementUsage or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.ProtectedItemResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.activestamp.models.BackupManagementUsage]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProtectedItemResourceList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.BackupManagementUsageList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProtectedItemResourceList", pipeline_response)
+            deserialized = self._deserialize("BackupManagementUsageList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupProtectedItems/"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_resource_storage_configs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_resource_storage_configs_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -62,15 +62,14 @@
         """Fetches resource storage config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -81,48 +80,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupResourceConfigResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def update(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceConfigResource,
@@ -139,71 +133,66 @@
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceConfigResource:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceConfigResource, IO],
+        parameters: Union[_models.BackupResourceConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.BackupResourceConfigResource:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Is either a BackupResourceConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource or
+         IO[bytes]
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -223,51 +212,46 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceConfigResource")
 
-        request = build_update_request(
+        _request = build_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     async def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceConfigResource,
@@ -284,71 +268,66 @@
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> None:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceConfigResource, IO],
+        parameters: Union[_models.BackupResourceConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Is either a BackupResourceConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource or
+         IO[bytes]
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -368,40 +347,35 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceConfigResource")
 
-        request = build_patch_request(
+        _request = build_patch_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    patch.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_usage_summaries_crr_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_usage_summaries_crr_operations.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,86 +1,129 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._backup_usage_summaries_crr_operations import build_list_request
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_request(
+    vault_name: str,
+    resource_group_name: str,
+    subscription_id: str,
+    *,
+    filter: Optional[str] = None,
+    skip_token: Optional[str] = None,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-11-15"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupUsageSummaries",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
+        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
+    if skip_token is not None:
+        _params["$skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class BackupUsageSummariesCRROperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.aio.RecoveryServicesBackupPassiveClient`'s
+        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.RecoveryServicesBackupPassiveClient`'s
         :attr:`backup_usage_summaries_crr` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(
         self,
         vault_name: str,
         resource_group_name: str,
         filter: Optional[str] = None,
         skip_token: Optional[str] = None,
         **kwargs: Any
-    ) -> AsyncIterable["_models.BackupManagementUsage"]:
+    ) -> Iterable["_models.BackupManagementUsage"]:
         """Fetches the backup management usage summaries of the vault.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either BackupManagementUsage or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupManagementUsage]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupManagementUsage]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupManagementUsageList] = kwargs.pop("cls", None)
@@ -92,67 +135,62 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
-        async def extract_data(pipeline_response):
+        def extract_data(pipeline_response):
             deserialized = self._deserialize("BackupManagementUsageList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return None, AsyncList(list_of_elem)
+            return None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
+        def get_next(next_link=None):
+            _request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupUsageSummaries"
-    }
+        return ItemPaged(get_next, extract_data)
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_cross_region_restore_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_fetch_tiering_cost_operations.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -24,235 +24,236 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._cross_region_restore_operations import build_trigger_request
+from ...operations._fetch_tiering_cost_operations import build_post_request
+from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class CrossRegionRestoreOperations:
+class FetchTieringCostOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.aio.RecoveryServicesBackupPassiveClient`'s
-        :attr:`cross_region_restore` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
+        :attr:`fetch_tiering_cost` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _trigger_initial(  # pylint: disable=inconsistent-return-statements
-        self, azure_region: str, parameters: Union[_models.CrossRegionRestoreRequest, IO], **kwargs: Any
-    ) -> None:
+    async def _post_initial(
+        self,
+        resource_group_name: str,
+        vault_name: str,
+        parameters: Union[_models.FetchTieringCostInfoRequest, IO[bytes]],
+        **kwargs: Any
+    ) -> Optional[_models.TieringCostInfo]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.TieringCostInfo]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
-            _json = self._serialize.body(parameters, "CrossRegionRestoreRequest")
+            _json = self._serialize.body(parameters, "FetchTieringCostInfoRequest")
 
-        request = build_trigger_request(
-            azure_region=azure_region,
+        _request = build_post_request(
+            resource_group_name=resource_group_name,
+            vault_name=vault_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._trigger_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+        deserialized = None
+        response_headers = {}
+        if response.status_code == 200:
+            deserialized = self._deserialize("TieringCostInfo", pipeline_response)
+
+        if response.status_code == 202:
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
-    _trigger_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrossRegionRestore"
-    }
+        return deserialized  # type: ignore
 
     @overload
-    async def begin_trigger(
+    async def begin_post(
         self,
-        azure_region: str,
-        parameters: _models.CrossRegionRestoreRequest,
+        resource_group_name: str,
+        vault_name: str,
+        parameters: _models.FetchTieringCostInfoRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Restores the specified backed up data in a different region as compared to where the data is
-        backed up.
-
-        Restores the specified backed up data in a different region as compared to where the data is
-        backed up.
-
-        :param azure_region: Azure region to hit Api. Required.
-        :type azure_region: str
-        :param parameters: resource cross region restore request. Required.
+    ) -> AsyncLROPoller[_models.TieringCostInfo]:
+        """Provides the details of the tiering related sizes and cost.
+        Status of the operation can be fetched using GetTieringCostOperationStatus API and result using
+        GetTieringCostOperationResult API.
+
+        :param resource_group_name: The name of the resource group where the recovery services vault is
+         present. Required.
+        :type resource_group_name: str
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
+        :param parameters: Fetch Tiering Cost Request. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrossRegionRestoreRequest
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.FetchTieringCostInfoRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either TieringCostInfo or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_trigger(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Restores the specified backed up data in a different region as compared to where the data is
-        backed up.
-
-        Restores the specified backed up data in a different region as compared to where the data is
-        backed up.
-
-        :param azure_region: Azure region to hit Api. Required.
-        :type azure_region: str
-        :param parameters: resource cross region restore request. Required.
-        :type parameters: IO
+    async def begin_post(
+        self,
+        resource_group_name: str,
+        vault_name: str,
+        parameters: IO[bytes],
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[_models.TieringCostInfo]:
+        """Provides the details of the tiering related sizes and cost.
+        Status of the operation can be fetched using GetTieringCostOperationStatus API and result using
+        GetTieringCostOperationResult API.
+
+        :param resource_group_name: The name of the resource group where the recovery services vault is
+         present. Required.
+        :type resource_group_name: str
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
+        :param parameters: Fetch Tiering Cost Request. Required.
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either TieringCostInfo or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
-    async def begin_trigger(
-        self, azure_region: str, parameters: Union[_models.CrossRegionRestoreRequest, IO], **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Restores the specified backed up data in a different region as compared to where the data is
-        backed up.
-
-        Restores the specified backed up data in a different region as compared to where the data is
-        backed up.
-
-        :param azure_region: Azure region to hit Api. Required.
-        :type azure_region: str
-        :param parameters: resource cross region restore request. Is either a CrossRegionRestoreRequest
-         type or a IO type. Required.
+    async def begin_post(
+        self,
+        resource_group_name: str,
+        vault_name: str,
+        parameters: Union[_models.FetchTieringCostInfoRequest, IO[bytes]],
+        **kwargs: Any
+    ) -> AsyncLROPoller[_models.TieringCostInfo]:
+        """Provides the details of the tiering related sizes and cost.
+        Status of the operation can be fetched using GetTieringCostOperationStatus API and result using
+        GetTieringCostOperationResult API.
+
+        :param resource_group_name: The name of the resource group where the recovery services vault is
+         present. Required.
+        :type resource_group_name: str
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
+        :param parameters: Fetch Tiering Cost Request. Is either a FetchTieringCostInfoRequest type or
+         a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrossRegionRestoreRequest or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+         ~azure.mgmt.recoveryservicesbackup.activestamp.models.FetchTieringCostInfoRequest or IO[bytes]
+        :return: An instance of AsyncLROPoller that returns either TieringCostInfo or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.recoveryservicesbackup.activestamp.models.TieringCostInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[_models.TieringCostInfo] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._trigger_initial(  # type: ignore
-                azure_region=azure_region,
+            raw_result = await self._post_initial(
+                resource_group_name=resource_group_name,
+                vault_name=vault_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+        def get_long_running_output(pipeline_response):
+            deserialized = self._deserialize("TieringCostInfo", pipeline_response)
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, deserialized, {})  # type: ignore
+            return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
+            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return AsyncLROPoller[_models.TieringCostInfo].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrossRegionRestore"
-    }
+        return AsyncLROPoller[_models.TieringCostInfo](
+            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
+        )
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_crr_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_crr_operation_results_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -56,15 +56,14 @@
     ) -> None:
         """get.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -75,37 +74,32 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrOperationResults/{operationId}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_crr_operation_status_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_crr_operation_status_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -54,15 +54,14 @@
     async def get(self, azure_region: str, operation_id: str, **kwargs: Any) -> _models.OperationStatus:
         """get.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -73,41 +72,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrOperationsStatus/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_recovery_points_crr_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_recovery_points_crr_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -75,15 +75,14 @@
         :type fabric_name: str
         :param container_name: Container name associated with the backed up item. Required.
         :type container_name: str
         :param protected_item_name: Backed up item whose backup copies are to be fetched. Required.
         :type protected_item_name: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RecoveryPointResource or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.RecoveryPointResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -99,77 +98,72 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     vault_name=vault_name,
                     resource_group_name=resource_group_name,
                     fabric_name=fabric_name,
                     container_name=container_name,
                     protected_item_name=protected_item_name,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RecoveryPointResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/"
-    }
-
     @distributed_trace_async
     async def get(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
@@ -190,15 +184,14 @@
         :type container_name: str
         :param protected_item_name: Backed up item name whose backup data needs to be fetched.
          Required.
         :type protected_item_name: str
         :param recovery_point_id: RecoveryPointID represents the backed up data to be fetched.
          Required.
         :type recovery_point_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RecoveryPointResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.RecoveryPointResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -209,45 +202,40 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.RecoveryPointResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("RecoveryPointResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_recovery_points_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_recovery_points_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -83,30 +83,29 @@
         :param recovery_point_id: Recovery Point Id. Required.
         :type recovery_point_id: str
         :param parameters: Get Access Token request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.AADPropertiesResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CrrAccessTokenResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrAccessTokenResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def get_access_token(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CrrAccessTokenResource:
         """Returns the Access token for communication between BMS and Protection service.
 
         Returns the Access token for communication between BMS and Protection service.
@@ -121,34 +120,33 @@
         :param container_name: Name of the container. Required.
         :type container_name: str
         :param protected_item_name: Name of the Protected Item. Required.
         :type protected_item_name: str
         :param recovery_point_id: Recovery Point Id. Required.
         :type recovery_point_id: str
         :param parameters: Get Access Token request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CrrAccessTokenResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrAccessTokenResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def get_access_token(
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: Union[_models.AADPropertiesResource, IO],
+        parameters: Union[_models.AADPropertiesResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.CrrAccessTokenResource:
         """Returns the Access token for communication between BMS and Protection service.
 
         Returns the Access token for communication between BMS and Protection service.
 
         :param vault_name: The name of the recovery services vault. Required.
@@ -160,22 +158,18 @@
         :type fabric_name: str
         :param container_name: Name of the container. Required.
         :type container_name: str
         :param protected_item_name: Name of the Protected Item. Required.
         :type protected_item_name: str
         :param recovery_point_id: Recovery Point Id. Required.
         :type recovery_point_id: str
-        :param parameters: Get Access Token request. Is either a AADPropertiesResource type or a IO
-         type. Required.
+        :param parameters: Get Access Token request. Is either a AADPropertiesResource type or a
+         IO[bytes] type. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.AADPropertiesResource
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         or IO[bytes]
         :return: CrrAccessTokenResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrAccessTokenResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -196,48 +190,43 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AADPropertiesResource")
 
-        request = build_get_access_token_request(
+        _request = build_get_access_token_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.get_access_token.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CrrAccessTokenResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get_access_token.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/accessToken"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_models_py3.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_models_py3.py`

 * *Files 1% similar despite different names*

```diff
@@ -194,15 +194,15 @@
 class ProtectedItem(_serialization.Model):  # pylint: disable=too-many-instance-attributes
     """Base class for backup items.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureFileshareProtectedItem, AzureIaaSVMProtectedItem, AzureVmWorkloadProtectedItem,
     DPMProtectedItem, GenericProtectedItem, MabFileFolderProtectedItem, AzureSqlProtectedItem
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -360,15 +360,15 @@
         self.is_rehydrate = is_rehydrate
         self.resource_guard_operation_requests = resource_guard_operation_requests
 
 
 class AzureFileshareProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """Azure File Share workload-specific backup item.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -646,15 +646,15 @@
 class RecoveryPoint(_serialization.Model):
     """Base class for backup copies. Workload-specific backup copies are derived from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureFileShareRecoveryPoint, AzureWorkloadRecoveryPoint, GenericRecoveryPoint,
     IaasVMRecoveryPoint
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -681,15 +681,15 @@
 
 
 class AzureFileShareRecoveryPoint(RecoveryPoint):
     """Azure File Share workload specific backup copy.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_type: Type of the backup copy. Specifies whether it is a crash consistent
      backup or app consistent.
     :vartype recovery_point_type: str
@@ -729,15 +729,15 @@
 
 class RestoreRequest(_serialization.Model):
     """Base class for restore request. Workload-specific restore requests are derived from this class.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureFileShareRestoreRequest, AzureWorkloadRestoreRequest, IaasVMRestoreRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -761,15 +761,15 @@
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
 
 
 class AzureFileShareRestoreRequest(RestoreRequest):
     """AzureFileShare Restore Request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
@@ -853,15 +853,15 @@
 
 class AzureIaaSVMProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload-specific backup item.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureIaaSClassicComputeVMProtectedItem, AzureIaaSComputeVMProtectedItem
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -1118,15 +1118,15 @@
         self.extended_info = extended_info
         self.extended_properties = extended_properties
 
 
 class AzureIaaSClassicComputeVMProtectedItem(AzureIaaSVMProtectedItem):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload-specific backup item representing the Classic Compute VM.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -1376,15 +1376,15 @@
         )
         self.protected_item_type: str = "Microsoft.ClassicCompute/virtualMachines"
 
 
 class AzureIaaSComputeVMProtectedItem(AzureIaaSVMProtectedItem):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload-specific backup item representing the Azure Resource Manager VM.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -1722,40 +1722,22 @@
     :vartype title: str
     :ivar message: Health Message.
     :vartype message: str
     :ivar recommendations: Health Recommended Actions.
     :vartype recommendations: list[str]
     """
 
-    _validation = {
-        "code": {"readonly": True},
-        "title": {"readonly": True},
-        "message": {"readonly": True},
-        "recommendations": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "code": {"key": "code", "type": "int"},
-        "title": {"key": "title", "type": "str"},
-        "message": {"key": "message", "type": "str"},
-        "recommendations": {"key": "recommendations", "type": "[str]"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-
 
 class Job(_serialization.Model):
     """Defines workload agnostic properties for a job.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureIaaSVMJob, AzureStorageJob, AzureWorkloadJob, DpmJob, MabJob
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -1842,15 +1824,15 @@
         self.activity_id = activity_id
         self.job_type: Optional[str] = None
 
 
 class AzureIaaSVMJob(Job):  # pylint: disable=too-many-instance-attributes
     """Azure IaaS VM workload-specific job object.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -2153,15 +2135,15 @@
         self.recovery_point_count = recovery_point_count
         self.policy_inconsistent = policy_inconsistent
 
 
 class AzureSqlProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """Azure SQL workload-specific backup item.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -2417,15 +2399,15 @@
         self.error_string = error_string
         self.recommendations = recommendations
 
 
 class AzureStorageJob(Job):  # pylint: disable=too-many-instance-attributes
     """Azure storage specific job.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -2625,15 +2607,15 @@
 class AzureVmWorkloadProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """Azure VM workload-specific protected item.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureVmWorkloadSAPAseDatabaseProtectedItem, AzureVmWorkloadSAPHanaDatabaseProtectedItem,
     AzureVmWorkloadSQLDatabaseProtectedItem
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -2942,18 +2924,18 @@
         self.oldest_recovery_point = oldest_recovery_point
         self.recovery_point_count = recovery_point_count
         self.policy_state = policy_state
 
 
 class AzureVmWorkloadSAPAseDatabaseProtectedItem(
     AzureVmWorkloadProtectedItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protected item representing SAP ASE Database.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -3213,18 +3195,18 @@
             **kwargs
         )
         self.protected_item_type: str = "AzureVmWorkloadSAPAseDatabase"
 
 
 class AzureVmWorkloadSAPHanaDatabaseProtectedItem(
     AzureVmWorkloadProtectedItem
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """Azure VM workload-specific protected item representing SAP HANA Database.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -3487,15 +3469,15 @@
 
 
 class AzureVmWorkloadSQLDatabaseProtectedItem(
     AzureVmWorkloadProtectedItem
 ):  # pylint: disable=too-many-instance-attributes
     """Azure VM workload-specific protected item representing SQL Database.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -3809,15 +3791,15 @@
         self.recommendations = recommendations
         self.additional_details = additional_details
 
 
 class AzureWorkloadJob(Job):  # pylint: disable=too-many-instance-attributes
     """Azure storage specific job.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -4010,15 +3992,15 @@
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadPointInTimeRecoveryPoint, AzureWorkloadSAPHanaRecoveryPoint,
     AzureWorkloadSQLRecoveryPoint
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -4084,15 +4066,15 @@
     """Recovery point specific to PointInTime.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSAPHanaPointInTimeRecoveryPoint
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -4162,15 +4144,15 @@
 class AzureWorkloadRestoreRequest(RestoreRequest):
     """AzureWorkload-specific restore.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadPointInTimeRestoreRequest, AzureWorkloadSAPHanaRestoreRequest,
     AzureWorkloadSQLRestoreRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
@@ -4256,15 +4238,15 @@
         self.recovery_mode = recovery_mode
         self.target_virtual_machine_id = target_virtual_machine_id
 
 
 class AzureWorkloadPointInTimeRestoreRequest(AzureWorkloadRestoreRequest):
     """AzureWorkload SAP Hana -specific restore. Specifically for PointInTime/Log restore.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
@@ -4348,20 +4330,22 @@
             target_virtual_machine_id=target_virtual_machine_id,
             **kwargs
         )
         self.object_type: str = "AzureWorkloadPointInTimeRestoreRequest"
         self.point_in_time = point_in_time
 
 
-class AzureWorkloadSAPHanaPointInTimeRecoveryPoint(AzureWorkloadPointInTimeRecoveryPoint):
+class AzureWorkloadSAPHanaPointInTimeRecoveryPoint(
+    AzureWorkloadPointInTimeRecoveryPoint
+):  # pylint: disable=name-too-long
     """Recovery point specific to PointInTime in SAPHana.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -4426,15 +4410,15 @@
 
 class AzureWorkloadSAPHanaRestoreRequest(AzureWorkloadRestoreRequest):
     """AzureWorkload SAP Hana-specific restore.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSAPHanaPointInTimeRestoreRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
@@ -4517,18 +4501,20 @@
             recovery_mode=recovery_mode,
             target_virtual_machine_id=target_virtual_machine_id,
             **kwargs
         )
         self.object_type: str = "AzureWorkloadSAPHanaRestoreRequest"
 
 
-class AzureWorkloadSAPHanaPointInTimeRestoreRequest(AzureWorkloadSAPHanaRestoreRequest):
+class AzureWorkloadSAPHanaPointInTimeRestoreRequest(
+    AzureWorkloadSAPHanaRestoreRequest
+):  # pylint: disable=name-too-long
     """AzureWorkload SAP Hana -specific restore. Specifically for PointInTime/Log restore.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
@@ -4617,15 +4603,15 @@
 
 
 class AzureWorkloadSAPHanaRecoveryPoint(AzureWorkloadRecoveryPoint):
     """SAPHana specific recoverypoint, specifically encapsulates full/diff recoverypoints.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -4684,15 +4670,15 @@
     extended info.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSQLPointInTimeRecoveryPoint
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -4766,15 +4752,15 @@
 
 
 class AzureWorkloadSQLPointInTimeRecoveryPoint(AzureWorkloadSQLRecoveryPoint):
     """Recovery point specific to PointInTime.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_time_in_utc: UTC time at which recovery point was created.
     :vartype recovery_point_time_in_utc: ~datetime.datetime
     :ivar type: Type of restore point. Known values are: "Invalid", "Full", "Log", "Differential",
@@ -4854,15 +4840,15 @@
 
 class AzureWorkloadSQLRestoreRequest(AzureWorkloadRestoreRequest):
     """AzureWorkload SQL -specific restore. Specifically for full/diff restore.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     AzureWorkloadSQLPointInTimeRestoreRequest
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
@@ -4972,18 +4958,18 @@
         self.should_use_alternate_target_location = should_use_alternate_target_location
         self.is_non_recoverable = is_non_recoverable
         self.alternate_directory_paths = alternate_directory_paths
 
 
 class AzureWorkloadSQLPointInTimeRestoreRequest(
     AzureWorkloadSQLRestoreRequest
-):  # pylint: disable=too-many-instance-attributes
+):  # pylint: disable=too-many-instance-attributes,name-too-long
     """AzureWorkload SQL -specific restore. Specifically for PointInTime/Log restore.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
      "AlternateLocation", "RestoreDisks", and "Offline".
     :vartype recovery_type: str or
@@ -5094,15 +5080,15 @@
             alternate_directory_paths=alternate_directory_paths,
             **kwargs
         )
         self.object_type: str = "AzureWorkloadSQLPointInTimeRestoreRequest"
         self.point_in_time = point_in_time
 
 
-class AzureWorkloadSQLRecoveryPointExtendedInfo(_serialization.Model):
+class AzureWorkloadSQLRecoveryPointExtendedInfo(_serialization.Model):  # pylint: disable=name-too-long
     """Extended info class details.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar data_directory_time_in_utc: UTC time at which data directory info was captured.
     :vartype data_directory_time_in_utc: ~datetime.datetime
     :ivar data_directory_paths: List of data directory paths during restore operation.
@@ -5644,15 +5630,15 @@
 
 class CrrAccessToken(_serialization.Model):  # pylint: disable=too-many-instance-attributes
     """CrrAccessToken.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     WorkloadCrrAccessToken
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: Type of the specific object - used for deserializing. Required.
     :vartype object_type: str
     :ivar access_token_string: Access token used for authentication.
     :vartype access_token_string: str
     :ivar subscription_id: Subscription Id of the source vault.
     :vartype subscription_id: str
@@ -6088,15 +6074,15 @@
         self.error_string = error_string
         self.recommendations = recommendations
 
 
 class DpmJob(Job):  # pylint: disable=too-many-instance-attributes
     """DPM workload-specific job object.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -6331,15 +6317,15 @@
         self.duration = duration
         self.status = status
 
 
 class DPMProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """Additional information on Backup engine specific backup item.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -6777,15 +6763,15 @@
         super().__init__(**kwargs)
         self.disk_exclusion_properties = disk_exclusion_properties
 
 
 class GenericProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """Base class for backup items.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -6983,15 +6969,15 @@
         self.source_associations = source_associations
         self.fabric_name = fabric_name
 
 
 class GenericRecoveryPoint(RecoveryPoint):
     """Generic backup copy.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar friendly_name: Friendly name of the backup copy.
     :vartype friendly_name: str
     :ivar recovery_point_type: Type of the backup copy.
@@ -7043,15 +7029,15 @@
 
 
 class IaasVMRecoveryPoint(RecoveryPoint):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload specific backup copy.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_type: Type of the backup copy.
     :vartype recovery_point_type: str
     :ivar recovery_point_time: Time at which this backup copy was created.
@@ -7188,15 +7174,15 @@
         self.zones = zones
         self.recovery_point_move_readiness_info = recovery_point_move_readiness_info
 
 
 class IaasVMRestoreRequest(RestoreRequest):  # pylint: disable=too-many-instance-attributes
     """IaaS VM workload-specific restore.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_point_id: ID of the backup copy to be recovered.
     :vartype recovery_point_id: str
     :ivar recovery_type: Type of this recovery. Known values are: "Invalid", "OriginalLocation",
@@ -7832,15 +7818,15 @@
         self.error_string = None
         self.recommendations = None
 
 
 class MabFileFolderProtectedItem(ProtectedItem):  # pylint: disable=too-many-instance-attributes
     """MAB workload-specific backup item.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar protected_item_type: backup item type. Required.
     :vartype protected_item_type: str
     :ivar backup_management_type: Type of backup management for the backed up item. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -8078,15 +8064,15 @@
         self.oldest_recovery_point = oldest_recovery_point
         self.recovery_point_count = recovery_point_count
 
 
 class MabJob(Job):  # pylint: disable=too-many-instance-attributes
     """MAB workload-specific job.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar entity_friendly_name: Friendly name of the entity on which the current job is executing.
     :vartype entity_friendly_name: str
     :ivar backup_management_type: Backup management type to execute the current job. Known values
      are: "Invalid", "AzureIaasVM", "MAB", "DPM", "AzureBackupServer", "AzureSql", "AzureStorage",
      "AzureWorkload", and "DefaultBackup".
     :vartype backup_management_type: str or
@@ -8523,15 +8509,15 @@
 class OperationStatusExtendedInfo(_serialization.Model):
     """Base class for additional information of operation status.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     OperationStatusJobExtendedInfo, OperationStatusJobsExtendedInfo,
     OperationStatusProvisionILRExtendedInfo, OperationStatusRecoveryPointExtendedInfo
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     """
 
     _validation = {
@@ -8556,15 +8542,15 @@
         super().__init__(**kwargs)
         self.object_type: Optional[str] = None
 
 
 class OperationStatusJobExtendedInfo(OperationStatusExtendedInfo):
     """Operation status job extended info.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar job_id: ID of the job created for this protected item.
     :vartype job_id: str
     """
@@ -8587,15 +8573,15 @@
         self.object_type: str = "OperationStatusJobExtendedInfo"
         self.job_id = job_id
 
 
 class OperationStatusJobsExtendedInfo(OperationStatusExtendedInfo):
     """Operation status extended info for list of jobs.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar job_ids: IDs of the jobs created for the protected item.
     :vartype job_ids: list[str]
     :ivar failed_jobs_error: Stores all the failed jobs along with the corresponding error codes.
@@ -8627,15 +8613,15 @@
         self.job_ids = job_ids
         self.failed_jobs_error = failed_jobs_error
 
 
 class OperationStatusProvisionILRExtendedInfo(OperationStatusExtendedInfo):
     """Operation status extended info for ILR provision action.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar recovery_target: Target details for file / folder restore.
     :vartype recovery_target:
      ~azure.mgmt.recoveryservicesbackup.passivestamp.models.InstantItemRecoveryTarget
@@ -8660,15 +8646,15 @@
         self.object_type: str = "OperationStatusProvisionILRExtendedInfo"
         self.recovery_target = recovery_target
 
 
 class OperationStatusRecoveryPointExtendedInfo(OperationStatusExtendedInfo):
     """Operation status extended info for Updated Recovery Point.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: This property will be used as the discriminator for deciding the specific
      types in the polymorphic chain of types. Required.
     :vartype object_type: str
     :ivar updated_recovery_point: Recovery Point info with updated source snapshot URI.
     :vartype updated_recovery_point:
      ~azure.mgmt.recoveryservicesbackup.passivestamp.models.RecoveryPoint
@@ -9363,15 +9349,15 @@
         self.database_name = database_name
         self.target_directory_for_file_restore = target_directory_for_file_restore
 
 
 class WorkloadCrrAccessToken(CrrAccessToken):  # pylint: disable=too-many-instance-attributes
     """WorkloadCrrAccessToken.
 
-    All required parameters must be populated in order to send to Azure.
+    All required parameters must be populated in order to send to server.
 
     :ivar object_type: Type of the specific object - used for deserializing. Required.
     :vartype object_type: str
     :ivar access_token_string: Access token used for authentication.
     :vartype access_token_string: str
     :ivar subscription_id: Subscription Id of the source vault.
     :vartype subscription_id: str
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_recovery_services_backup_passive_client_enums.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/models/_recovery_services_backup_passive_client_enums.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/__init__.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_aad_properties_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_aad_properties_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -91,15 +91,14 @@
 
         Fetches the AAD properties from target region BCM stamp.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param filter: OData filter options. Default value is None.
         :type filter: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AADPropertiesResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.AADPropertiesResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -110,41 +109,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AADPropertiesResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             filter=filter,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AADPropertiesResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupAadProperties"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_crr_job_details_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_crr_job_details_operations.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -14,83 +14,49 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import _convert_request
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._backup_crr_job_details_operations import build_get_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_get_request(azure_region: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-11-15"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrJob",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "azureRegion": _SERIALIZER.url("azure_region", azure_region, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class BackupCrrJobDetailsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.RecoveryServicesBackupPassiveClient`'s
+        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.aio.RecoveryServicesBackupPassiveClient`'s
         :attr:`backup_crr_job_details` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @overload
-    def get(
+    async def get(
         self,
         azure_region: str,
         parameters: _models.CrrJobRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.JobResource:
@@ -101,57 +67,53 @@
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: CRR Job request. Required.
         :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def get(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
+    async def get(
+        self, azure_region: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.JobResource:
         """Get CRR job details from target region.
 
         Get CRR job details from target region.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: CRR Job request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def get(
-        self, azure_region: str, parameters: Union[_models.CrrJobRequest, IO], **kwargs: Any
+    @distributed_trace_async
+    async def get(
+        self, azure_region: str, parameters: Union[_models.CrrJobRequest, IO[bytes]], **kwargs: Any
     ) -> _models.JobResource:
         """Get CRR job details from target region.
 
         Get CRR job details from target region.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
-        :param parameters: CRR Job request. Is either a CrrJobRequest type or a IO type. Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+        :param parameters: CRR Job request. Is either a CrrJobRequest type or a IO[bytes] type.
+         Required.
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest or
+         IO[bytes]
         :return: JobResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -171,43 +133,38 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "CrrJobRequest")
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrJob"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_crr_jobs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_crr_jobs_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -120,80 +120,75 @@
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def list(
         self,
         azure_region: str,
-        parameters: IO,
+        parameters: IO[bytes],
         filter: Optional[str] = None,
         skip_token: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Iterable["_models.JobResource"]:
         """Gets the list of CRR jobs from the target region.
 
         Gets the list of CRR jobs from the target region.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: Backup CRR Job request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def list(
         self,
         azure_region: str,
-        parameters: Union[_models.CrrJobRequest, IO],
+        parameters: Union[_models.CrrJobRequest, IO[bytes]],
         filter: Optional[str] = None,
         skip_token: Optional[str] = None,
         **kwargs: Any
     ) -> Iterable["_models.JobResource"]:
         """Gets the list of CRR jobs from the target region.
 
         Gets the list of CRR jobs from the target region.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
-        :param parameters: Backup CRR Job request. Is either a CrrJobRequest type or a IO type.
+        :param parameters: Backup CRR Job request. Is either a CrrJobRequest type or a IO[bytes] type.
          Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest or IO
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrJobRequest or
+         IO[bytes]
         :param filter: OData filter options. Default value is None.
         :type filter: str
         :param skip_token: skipToken Filter. Default value is None.
         :type skip_token: str
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.recoveryservicesbackup.passivestamp.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -216,69 +211,64 @@
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "CrrJobRequest")
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                _request = build_list_request(
                     azure_region=azure_region,
                     subscription_id=self._config.subscription_id,
                     filter=filter,
                     skip_token=skip_token,
                     api_version=api_version,
                     content_type=content_type,
                     json=_json,
                     content=_content,
-                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
+                _request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+                _request = _convert_request(_request)
+                _request.url = self._client.format_url(_request.url)
+                _request.method = "GET"
+            return _request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("JobResourceList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            request = prepare_request(next_link)
+            _request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                _request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrJobs"
-    }
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_resource_storage_configs_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_backup_resource_storage_configs_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -152,15 +152,14 @@
         """Fetches resource storage config.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -171,48 +170,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BackupResourceConfigResource] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def update(
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceConfigResource,
@@ -229,71 +223,66 @@
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.BackupResourceConfigResource:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update(
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceConfigResource, IO],
+        parameters: Union[_models.BackupResourceConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> _models.BackupResourceConfigResource:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Is either a BackupResourceConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource or
+         IO[bytes]
         :return: BackupResourceConfigResource or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -313,51 +302,46 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceConfigResource")
 
-        request = build_update_request(
+        _request = build_update_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("BackupResourceConfigResource", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-    update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+        return deserialized  # type: ignore
 
     @overload
     def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         parameters: _models.BackupResourceConfigResource,
@@ -374,71 +358,66 @@
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> None:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def patch(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
-        parameters: Union[_models.BackupResourceConfigResource, IO],
+        parameters: Union[_models.BackupResourceConfigResource, IO[bytes]],
         **kwargs: Any
     ) -> None:
         """Updates vault storage model type.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
         :param parameters: Vault storage config request. Is either a BackupResourceConfigResource type
-         or a IO type. Required.
+         or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
+         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.BackupResourceConfigResource or
+         IO[bytes]
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -458,40 +437,35 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "BackupResourceConfigResource")
 
-        request = build_patch_request(
+        _request = build_patch_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    patch.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupstorageconfig/vaultstorageconfig"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_cross_region_restore_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_cross_region_restore_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -84,15 +84,15 @@
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     def _trigger_initial(  # pylint: disable=inconsistent-return-statements
-        self, azure_region: str, parameters: Union[_models.CrossRegionRestoreRequest, IO], **kwargs: Any
+        self, azure_region: str, parameters: Union[_models.CrossRegionRestoreRequest, IO[bytes]], **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -109,46 +109,41 @@
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "CrossRegionRestoreRequest")
 
-        request = build_trigger_request(
+        _request = build_trigger_request(
             azure_region=azure_region,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._trigger_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    _trigger_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrossRegionRestore"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
 
     @overload
     def begin_trigger(
         self,
         azure_region: str,
         parameters: _models.CrossRegionRestoreRequest,
         *,
@@ -165,84 +160,57 @@
         :type azure_region: str
         :param parameters: resource cross region restore request. Required.
         :type parameters:
          ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrossRegionRestoreRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_trigger(
-        self, azure_region: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
+        self, azure_region: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
     ) -> LROPoller[None]:
         """Restores the specified backed up data in a different region as compared to where the data is
         backed up.
 
         Restores the specified backed up data in a different region as compared to where the data is
         backed up.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: resource cross region restore request. Required.
-        :type parameters: IO
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_trigger(
-        self, azure_region: str, parameters: Union[_models.CrossRegionRestoreRequest, IO], **kwargs: Any
+        self, azure_region: str, parameters: Union[_models.CrossRegionRestoreRequest, IO[bytes]], **kwargs: Any
     ) -> LROPoller[None]:
         """Restores the specified backed up data in a different region as compared to where the data is
         backed up.
 
         Restores the specified backed up data in a different region as compared to where the data is
         backed up.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param parameters: resource cross region restore request. Is either a CrossRegionRestoreRequest
-         type or a IO type. Required.
+         type or a IO[bytes] type. Required.
         :type parameters:
-         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrossRegionRestoreRequest or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
+         ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrossRegionRestoreRequest or IO[bytes]
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -263,29 +231,25 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})
+                return cls(pipeline_response, None, {})  # type: ignore
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return LROPoller[None].from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_trigger.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrossRegionRestore"
-    }
+        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_crr_operation_results_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_crr_operation_results_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -88,15 +88,14 @@
     ) -> None:
         """get.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -107,37 +106,32 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrOperationResults/{operationId}"
-    }
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_crr_operation_status_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_crr_operation_status_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -86,15 +86,14 @@
     def get(self, azure_region: str, operation_id: str, **kwargs: Any) -> _models.OperationStatus:
         """get.
 
         :param azure_region: Azure region to hit Api. Required.
         :type azure_region: str
         :param operation_id: Required.
         :type operation_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -105,41 +104,36 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        _request = build_get_request(
             azure_region=azure_region,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.RecoveryServices/locations/{azureRegion}/backupCrrOperationsStatus/{operationId}"
-    }
+        return deserialized  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_patch.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure/mgmt/recoveryservicesbackup/passivestamp/operations/_recovery_points_operations.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_item_level_recovery_connections_operations.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines
+# pylint: disable=too-many-lines,too-many-statements
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -14,278 +14,307 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import _convert_request
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._item_level_recovery_connections_operations import build_provision_request, build_revoke_request
+from .._vendor import RecoveryServicesBackupClientMixinABC
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
 
-
-def build_get_access_token_request(
-    vault_name: str,
-    resource_group_name: str,
-    fabric_name: str,
-    container_name: str,
-    protected_item_name: str,
-    recovery_point_id: str,
-    subscription_id: str,
-    **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-11-15"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/accessToken",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "vaultName": _SERIALIZER.url("vault_name", vault_name, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "fabricName": _SERIALIZER.url("fabric_name", fabric_name, "str"),
-        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
-        "protectedItemName": _SERIALIZER.url("protected_item_name", protected_item_name, "str"),
-        "recoveryPointId": _SERIALIZER.url("recovery_point_id", recovery_point_id, "str"),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-class RecoveryPointsOperations:
+class ItemLevelRecoveryConnectionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.recoveryservicesbackup.passivestamp.RecoveryServicesBackupPassiveClient`'s
-        :attr:`recovery_points` attribute.
+        :class:`~azure.mgmt.recoveryservicesbackup.activestamp.aio.RecoveryServicesBackupClient`'s
+        :attr:`item_level_recovery_connections` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @overload
-    def get_access_token(
+    async def provision(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: _models.AADPropertiesResource,
+        parameters: _models.ILRRequestResource,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> _models.CrrAccessTokenResource:
-        """Returns the Access token for communication between BMS and Protection service.
-
-        Returns the Access token for communication between BMS and Protection service.
+    ) -> None:
+        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
+        opens a file
+        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
+        To know the status of
+        provisioning, call GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the container. Required.
+        :param fabric_name: Fabric name associated with the backed up items. Required.
         :type fabric_name: str
-        :param container_name: Name of the container. Required.
+        :param container_name: Container name associated with the backed up items. Required.
         :type container_name: str
-        :param protected_item_name: Name of the Protected Item. Required.
+        :param protected_item_name: Backed up item name whose files/folders are to be restored.
+         Required.
         :type protected_item_name: str
-        :param recovery_point_id: Recovery Point Id. Required.
+        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
+         will be provisioned
+         for this backed up data. Required.
         :type recovery_point_id: str
-        :param parameters: Get Access Token request. Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.AADPropertiesResource
+        :param parameters: resource ILR request. Required.
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ILRRequestResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: CrrAccessTokenResource or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrAccessTokenResource
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def get_access_token(
+    async def provision(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: IO,
+        parameters: IO[bytes],
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> _models.CrrAccessTokenResource:
-        """Returns the Access token for communication between BMS and Protection service.
-
-        Returns the Access token for communication between BMS and Protection service.
+    ) -> None:
+        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
+        opens a file
+        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
+        To know the status of
+        provisioning, call GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the container. Required.
+        :param fabric_name: Fabric name associated with the backed up items. Required.
         :type fabric_name: str
-        :param container_name: Name of the container. Required.
+        :param container_name: Container name associated with the backed up items. Required.
         :type container_name: str
-        :param protected_item_name: Name of the Protected Item. Required.
+        :param protected_item_name: Backed up item name whose files/folders are to be restored.
+         Required.
         :type protected_item_name: str
-        :param recovery_point_id: Recovery Point Id. Required.
+        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
+         will be provisioned
+         for this backed up data. Required.
         :type recovery_point_id: str
-        :param parameters: Get Access Token request. Required.
-        :type parameters: IO
+        :param parameters: resource ILR request. Required.
+        :type parameters: IO[bytes]
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: CrrAccessTokenResource or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrAccessTokenResource
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def get_access_token(
+    @distributed_trace_async
+    async def provision(  # pylint: disable=inconsistent-return-statements
         self,
         vault_name: str,
         resource_group_name: str,
         fabric_name: str,
         container_name: str,
         protected_item_name: str,
         recovery_point_id: str,
-        parameters: Union[_models.AADPropertiesResource, IO],
+        parameters: Union[_models.ILRRequestResource, IO[bytes]],
         **kwargs: Any
-    ) -> _models.CrrAccessTokenResource:
-        """Returns the Access token for communication between BMS and Protection service.
-
-        Returns the Access token for communication between BMS and Protection service.
+    ) -> None:
+        """Provisions a script which invokes an iSCSI connection to the backup data. Executing this script
+        opens a file
+        explorer displaying all the recoverable files and folders. This is an asynchronous operation.
+        To know the status of
+        provisioning, call GetProtectedItemOperationResult API.
 
         :param vault_name: The name of the recovery services vault. Required.
         :type vault_name: str
         :param resource_group_name: The name of the resource group where the recovery services vault is
          present. Required.
         :type resource_group_name: str
-        :param fabric_name: Fabric name associated with the container. Required.
+        :param fabric_name: Fabric name associated with the backed up items. Required.
         :type fabric_name: str
-        :param container_name: Name of the container. Required.
+        :param container_name: Container name associated with the backed up items. Required.
         :type container_name: str
-        :param protected_item_name: Name of the Protected Item. Required.
+        :param protected_item_name: Backed up item name whose files/folders are to be restored.
+         Required.
         :type protected_item_name: str
-        :param recovery_point_id: Recovery Point Id. Required.
+        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
+         will be provisioned
+         for this backed up data. Required.
         :type recovery_point_id: str
-        :param parameters: Get Access Token request. Is either a AADPropertiesResource type or a IO
+        :param parameters: resource ILR request. Is either a ILRRequestResource type or a IO[bytes]
          type. Required.
-        :type parameters: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.AADPropertiesResource
-         or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: CrrAccessTokenResource or the result of cls(response)
-        :rtype: ~azure.mgmt.recoveryservicesbackup.passivestamp.models.CrrAccessTokenResource
+        :type parameters: ~azure.mgmt.recoveryservicesbackup.activestamp.models.ILRRequestResource or
+         IO[bytes]
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
-            400: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CrrAccessTokenResource] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
-            _json = self._serialize.body(parameters, "AADPropertiesResource")
+            _json = self._serialize.body(parameters, "ILRRequestResource")
 
-        request = build_get_access_token_request(
+        _request = build_provision_request(
             vault_name=vault_name,
             resource_group_name=resource_group_name,
             fabric_name=fabric_name,
             container_name=container_name,
             protected_item_name=protected_item_name,
             recovery_point_id=recovery_point_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.get_access_token.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.NewErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("CrrAccessTokenResource", pipeline_response)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, None, {})  # type: ignore
+
+    @distributed_trace_async
+    async def revoke(  # pylint: disable=inconsistent-return-statements
+        self,
+        vault_name: str,
+        resource_group_name: str,
+        fabric_name: str,
+        container_name: str,
+        protected_item_name: str,
+        recovery_point_id: str,
+        **kwargs: Any
+    ) -> None:
+        """Revokes an iSCSI connection which can be used to download a script. Executing this script opens
+        a file explorer
+        displaying all recoverable files and folders. This is an asynchronous operation.
+
+        :param vault_name: The name of the recovery services vault. Required.
+        :type vault_name: str
+        :param resource_group_name: The name of the resource group where the recovery services vault is
+         present. Required.
+        :type resource_group_name: str
+        :param fabric_name: Fabric name associated with the backed up items. Required.
+        :type fabric_name: str
+        :param container_name: Container name associated with the backed up items. Required.
+        :type container_name: str
+        :param protected_item_name: Backed up item name whose files/folders are to be restored.
+         Required.
+        :type protected_item_name: str
+        :param recovery_point_id: Recovery point ID which represents backed up data. iSCSI connection
+         will be revoked for
+         this backed up data. Required.
+        :type recovery_point_id: str
+        :return: None or the result of cls(response)
+        :rtype: None
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        _request = build_revoke_request(
+            vault_name=vault_name,
+            resource_group_name=resource_group_name,
+            fabric_name=fabric_name,
+            container_name=container_name,
+            protected_item_name=protected_item_name,
+            recovery_point_id=recovery_point_id,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            headers=_headers,
+            params=_params,
+        )
+        _request = _convert_request(_request)
+        _request.url = self._client.format_url(_request.url)
 
-        return deserialized
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            _request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
 
-    get_access_token.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{vaultName}/backupFabrics/{fabricName}/protectionContainers/{containerName}/protectedItems/{protectedItemName}/recoveryPoints/{recoveryPointId}/accessToken"
-    }
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+        if cls:
+            return cls(pipeline_response, None, {})  # type: ignore
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure_mgmt_recoveryservicesbackup.egg-info/PKG-INFO` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure_mgmt_recoveryservicesbackup.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-recoveryservicesbackup
-Version: 9.0.0
+Version: 9.1.0
 Summary: Microsoft Azure Recovery Services Backup Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 5 - Production/Stable
@@ -17,17 +17,14 @@
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
 Classifier: License :: OSI Approved :: MIT License
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 License-File: LICENSE
 License-File: LICENSE.txt
-Requires-Dist: isodate<1.0.0,>=0.6.1
-Requires-Dist: azure-common~=1.1
-Requires-Dist: azure-mgmt-core<2.0.0,>=1.3.2
 
 # Microsoft Azure SDK for Python
 
 This is the Microsoft Azure Recovery Services Backup Management Client Library.
 This package has been tested with Python 3.8+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
@@ -86,14 +83,31 @@
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 # Release History
 
+## 9.1.0 (2024-04-22)
+
+### Features Added
+
+  - Model AzureIaaSVMProtectionPolicy has a new parameter snapshot_consistency_type
+  - Model AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model AzureWorkloadSAPHanaRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model AzureWorkloadSQLRestoreWithRehydrateRequest has a new parameter resource_guard_operation_requests
+  - Model IaasVMRestoreWithRehydrationRequest has a new parameter resource_guard_operation_requests
+  - Operation BackupResourceVaultConfigsOperations.put has a new optional parameter x_ms_authorization_auxiliary
+  - Operation BackupResourceVaultConfigsOperations.update has a new optional parameter x_ms_authorization_auxiliary
+  - Operation ProtectedItemsOperations.create_or_update has a new optional parameter x_ms_authorization_auxiliary
+  - Operation ProtectionPoliciesOperations.create_or_update has a new optional parameter x_ms_authorization_auxiliary
+  - Operation RestoresOperations.begin_trigger has a new optional parameter x_ms_authorization_auxiliary
+  - Operation SecurityPINsOperations.get has a new optional parameter x_ms_authorization_auxiliary
+
 ## 9.0.0 (2024-01-24)
 
 ### Features Added
 
   - Added operation group FetchTieringCostOperations
   - Added operation group GetTieringCostOperationResultOperations
   - Added operation group TieringCostOperationStatusOperations
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/azure_mgmt_recoveryservicesbackup.egg-info/SOURCES.txt` & `azure-mgmt-recoveryservicesbackup-9.1.0/azure_mgmt_recoveryservicesbackup.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -12,15 +12,14 @@
 azure/mgmt/recoveryservicesbackup/activestamp/__init__.py
 azure/mgmt/recoveryservicesbackup/activestamp/_configuration.py
 azure/mgmt/recoveryservicesbackup/activestamp/_patch.py
 azure/mgmt/recoveryservicesbackup/activestamp/_recovery_services_backup_client.py
 azure/mgmt/recoveryservicesbackup/activestamp/_serialization.py
 azure/mgmt/recoveryservicesbackup/activestamp/_vendor.py
 azure/mgmt/recoveryservicesbackup/activestamp/_version.py
-azure/mgmt/recoveryservicesbackup/activestamp/py.typed
 azure/mgmt/recoveryservicesbackup/activestamp/aio/__init__.py
 azure/mgmt/recoveryservicesbackup/activestamp/aio/_configuration.py
 azure/mgmt/recoveryservicesbackup/activestamp/aio/_patch.py
 azure/mgmt/recoveryservicesbackup/activestamp/aio/_recovery_services_backup_client.py
 azure/mgmt/recoveryservicesbackup/activestamp/aio/_vendor.py
 azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/__init__.py
 azure/mgmt/recoveryservicesbackup/activestamp/aio/operations/_backup_engines_operations.py
@@ -139,15 +138,14 @@
 azure/mgmt/recoveryservicesbackup/passivestamp/__init__.py
 azure/mgmt/recoveryservicesbackup/passivestamp/_configuration.py
 azure/mgmt/recoveryservicesbackup/passivestamp/_patch.py
 azure/mgmt/recoveryservicesbackup/passivestamp/_recovery_services_backup_passive_client.py
 azure/mgmt/recoveryservicesbackup/passivestamp/_serialization.py
 azure/mgmt/recoveryservicesbackup/passivestamp/_vendor.py
 azure/mgmt/recoveryservicesbackup/passivestamp/_version.py
-azure/mgmt/recoveryservicesbackup/passivestamp/py.typed
 azure/mgmt/recoveryservicesbackup/passivestamp/aio/__init__.py
 azure/mgmt/recoveryservicesbackup/passivestamp/aio/_configuration.py
 azure/mgmt/recoveryservicesbackup/passivestamp/aio/_patch.py
 azure/mgmt/recoveryservicesbackup/passivestamp/aio/_recovery_services_backup_passive_client.py
 azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/__init__.py
 azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_aad_properties_operations.py
 azure/mgmt/recoveryservicesbackup/passivestamp/aio/operations/_backup_crr_job_details_operations.py
```

### Comparing `azure-mgmt-recoveryservicesbackup-9.0.0/setup.py` & `azure-mgmt-recoveryservicesbackup-9.1.0/setup.py`

 * *Files 2% similar despite different names*

```diff
@@ -70,13 +70,13 @@
         ]
     ),
     include_package_data=True,
     package_data={
         "pytyped": ["py.typed"],
     },
     install_requires=[
-        "isodate<1.0.0,>=0.6.1",
-        "azure-common~=1.1",
-        "azure-mgmt-core>=1.3.2,<2.0.0",
+        "isodate>=0.6.1",
+        "azure-common>=1.1",
+        "azure-mgmt-core>=1.3.2",
     ],
     python_requires=">=3.8",
 )
```

