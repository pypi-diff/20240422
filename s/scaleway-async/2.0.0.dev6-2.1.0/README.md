# Comparing `tmp/scaleway_async-2.0.0.dev6.tar.gz` & `tmp/scaleway_async-2.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "scaleway_async-2.0.0.dev6.tar", max compression
+gzip compressed data, was "scaleway_async-2.1.0.tar", max compression
```

## Comparing `scaleway_async-2.0.0.dev6.tar` & `scaleway_async-2.1.0.tar`

### file list

```diff
@@ -1,207 +1,226 @@
--rw-r--r--   0        0        0       30 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/README.md
--rw-r--r--   0        0        0     1138 2023-11-28 15:51:56.780953 scaleway_async-2.0.0.dev6/pyproject.toml
--rw-r--r--   0        0        0      913 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/__init__.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/account/__init__.py
--rw-r--r--   0        0        0      714 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/account/v2/__init__.py
--rw-r--r--   0        0        0     8546 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/account/v2/api.py
--rw-r--r--   0        0        0     2762 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/account/v2/marshalling.py
--rw-r--r--   0        0        0     2638 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/account/v2/types.py
--rw-r--r--   0        0        0      828 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/account/v3/__init__.py
--rw-r--r--   0        0        0     8270 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/account/v3/api.py
--rw-r--r--   0        0        0     2822 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/account/v3/marshalling.py
--rw-r--r--   0        0        0     2678 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/account/v3/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/__init__.py
--rw-r--r--   0        0        0     1674 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/v1alpha1/__init__.py
--rw-r--r--   0        0        0    18443 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/v1alpha1/api.py
--rw-r--r--   0        0        0      496 2023-11-28 15:51:37.608916 scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/v1alpha1/content.py
--rw-r--r--   0        0        0     7536 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/v1alpha1/marshalling.py
--rw-r--r--   0        0        0     7171 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/baremetal/__init__.py
--rw-r--r--   0        0        0     5332 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/__init__.py
--rw-r--r--   0        0        0    53384 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/api.py
--rw-r--r--   0        0        0     1060 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/content.py
--rw-r--r--   0        0        0    30608 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/marshalling.py
--rw-r--r--   0        0        0    27983 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/billing/__init__.py
--rw-r--r--   0        0        0     1414 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/billing/v2alpha1/__init__.py
--rw-r--r--   0        0        0     9200 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/billing/v2alpha1/api.py
--rw-r--r--   0        0        0     7208 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/billing/v2alpha1/marshalling.py
--rw-r--r--   0        0        0     7103 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/billing/v2alpha1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/block/__init__.py
--rw-r--r--   0        0        0     2456 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/__init__.py
--rw-r--r--   0        0        0    26645 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/api.py
--rw-r--r--   0        0        0      926 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/content.py
--rw-r--r--   0        0        0    13955 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/marshalling.py
--rw-r--r--   0        0        0    13735 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/cockpit/__init__.py
--rw-r--r--   0        0        0     3684 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/cockpit/v1beta1/__init__.py
--rw-r--r--   0        0        0    35053 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/cockpit/v1beta1/api.py
--rw-r--r--   0        0        0      418 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/cockpit/v1beta1/content.py
--rw-r--r--   0        0        0    21183 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/cockpit/v1beta1/marshalling.py
--rw-r--r--   0        0        0    15156 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/cockpit/v1beta1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/container/__init__.py
--rw-r--r--   0        0        0     5370 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/__init__.py
--rw-r--r--   0        0        0    66075 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/api.py
--rw-r--r--   0        0        0     1581 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/content.py
--rw-r--r--   0        0        0    28232 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/marshalling.py
--rw-r--r--   0        0        0    28544 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.612917 scaleway_async-2.0.0.dev6/scaleway_async/document_db/__init__.py
--rw-r--r--   0        0        0     9020 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/__init__.py
--rw-r--r--   0        0        0   101580 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/api.py
--rw-r--r--   0        0        0     1612 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/content.py
--rw-r--r--   0        0        0    49031 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/marshalling.py
--rw-r--r--   0        0        0    41184 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/domain/__init__.py
--rw-r--r--   0        0        0    13030 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/__init__.py
--rw-r--r--   0        0        0    88797 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/api.py
--rw-r--r--   0        0        0     1942 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/content.py
--rw-r--r--   0        0        0    86406 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/marshalling.py
--rw-r--r--   0        0        0    34374 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/__init__.py
--rw-r--r--   0        0        0     1762 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/__init__.py
--rw-r--r--   0        0        0    20761 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/api.py
--rw-r--r--   0        0        0      647 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/content.py
--rw-r--r--   0        0        0     7811 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/marshalling.py
--rw-r--r--   0        0        0     8804 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/function/__init__.py
--rw-r--r--   0        0        0     5864 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/__init__.py
--rw-r--r--   0        0        0    68173 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/api.py
--rw-r--r--   0        0        0     1573 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/content.py
--rw-r--r--   0        0        0    30521 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/marshalling.py
--rw-r--r--   0        0        0    30250 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/iam/__init__.py
--rw-r--r--   0        0        0     5416 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/iam/v1alpha1/__init__.py
--rw-r--r--   0        0        0    80203 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/iam/v1alpha1/api.py
--rw-r--r--   0        0        0    30504 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/iam/v1alpha1/marshalling.py
--rw-r--r--   0        0        0    29209 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/iam/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/instance/__init__.py
--rw-r--r--   0        0        0    13232 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/__init__.py
--rw-r--r--   0        0        0   140578 2023-11-28 15:51:37.616917 scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/api.py
--rw-r--r--   0        0        0     2384 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/content.py
--rw-r--r--   0        0        0   106377 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/marshalling.py
--rw-r--r--   0        0        0    66625 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/types.py
--rw-r--r--   0        0        0    11110 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/types_private.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/iot/__init__.py
--rw-r--r--   0        0        0     5818 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/iot/v1/__init__.py
--rw-r--r--   0        0        0    62067 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/iot/v1/api.py
--rw-r--r--   0        0        0      363 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/iot/v1/content.py
--rw-r--r--   0        0        0    32821 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/iot/v1/marshalling.py
--rw-r--r--   0        0        0    29997 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/iot/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipam/__init__.py
--rw-r--r--   0        0        0      762 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipam/v1/__init__.py
--rw-r--r--   0        0        0    13116 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipam/v1/api.py
--rw-r--r--   0        0        0     4924 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipam/v1/marshalling.py
--rw-r--r--   0        0        0     6040 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipam/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipfs/__init__.py
--rw-r--r--   0        0        0     2572 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/__init__.py
--rw-r--r--   0        0        0    34058 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/api.py
--rw-r--r--   0        0        0      552 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/content.py
--rw-r--r--   0        0        0    12468 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/marshalling.py
--rw-r--r--   0        0        0    11507 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/jobs/__init__.py
--rw-r--r--   0        0        0     1464 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/jobs/v1alpha1/__init__.py
--rw-r--r--   0        0        0    14791 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/jobs/v1alpha1/api.py
--rw-r--r--   0        0        0      401 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/jobs/v1alpha1/content.py
--rw-r--r--   0        0        0     6847 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/jobs/v1alpha1/marshalling.py
--rw-r--r--   0        0        0     4756 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/jobs/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/k8s/__init__.py
--rw-r--r--   0        0        0     5312 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/__init__.py
--rw-r--r--   0        0        0    59308 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/api.py
--rw-r--r--   0        0        0      934 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/content.py
--rw-r--r--   0        0        0    38380 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/marshalling.py
--rw-r--r--   0        0        0    45094 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/types.py
--rw-r--r--   0        0        0      540 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/types_private.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/lb/__init__.py
--rw-r--r--   0        0        0    13054 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/__init__.py
--rw-r--r--   0        0        0   224057 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/api.py
--rw-r--r--   0        0        0     1106 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/content.py
--rw-r--r--   0        0        0    78597 2023-11-28 15:51:37.620916 scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/marshalling.py
--rw-r--r--   0        0        0    88883 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/marketplace/__init__.py
--rw-r--r--   0        0        0      884 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v1/__init__.py
--rw-r--r--   0        0        0     4506 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v1/api.py
--rw-r--r--   0        0        0     6349 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v1/marshalling.py
--rw-r--r--   0        0        0     3014 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v1/types.py
--rw-r--r--   0        0        0     1470 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v2/__init__.py
--rw-r--r--   0        0        0    14533 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v2/api.py
--rw-r--r--   0        0        0     6455 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v2/marshalling.py
--rw-r--r--   0        0        0     5135 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v2/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/mnq/__init__.py
--rw-r--r--   0        0        0     3766 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/mnq/v1beta1/__init__.py
--rw-r--r--   0        0        0    42474 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/mnq/v1beta1/api.py
--rw-r--r--   0        0        0    17117 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/mnq/v1beta1/marshalling.py
--rw-r--r--   0        0        0    16867 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/mnq/v1beta1/types.py
--rw-r--r--   0        0        0        0 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/py.typed
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/qaas/__init__.py
--rw-r--r--   0        0        0     1994 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/qaas/v1alpha1/__init__.py
--rw-r--r--   0        0        0    22085 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/qaas/v1alpha1/api.py
--rw-r--r--   0        0        0      600 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/qaas/v1alpha1/content.py
--rw-r--r--   0        0        0     9768 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/qaas/v1alpha1/marshalling.py
--rw-r--r--   0        0        0     9916 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/qaas/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/rdb/__init__.py
--rw-r--r--   0        0        0    10286 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/__init__.py
--rw-r--r--   0        0        0   118529 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/api.py
--rw-r--r--   0        0        0     1947 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/content.py
--rw-r--r--   0        0        0    54842 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/marshalling.py
--rw-r--r--   0        0        0    47933 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/redis/__init__.py
--rw-r--r--   0        0        0     3760 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/redis/v1/__init__.py
--rw-r--r--   0        0        0    44353 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/redis/v1/api.py
--rw-r--r--   0        0        0      488 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/redis/v1/content.py
--rw-r--r--   0        0        0    21445 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/redis/v1/marshalling.py
--rw-r--r--   0        0        0    17769 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/redis/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/registry/__init__.py
--rw-r--r--   0        0        0     1962 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/__init__.py
--rw-r--r--   0        0        0    29415 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/api.py
--rw-r--r--   0        0        0      710 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/content.py
--rw-r--r--   0        0        0     7883 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/marshalling.py
--rw-r--r--   0        0        0    11276 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/secret/__init__.py
--rw-r--r--   0        0        0     3036 2023-11-28 15:51:37.624916 scaleway_async-2.0.0.dev6/scaleway_async/secret/v1alpha1/__init__.py
--rw-r--r--   0        0        0    50923 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/secret/v1alpha1/api.py
--rw-r--r--   0        0        0    12453 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/secret/v1alpha1/marshalling.py
--rw-r--r--   0        0        0    20064 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/secret/v1alpha1/types.py
--rw-r--r--   0        0        0      194 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/std/__init__.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/std/api.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/std/marshalling.py
--rw-r--r--   0        0        0      469 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/std/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/tem/__init__.py
--rw-r--r--   0        0        0     2370 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/__init__.py
--rw-r--r--   0        0        0    26086 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/api.py
--rw-r--r--   0        0        0      549 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/content.py
--rw-r--r--   0        0        0    14480 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/marshalling.py
--rw-r--r--   0        0        0    15311 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/test/__init__.py
--rw-r--r--   0        0        0     1088 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/test/v1/__init__.py
--rw-r--r--   0        0        0    11702 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/test/v1/api.py
--rw-r--r--   0        0        0      349 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/test/v1/content.py
--rw-r--r--   0        0        0     6143 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/test/v1/marshalling.py
--rw-r--r--   0        0        0     3231 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/test/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/testinternal/__init__.py
--rw-r--r--   0        0        0     5394 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/testinternal/v1/__init__.py
--rw-r--r--   0        0        0    62514 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/testinternal/v1/api.py
--rw-r--r--   0        0        0      373 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/testinternal/v1/content.py
--rw-r--r--   0        0        0    84969 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/testinternal/v1/marshalling.py
--rw-r--r--   0        0        0    23543 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/testinternal/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpc/__init__.py
--rw-r--r--   0        0        0      818 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpc/v1/__init__.py
--rw-r--r--   0        0        0    11822 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpc/v1/api.py
--rw-r--r--   0        0        0     3250 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpc/v1/marshalling.py
--rw-r--r--   0        0        0     4368 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpc/v1/types.py
--rw-r--r--   0        0        0     1864 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpc/v2/__init__.py
--rw-r--r--   0        0        0    29471 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpc/v2/api.py
--rw-r--r--   0        0        0     9990 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpc/v2/marshalling.py
--rw-r--r--   0        0        0    10131 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpc/v2/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/__init__.py
--rw-r--r--   0        0        0     4770 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/__init__.py
--rw-r--r--   0        0        0    80278 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/api.py
--rw-r--r--   0        0        0      754 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/content.py
--rw-r--r--   0        0        0    29413 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/marshalling.py
--rw-r--r--   0        0        0    35147 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/types.py
--rw-r--r--   0        0        0      127 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/webhosting/__init__.py
--rw-r--r--   0        0        0     2128 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/webhosting/v1alpha1/__init__.py
--rw-r--r--   0        0        0    20281 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/webhosting/v1alpha1/api.py
--rw-r--r--   0        0        0      421 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/webhosting/v1alpha1/content.py
--rw-r--r--   0        0        0    12221 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/webhosting/v1alpha1/marshalling.py
--rw-r--r--   0        0        0    12583 2023-11-28 15:51:37.628917 scaleway_async-2.0.0.dev6/scaleway_async/webhosting/v1alpha1/types.py
--rw-r--r--   0        0        0     1121 1970-01-01 00:00:00.000000 scaleway_async-2.0.0.dev6/PKG-INFO
+-rw-r--r--   0        0        0       30 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/README.md
+-rw-r--r--   0        0        0     1118 2024-04-22 08:30:11.953375 scaleway_async-2.1.0/pyproject.toml
+-rw-r--r--   0        0        0      913 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/__init__.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/account/__init__.py
+-rw-r--r--   0        0        0      714 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/account/v2/__init__.py
+-rw-r--r--   0        0        0     8546 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/account/v2/api.py
+-rw-r--r--   0        0        0     2850 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/account/v2/marshalling.py
+-rw-r--r--   0        0        0     2638 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/account/v2/types.py
+-rw-r--r--   0        0        0      828 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/account/v3/__init__.py
+-rw-r--r--   0        0        0     8270 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/account/v3/api.py
+-rw-r--r--   0        0        0     2910 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/account/v3/marshalling.py
+-rw-r--r--   0        0        0     2678 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/account/v3/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/applesilicon/__init__.py
+-rw-r--r--   0        0        0     1674 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/applesilicon/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    18443 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/applesilicon/v1alpha1/api.py
+-rw-r--r--   0        0        0      496 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/applesilicon/v1alpha1/content.py
+-rw-r--r--   0        0        0     7838 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/applesilicon/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0     7171 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/applesilicon/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.637349 scaleway_async-2.1.0/scaleway_async/baremetal/__init__.py
+-rw-r--r--   0        0        0     5338 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/baremetal/v1/__init__.py
+-rw-r--r--   0        0        0    53362 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/baremetal/v1/api.py
+-rw-r--r--   0        0        0     1063 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/baremetal/v1/content.py
+-rw-r--r--   0        0        0    31593 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/baremetal/v1/marshalling.py
+-rw-r--r--   0        0        0    27983 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/baremetal/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/billing/__init__.py
+-rw-r--r--   0        0        0     1414 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/billing/v2alpha1/__init__.py
+-rw-r--r--   0        0        0     9200 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/billing/v2alpha1/api.py
+-rw-r--r--   0        0        0     7732 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/billing/v2alpha1/marshalling.py
+-rw-r--r--   0        0        0     7103 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/billing/v2alpha1/types.py
+-rw-r--r--   0        0        0     2078 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/billing/v2beta1/__init__.py
+-rw-r--r--   0        0        0    19113 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/billing/v2beta1/api.py
+-rw-r--r--   0        0        0    11343 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/billing/v2beta1/marshalling.py
+-rw-r--r--   0        0        0    12804 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/billing/v2beta1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/block/__init__.py
+-rw-r--r--   0        0        0     2316 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/block/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    25374 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/block/v1alpha1/api.py
+-rw-r--r--   0        0        0      922 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/block/v1alpha1/content.py
+-rw-r--r--   0        0        0    12380 2024-04-22 08:29:50.641349 scaleway_async-2.1.0/scaleway_async/block/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    12472 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/block/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/__init__.py
+-rw-r--r--   0        0        0     4656 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/v1/__init__.py
+-rw-r--r--   0        0        0    47472 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/v1/api.py
+-rw-r--r--   0        0        0    20821 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/v1/marshalling.py
+-rw-r--r--   0        0        0    20051 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/v1/types.py
+-rw-r--r--   0        0        0     3758 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/v1beta1/__init__.py
+-rw-r--r--   0        0        0    33854 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/v1beta1/api.py
+-rw-r--r--   0        0        0      418 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/v1beta1/content.py
+-rw-r--r--   0        0        0    21780 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    15330 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/cockpit/v1beta1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/container/__init__.py
+-rw-r--r--   0        0        0     5100 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/container/v1beta1/__init__.py
+-rw-r--r--   0        0        0    64481 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/container/v1beta1/api.py
+-rw-r--r--   0        0        0     1581 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/container/v1beta1/content.py
+-rw-r--r--   0        0        0    27167 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/container/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    27207 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/container/v1beta1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/dedibox/__init__.py
+-rw-r--r--   0        0        0    19280 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/dedibox/v1/__init__.py
+-rw-r--r--   0        0        0   140214 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/dedibox/v1/api.py
+-rw-r--r--   0        0        0     2688 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/dedibox/v1/content.py
+-rw-r--r--   0        0        0    99051 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/dedibox/v1/marshalling.py
+-rw-r--r--   0        0        0    74459 2024-04-22 08:29:50.645349 scaleway_async-2.1.0/scaleway_async/dedibox/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/document_db/__init__.py
+-rw-r--r--   0        0        0     9342 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/__init__.py
+-rw-r--r--   0        0        0   104387 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/api.py
+-rw-r--r--   0        0        0     1614 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/content.py
+-rw-r--r--   0        0        0    52232 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    42675 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/domain/__init__.py
+-rw-r--r--   0        0        0    13096 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/domain/v2beta1/__init__.py
+-rw-r--r--   0        0        0    92043 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/domain/v2beta1/api.py
+-rw-r--r--   0        0        0     1948 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/domain/v2beta1/content.py
+-rw-r--r--   0        0        0    90187 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/domain/v2beta1/marshalling.py
+-rw-r--r--   0        0        0    36143 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/domain/v2beta1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/flexibleip/__init__.py
+-rw-r--r--   0        0        0     1766 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    20763 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/api.py
+-rw-r--r--   0        0        0      649 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/content.py
+-rw-r--r--   0        0        0     8075 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0     8804 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/function/__init__.py
+-rw-r--r--   0        0        0     5594 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/function/v1beta1/__init__.py
+-rw-r--r--   0        0        0    66432 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/function/v1beta1/api.py
+-rw-r--r--   0        0        0     1573 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/function/v1beta1/content.py
+-rw-r--r--   0        0        0    29502 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/function/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    28712 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/function/v1beta1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/iam/__init__.py
+-rw-r--r--   0        0        0     5586 2024-04-22 08:29:50.649349 scaleway_async-2.1.0/scaleway_async/iam/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    85411 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/iam/v1alpha1/api.py
+-rw-r--r--   0        0        0    33530 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/iam/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    30388 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/iam/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/instance/__init__.py
+-rw-r--r--   0        0        0    13930 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/instance/v1/__init__.py
+-rw-r--r--   0        0        0   152660 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/instance/v1/api.py
+-rw-r--r--   0        0        0     2388 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/instance/v1/content.py
+-rw-r--r--   0        0        0   116264 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/instance/v1/marshalling.py
+-rw-r--r--   0        0        0    65118 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/instance/v1/types.py
+-rw-r--r--   0        0        0     6858 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/instance/v1/types_private.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/iot/__init__.py
+-rw-r--r--   0        0        0     5818 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/iot/v1/__init__.py
+-rw-r--r--   0        0        0    62483 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/iot/v1/api.py
+-rw-r--r--   0        0        0      363 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/iot/v1/content.py
+-rw-r--r--   0        0        0    33954 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/iot/v1/marshalling.py
+-rw-r--r--   0        0        0    29997 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/iot/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/ipam/__init__.py
+-rw-r--r--   0        0        0      804 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/ipam/v1/__init__.py
+-rw-r--r--   0        0        0    13672 2024-04-22 08:29:50.653349 scaleway_async-2.1.0/scaleway_async/ipam/v1/api.py
+-rw-r--r--   0        0        0     6042 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/ipam/v1/marshalling.py
+-rw-r--r--   0        0        0     6482 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/ipam/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/ipfs/__init__.py
+-rw-r--r--   0        0        0     2572 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    34058 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/api.py
+-rw-r--r--   0        0        0      552 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/content.py
+-rw-r--r--   0        0        0    12468 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    11507 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/jobs/__init__.py
+-rw-r--r--   0        0        0     1760 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/jobs/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    18654 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/jobs/v1alpha1/api.py
+-rw-r--r--   0        0        0      402 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/jobs/v1alpha1/content.py
+-rw-r--r--   0        0        0    11385 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/jobs/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0     7454 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/jobs/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/k8s/__init__.py
+-rw-r--r--   0        0        0     5344 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/k8s/v1/__init__.py
+-rw-r--r--   0        0        0    58997 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/k8s/v1/api.py
+-rw-r--r--   0        0        0      934 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/k8s/v1/content.py
+-rw-r--r--   0        0        0    40250 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/k8s/v1/marshalling.py
+-rw-r--r--   0        0        0    44725 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/k8s/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/lb/__init__.py
+-rw-r--r--   0        0        0    13124 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/lb/v1/__init__.py
+-rw-r--r--   0        0        0   229464 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/lb/v1/api.py
+-rw-r--r--   0        0        0     1107 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/lb/v1/content.py
+-rw-r--r--   0        0        0    82547 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/lb/v1/marshalling.py
+-rw-r--r--   0        0        0    90467 2024-04-22 08:29:50.657349 scaleway_async-2.1.0/scaleway_async/lb/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/llm_inference/__init__.py
+-rw-r--r--   0        0        0     3026 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/llm_inference/v1beta1/__init__.py
+-rw-r--r--   0        0        0    31941 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/llm_inference/v1beta1/api.py
+-rw-r--r--   0        0        0      443 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/llm_inference/v1beta1/content.py
+-rw-r--r--   0        0        0    17690 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/llm_inference/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    14475 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/llm_inference/v1beta1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/marketplace/__init__.py
+-rw-r--r--   0        0        0     1470 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/marketplace/v2/__init__.py
+-rw-r--r--   0        0        0    15103 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/marketplace/v2/api.py
+-rw-r--r--   0        0        0     6721 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/marketplace/v2/marshalling.py
+-rw-r--r--   0        0        0     5135 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/marketplace/v2/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/mnq/__init__.py
+-rw-r--r--   0        0        0     3766 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/mnq/v1beta1/__init__.py
+-rw-r--r--   0        0        0    42474 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/mnq/v1beta1/api.py
+-rw-r--r--   0        0        0    18048 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/mnq/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    16867 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/mnq/v1beta1/types.py
+-rw-r--r--   0        0        0        0 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/py.typed
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/qaas/__init__.py
+-rw-r--r--   0        0        0     4200 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/qaas/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    43639 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/qaas/v1alpha1/api.py
+-rw-r--r--   0        0        0      843 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/qaas/v1alpha1/content.py
+-rw-r--r--   0        0        0    18882 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/qaas/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    19382 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/qaas/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/rdb/__init__.py
+-rw-r--r--   0        0        0    10564 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/rdb/v1/__init__.py
+-rw-r--r--   0        0        0   121100 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/rdb/v1/api.py
+-rw-r--r--   0        0        0     1950 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/rdb/v1/content.py
+-rw-r--r--   0        0        0    57727 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/rdb/v1/marshalling.py
+-rw-r--r--   0        0        0    48945 2024-04-22 08:29:50.661349 scaleway_async-2.1.0/scaleway_async/rdb/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/redis/__init__.py
+-rw-r--r--   0        0        0     3760 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/redis/v1/__init__.py
+-rw-r--r--   0        0        0    44849 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/redis/v1/api.py
+-rw-r--r--   0        0        0      488 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/redis/v1/content.py
+-rw-r--r--   0        0        0    21935 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/redis/v1/marshalling.py
+-rw-r--r--   0        0        0    17769 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/redis/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/registry/__init__.py
+-rw-r--r--   0        0        0     1962 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/registry/v1/__init__.py
+-rw-r--r--   0        0        0    29615 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/registry/v1/api.py
+-rw-r--r--   0        0        0      710 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/registry/v1/content.py
+-rw-r--r--   0        0        0     8195 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/registry/v1/marshalling.py
+-rw-r--r--   0        0        0    11276 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/registry/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/secret/__init__.py
+-rw-r--r--   0        0        0     3160 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/secret/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    51433 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/secret/v1alpha1/api.py
+-rw-r--r--   0        0        0    15827 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/secret/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    21526 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/secret/v1alpha1/types.py
+-rw-r--r--   0        0        0     3050 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/secret/v1beta1/__init__.py
+-rw-r--r--   0        0        0    36854 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/secret/v1beta1/api.py
+-rw-r--r--   0        0        0    15392 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/secret/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    18709 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/secret/v1beta1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/serverless_sqldb/__init__.py
+-rw-r--r--   0        0        0     1528 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/serverless_sqldb/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    20151 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/serverless_sqldb/v1alpha1/api.py
+-rw-r--r--   0        0        0      427 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/serverless_sqldb/v1alpha1/content.py
+-rw-r--r--   0        0        0     6440 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/serverless_sqldb/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0     8013 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/serverless_sqldb/v1alpha1/types.py
+-rw-r--r--   0        0        0      194 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/std/__init__.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/std/api.py
+-rw-r--r--   0        0        0      129 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/std/marshalling.py
+-rw-r--r--   0        0        0      469 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/std/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.665349 scaleway_async-2.1.0/scaleway_async/tem/__init__.py
+-rw-r--r--   0        0        0     2646 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/tem/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    26329 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/tem/v1alpha1/api.py
+-rw-r--r--   0        0        0      549 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/tem/v1alpha1/content.py
+-rw-r--r--   0        0        0    18144 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/tem/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    16470 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/tem/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/test/__init__.py
+-rw-r--r--   0        0        0     1088 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/test/v1/__init__.py
+-rw-r--r--   0        0        0    11786 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/test/v1/api.py
+-rw-r--r--   0        0        0      349 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/test/v1/content.py
+-rw-r--r--   0        0        0     6231 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/test/v1/marshalling.py
+-rw-r--r--   0        0        0     3231 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/test/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpc/__init__.py
+-rw-r--r--   0        0        0      818 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpc/v1/__init__.py
+-rw-r--r--   0        0        0    11822 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpc/v1/api.py
+-rw-r--r--   0        0        0     3338 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpc/v1/marshalling.py
+-rw-r--r--   0        0        0     4368 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpc/v1/types.py
+-rw-r--r--   0        0        0     1932 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpc/v2/__init__.py
+-rw-r--r--   0        0        0    31296 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpc/v2/api.py
+-rw-r--r--   0        0        0    10469 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpc/v2/marshalling.py
+-rw-r--r--   0        0        0    10678 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpc/v2/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpcgw/__init__.py
+-rw-r--r--   0        0        0     4846 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpcgw/v1/__init__.py
+-rw-r--r--   0        0        0    82023 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpcgw/v1/api.py
+-rw-r--r--   0        0        0      755 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpcgw/v1/content.py
+-rw-r--r--   0        0        0    30617 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpcgw/v1/marshalling.py
+-rw-r--r--   0        0        0    35539 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/vpcgw/v1/types.py
+-rw-r--r--   0        0        0      127 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/webhosting/__init__.py
+-rw-r--r--   0        0        0     2234 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/webhosting/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    21184 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/webhosting/v1alpha1/api.py
+-rw-r--r--   0        0        0      421 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/webhosting/v1alpha1/content.py
+-rw-r--r--   0        0        0    14155 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/webhosting/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    13805 2024-04-22 08:29:50.669349 scaleway_async-2.1.0/scaleway_async/webhosting/v1alpha1/types.py
+-rw-r--r--   0        0        0     1111 1970-01-01 00:00:00.000000 scaleway_async-2.1.0/PKG-INFO
```

### Comparing `scaleway_async-2.0.0.dev6/pyproject.toml` & `scaleway_async-2.1.0/pyproject.toml`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "scaleway-async"
-version = "2.0.0.dev6"
+version = "2.1.0"
 description = "Scaleway SDK for Python"
 authors = ["Scaleway <opensource@scaleway.com>"]
 license = "BSD"
 readme = "README.md"
 classifiers = [
     "Development Status :: 3 - Alpha",
     "Environment :: Console",
@@ -20,21 +20,20 @@
     "Programming Language :: Python :: 3.9",
     "Programming Language :: Python :: 3.10",
     "Topic :: Software Development",
 ]
 
 [tool.poetry.dependencies]
 python = "^3.8"
-scaleway-core = "2.0.0.dev6"
+scaleway-core = "2.1.0"
 
 [tool.poetry.group.dev.dependencies]
 scaleway-core = { path = "../scaleway-core", develop = true }
-ruff = "^0.0.286"
+ruff = ">=0.0.286,<0.3.6"
 mypy = "^1.5.1"
-black = "^23.7.0"
 
 [build-system]
 requires = ["poetry-core"]
 build-backend = "poetry.core.masonry.api"
 
 [tool.ruff]
 ignore = ["E501"]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/__init__.py` & `scaleway_async-2.1.0/scaleway_async/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/account/v2/__init__.py` & `scaleway_async-2.1.0/scaleway_async/account/v2/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/account/v2/api.py` & `scaleway_async-2.1.0/scaleway_async/account/v2/api.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/account/v2/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/account/v2/marshalling.py`

 * *Files 2% similar despite different names*

```diff
@@ -36,18 +36,22 @@
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Project(**args)
 
 
 def unmarshal_ListProjectsResponse(data: Any) -> ListProjectsResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/account/v2/types.py` & `scaleway_async-2.1.0/scaleway_async/account/v2/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/account/v3/__init__.py` & `scaleway_async-2.1.0/scaleway_async/account/v3/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/account/v3/api.py` & `scaleway_async-2.1.0/scaleway_async/account/v3/api.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/account/v3/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/account/v3/marshalling.py`

 * *Files 6% similar despite different names*

```diff
@@ -36,18 +36,22 @@
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Project(**args)
 
 
 def unmarshal_ListProjectsResponse(data: Any) -> ListProjectsResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/account/v3/types.py` & `scaleway_async-2.1.0/scaleway_async/account/v3/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/applesilicon/v1alpha1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/v1alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/applesilicon/v1alpha1/api.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/applesilicon/v1alpha1/marshalling.py`

 * *Files 3% similar despite different names*

```diff
@@ -78,15 +78,15 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("capacity", None)
     if field is not None:
         args["capacity"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     return ServerTypeDisk(**args)
 
 
 def unmarshal_ServerTypeMemory(data: Any) -> ServerTypeMemory:
@@ -97,15 +97,15 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("capacity", None)
     if field is not None:
         args["capacity"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     return ServerTypeMemory(**args)
 
 
 def unmarshal_ServerType(data: Any) -> ServerType:
@@ -123,26 +123,34 @@
     field = data.get("stock", None)
     if field is not None:
         args["stock"] = field
 
     field = data.get("cpu", None)
     if field is not None:
         args["cpu"] = unmarshal_ServerTypeCPU(field)
+    else:
+        args["cpu"] = None
 
     field = data.get("disk", None)
     if field is not None:
         args["disk"] = unmarshal_ServerTypeDisk(field)
+    else:
+        args["disk"] = None
 
     field = data.get("memory", None)
     if field is not None:
         args["memory"] = unmarshal_ServerTypeMemory(field)
+    else:
+        args["memory"] = None
 
     field = data.get("minimum_lease_duration", None)
     if field is not None:
         args["minimum_lease_duration"] = field
+    else:
+        args["minimum_lease_duration"] = None
 
     return ServerType(**args)
 
 
 def unmarshal_Server(data: Any) -> Server:
     if not isinstance(data, dict):
         raise TypeError(
@@ -151,15 +159,15 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
@@ -186,24 +194,30 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("deletable_at", None)
     if field is not None:
         args["deletable_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["deletable_at"] = None
 
     return Server(**args)
 
 
 def unmarshal_ListOSResponse(data: Any) -> ListOSResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/applesilicon/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/applesilicon/v1alpha1/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/baremetal/v1/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,19 +6,19 @@
 from .types import ListServerPrivateNetworksRequestOrderBy
 from .types import ListServersRequestOrderBy
 from .types import ListSettingsRequestOrderBy
 from .types import OfferStock
 from .types import OfferSubscriptionPeriod
 from .types import ServerBootType
 from .types import ServerInstallStatus
-from .content import SERVERINSTALL_TRANSIENT_STATUSES
+from .content import SERVER_INSTALL_TRANSIENT_STATUSES
 from .types import ServerOptionOptionStatus
 from .types import ServerPingStatus
 from .types import ServerPrivateNetworkStatus
-from .content import SERVERPRIVATENETWORK_TRANSIENT_STATUSES
+from .content import SERVER_PRIVATE_NETWORK_TRANSIENT_STATUSES
 from .types import ServerStatus
 from .content import SERVER_TRANSIENT_STATUSES
 from .types import SettingType
 from .types import OSOSField
 from .types import CPU
 from .types import Disk
 from .types import Memory
@@ -86,19 +86,19 @@
     "ListServerPrivateNetworksRequestOrderBy",
     "ListServersRequestOrderBy",
     "ListSettingsRequestOrderBy",
     "OfferStock",
     "OfferSubscriptionPeriod",
     "ServerBootType",
     "ServerInstallStatus",
-    "SERVERINSTALL_TRANSIENT_STATUSES",
+    "SERVER_INSTALL_TRANSIENT_STATUSES",
     "ServerOptionOptionStatus",
     "ServerPingStatus",
     "ServerPrivateNetworkStatus",
-    "SERVERPRIVATENETWORK_TRANSIENT_STATUSES",
+    "SERVER_PRIVATE_NETWORK_TRANSIENT_STATUSES",
     "ServerStatus",
     "SERVER_TRANSIENT_STATUSES",
     "SettingType",
     "OSOSField",
     "CPU",
     "Disk",
     "Memory",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/baremetal/v1/api.py`

 * *Files 1% similar despite different names*

```diff
@@ -288,15 +288,17 @@
         Create an Elastic Metal server.
         Create a new Elastic Metal server. Once the server is created, proceed with the [installation of an OS](#post-3e949e).
         :param offer_id: Offer ID of the new server.
         :param name: Name of the server (≠hostname).
         :param description: Description associated with the server, max 255 characters.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param organization_id: Organization ID with which the server will be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: Project ID with which the server will be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param tags: Tags to associate to the server.
         :param install: Object describing the configuration details of the OS installation on the server.
         :param option_ids: IDs of options to enable on server.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
@@ -1398,15 +1400,14 @@
         *,
         server_id: str,
         private_network_id: str,
         zone: Optional[Zone] = None,
     ) -> ServerPrivateNetwork:
         """
         Add a server to a Private Network.
-        Add a server to a Private Network.
         :param server_id: The ID of the server.
         :param private_network_id: The ID of the Private Network.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :return: :class:`ServerPrivateNetwork <ServerPrivateNetwork>`
 
         Usage:
         ::
@@ -1441,15 +1442,14 @@
         *,
         server_id: str,
         private_network_ids: List[str],
         zone: Optional[Zone] = None,
     ) -> SetServerPrivateNetworksResponse:
         """
         Set multiple Private Networks on a server.
-        Set multiple Private Networks on a server.
         :param server_id: The ID of the server.
         :param private_network_ids: The IDs of the Private Networks.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :return: :class:`SetServerPrivateNetworksResponse <SetServerPrivateNetworksResponse>`
 
         Usage:
         ::
@@ -1489,15 +1489,14 @@
         server_id: Optional[str] = None,
         private_network_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListServerPrivateNetworksResponse:
         """
         List the Private Networks of a server.
-        List the Private Networks of a server.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: The sort order for the returned Private Networks.
         :param page: The page number for the returned Private Networks.
         :param page_size: The maximum number of Private Networks per page.
         :param server_id: Filter Private Networks by server ID.
         :param private_network_id: Filter Private Networks by Private Network ID.
         :param organization_id: Filter Private Networks by Organization ID.
@@ -1540,15 +1539,14 @@
         server_id: Optional[str] = None,
         private_network_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[ServerPrivateNetwork]:
         """
         List the Private Networks of a server.
-        List the Private Networks of a server.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: The sort order for the returned Private Networks.
         :param page: The page number for the returned Private Networks.
         :param page_size: The maximum number of Private Networks per page.
         :param server_id: Filter Private Networks by server ID.
         :param private_network_id: Filter Private Networks by Private Network ID.
         :param organization_id: Filter Private Networks by Organization ID.
@@ -1582,15 +1580,14 @@
         *,
         server_id: str,
         private_network_id: str,
         zone: Optional[Zone] = None,
     ) -> None:
         """
         Delete a Private Network.
-        Delete a Private Network.
         :param server_id: The ID of the server.
         :param private_network_id: The ID of the Private Network.
         :param zone: Zone to target. If none is passed will use default zone from the config.
 
         Usage:
         ::
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/content.py` & `scaleway_async-2.1.0/scaleway_async/baremetal/v1/content.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,22 +4,22 @@
 
 from .types import (
     ServerInstallStatus,
     ServerPrivateNetworkStatus,
     ServerStatus,
 )
 
-SERVERINSTALL_TRANSIENT_STATUSES: List[ServerInstallStatus] = [
+SERVER_INSTALL_TRANSIENT_STATUSES: List[ServerInstallStatus] = [
     ServerInstallStatus.TO_INSTALL,
     ServerInstallStatus.INSTALLING,
 ]
 """
 Lists transient statutes of the enum :class:`ServerInstallStatus <ServerInstallStatus>`.
 """
-SERVERPRIVATENETWORK_TRANSIENT_STATUSES: List[ServerPrivateNetworkStatus] = [
+SERVER_PRIVATE_NETWORK_TRANSIENT_STATUSES: List[ServerPrivateNetworkStatus] = [
     ServerPrivateNetworkStatus.ATTACHING,
     ServerPrivateNetworkStatus.DETACHING,
 ]
 """
 Lists transient statutes of the enum :class:`ServerPrivateNetworkStatus <ServerPrivateNetworkStatus>`.
 """
 SERVER_TRANSIENT_STATUSES: List[ServerStatus] = [
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/baremetal/v1/marshalling.py`

 * *Files 8% similar despite different names*

```diff
@@ -107,14 +107,16 @@
     field = data.get("required", None)
     if field is not None:
         args["required"] = field
 
     field = data.get("default_value", None)
     if field is not None:
         args["default_value"] = field
+    else:
+        args["default_value"] = None
 
     return OSOSField(**args)
 
 
 def unmarshal_OS(data: Any) -> OS:
     if not isinstance(data, dict):
         raise TypeError(
@@ -150,30 +152,40 @@
     field = data.get("allowed", None)
     if field is not None:
         args["allowed"] = field
 
     field = data.get("ssh", None)
     if field is not None:
         args["ssh"] = unmarshal_OSOSField(field)
+    else:
+        args["ssh"] = None
 
     field = data.get("user", None)
     if field is not None:
         args["user"] = unmarshal_OSOSField(field)
+    else:
+        args["user"] = None
 
     field = data.get("password", None)
     if field is not None:
         args["password"] = unmarshal_OSOSField(field)
+    else:
+        args["password"] = None
 
     field = data.get("service_user", None)
     if field is not None:
         args["service_user"] = unmarshal_OSOSField(field)
+    else:
+        args["service_user"] = None
 
     field = data.get("service_password", None)
     if field is not None:
         args["service_password"] = unmarshal_OSOSField(field)
+    else:
+        args["service_password"] = None
 
     return OS(**args)
 
 
 def unmarshal_CPU(data: Any) -> CPU:
     if not isinstance(data, dict):
         raise TypeError(
@@ -213,15 +225,15 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("capacity", None)
     if field is not None:
         args["capacity"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     return Disk(**args)
 
 
 def unmarshal_Memory(data: Any) -> Memory:
@@ -232,15 +244,15 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("capacity", None)
     if field is not None:
         args["capacity"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("frequency", None)
     if field is not None:
         args["frequency"] = field
 
@@ -278,18 +290,22 @@
     field = data.get("manageable", None)
     if field is not None:
         args["manageable"] = field
 
     field = data.get("price", None)
     if field is not None:
         args["price"] = unmarshal_Money(field)
+    else:
+        args["price"] = None
 
     field = data.get("os_id", None)
     if field is not None:
         args["os_id"] = field
+    else:
+        args["os_id"] = None
 
     return OfferOptionOffer(**args)
 
 
 def unmarshal_PersistentMemory(data: Any) -> PersistentMemory:
     if not isinstance(data, dict):
         raise TypeError(
@@ -298,15 +314,15 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("capacity", None)
     if field is not None:
         args["capacity"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("frequency", None)
     if field is not None:
         args["frequency"] = field
 
@@ -369,18 +385,22 @@
     field = data.get("enable", None)
     if field is not None:
         args["enable"] = field
 
     field = data.get("price_per_hour", None)
     if field is not None:
         args["price_per_hour"] = unmarshal_Money(field)
+    else:
+        args["price_per_hour"] = None
 
     field = data.get("price_per_month", None)
     if field is not None:
         args["price_per_month"] = unmarshal_Money(field)
+    else:
+        args["price_per_month"] = None
 
     field = data.get("cpus", None)
     if field is not None:
         args["cpus"] = [unmarshal_CPU(v) for v in field] if field is not None else None
 
     field = data.get("memories", None)
     if field is not None:
@@ -437,14 +457,16 @@
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("fee", None)
     if field is not None:
         args["fee"] = unmarshal_Money(field)
+    else:
+        args["fee"] = None
 
     return Offer(**args)
 
 
 def unmarshal_Option(data: Any) -> Option:
     if not isinstance(data, dict):
         raise TypeError(
@@ -495,22 +517,28 @@
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("vlan", None)
     if field is not None:
         args["vlan"] = field
+    else:
+        args["vlan"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return ServerPrivateNetwork(**args)
 
 
 def unmarshal_ServerInstall(data: Any) -> ServerInstall:
     if not isinstance(data, dict):
         raise TypeError(
@@ -573,14 +601,16 @@
     field = data.get("manageable", None)
     if field is not None:
         args["manageable"] = field
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     return ServerOption(**args)
 
 
 def unmarshal_ServerRescueServer(data: Any) -> ServerRescueServer:
     if not isinstance(data, dict):
         raise TypeError(
@@ -631,18 +661,22 @@
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("offer_id", None)
     if field is not None:
         args["offer_id"] = field
 
     field = data.get("offer_name", None)
     if field is not None:
@@ -677,18 +711,22 @@
         args["options"] = (
             [unmarshal_ServerOption(v) for v in field] if field is not None else None
         )
 
     field = data.get("install", None)
     if field is not None:
         args["install"] = unmarshal_ServerInstall(field)
+    else:
+        args["install"] = None
 
     field = data.get("rescue_server", None)
     if field is not None:
         args["rescue_server"] = unmarshal_ServerRescueServer(field)
+    else:
+        args["rescue_server"] = None
 
     return Server(**args)
 
 
 def unmarshal_Setting(data: Any) -> Setting:
     if not isinstance(data, dict):
         raise TypeError(
@@ -697,15 +735,15 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("project_id", None)
     if field is not None:
         args["project_id"] = field
 
@@ -735,14 +773,16 @@
     field = data.get("password", None)
     if field is not None:
         args["password"] = field
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     return BMCAccess(**args)
 
 
 def unmarshal_GetServerMetricsResponse(data: Any) -> GetServerMetricsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -750,14 +790,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("pings", None)
     if field is not None:
         args["pings"] = unmarshal_TimeSeries(field)
+    else:
+        args["pings"] = None
 
     return GetServerMetricsResponse(**args)
 
 
 def unmarshal_ListOSResponse(data: Any) -> ListOSResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -834,18 +876,22 @@
     field = data.get("action", None)
     if field is not None:
         args["action"] = field
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return ServerEvent(**args)
 
 
 def unmarshal_ListServerEventsResponse(data: Any) -> ListServerEventsResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/baremetal/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/baremetal/v1/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/billing/v2alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/billing/v2alpha1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/billing/v2alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/billing/v2alpha1/api.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/billing/v2alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/billing/v2alpha1/marshalling.py`

 * *Files 9% similar despite different names*

```diff
@@ -44,14 +44,16 @@
     field = data.get("operation_path", None)
     if field is not None:
         args["operation_path"] = field
 
     field = data.get("value", None)
     if field is not None:
         args["value"] = unmarshal_Money(field)
+    else:
+        args["value"] = None
 
     return GetConsumptionResponseConsumption(**args)
 
 
 def unmarshal_GetConsumptionResponse(data: Any) -> GetConsumptionResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -67,14 +69,16 @@
             if field is not None
             else None
         )
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return GetConsumptionResponse(**args)
 
 
 def unmarshal_DiscountCoupon(data: Any) -> DiscountCoupon:
     if not isinstance(data, dict):
         raise TypeError(
@@ -82,27 +86,29 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
+    else:
+        args["description"] = None
 
     return DiscountCoupon(**args)
 
 
 def unmarshal_DiscountFilter(data: Any) -> DiscountFilter:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'DiscountFilter' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("value", None)
     if field is not None:
         args["value"] = field
 
@@ -152,26 +158,34 @@
         )
 
     field = data.get("creation_date", None)
     if field is not None:
         args["creation_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["creation_date"] = None
 
     field = data.get("start_date", None)
     if field is not None:
         args["start_date"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["start_date"] = None
 
     field = data.get("stop_date", None)
     if field is not None:
         args["stop_date"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["stop_date"] = None
 
     field = data.get("coupon", None)
     if field is not None:
         args["coupon"] = unmarshal_DiscountCoupon(field)
+    else:
+        args["coupon"] = None
 
     return Discount(**args)
 
 
 def unmarshal_ListDiscountsResponse(data: Any) -> ListDiscountsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -212,32 +226,42 @@
     field = data.get("number", None)
     if field is not None:
         args["number"] = field
 
     field = data.get("start_date", None)
     if field is not None:
         args["start_date"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["start_date"] = None
 
     field = data.get("issued_date", None)
     if field is not None:
         args["issued_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["issued_date"] = None
 
     field = data.get("due_date", None)
     if field is not None:
         args["due_date"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["due_date"] = None
 
     field = data.get("total_untaxed", None)
     if field is not None:
         args["total_untaxed"] = unmarshal_Money(field)
+    else:
+        args["total_untaxed"] = None
 
     field = data.get("total_taxed", None)
     if field is not None:
         args["total_taxed"] = unmarshal_Money(field)
+    else:
+        args["total_taxed"] = None
 
     return Invoice(**args)
 
 
 def unmarshal_ListInvoicesResponse(data: Any) -> ListInvoicesResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/billing/v2alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/billing/v2alpha1/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/block/v1alpha1/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,36 +6,34 @@
 from .content import REFERENCE_TRANSIENT_STATUSES
 from .types import ReferenceType
 from .types import SnapshotStatus
 from .content import SNAPSHOT_TRANSIENT_STATUSES
 from .types import StorageClass
 from .types import VolumeStatus
 from .content import VOLUME_TRANSIENT_STATUSES
+from .types import Reference
 from .types import SnapshotParentVolume
 from .types import VolumeSpecifications
-from .types import Reference
 from .types import CreateVolumeRequestFromEmpty
 from .types import CreateVolumeRequestFromSnapshot
-from .types import SnapshotSummary
+from .types import Snapshot
 from .types import VolumeType
 from .types import Volume
 from .types import CreateSnapshotRequest
 from .types import CreateVolumeRequest
 from .types import DeleteSnapshotRequest
 from .types import DeleteVolumeRequest
 from .types import GetSnapshotRequest
 from .types import GetVolumeRequest
-from .types import ImportSnapshotFromS3Request
 from .types import ListSnapshotsRequest
 from .types import ListSnapshotsResponse
 from .types import ListVolumeTypesRequest
 from .types import ListVolumeTypesResponse
 from .types import ListVolumesRequest
 from .types import ListVolumesResponse
-from .types import Snapshot
 from .types import UpdateSnapshotRequest
 from .types import UpdateVolumeRequest
 from .api import BlockV1Alpha1API
 
 __all__ = [
     "ListSnapshotsRequestOrderBy",
     "ListVolumesRequestOrderBy",
@@ -43,33 +41,31 @@
     "REFERENCE_TRANSIENT_STATUSES",
     "ReferenceType",
     "SnapshotStatus",
     "SNAPSHOT_TRANSIENT_STATUSES",
     "StorageClass",
     "VolumeStatus",
     "VOLUME_TRANSIENT_STATUSES",
+    "Reference",
     "SnapshotParentVolume",
     "VolumeSpecifications",
-    "Reference",
     "CreateVolumeRequestFromEmpty",
     "CreateVolumeRequestFromSnapshot",
-    "SnapshotSummary",
+    "Snapshot",
     "VolumeType",
     "Volume",
     "CreateSnapshotRequest",
     "CreateVolumeRequest",
     "DeleteSnapshotRequest",
     "DeleteVolumeRequest",
     "GetSnapshotRequest",
     "GetVolumeRequest",
-    "ImportSnapshotFromS3Request",
     "ListSnapshotsRequest",
     "ListSnapshotsResponse",
     "ListVolumeTypesRequest",
     "ListVolumeTypesResponse",
     "ListVolumesRequest",
     "ListVolumesResponse",
-    "Snapshot",
     "UpdateSnapshotRequest",
     "UpdateVolumeRequest",
     "BlockV1Alpha1API",
 ]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/block/v1alpha1/api.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,38 +16,35 @@
 from .types import (
     ListSnapshotsRequestOrderBy,
     ListVolumesRequestOrderBy,
     CreateSnapshotRequest,
     CreateVolumeRequest,
     CreateVolumeRequestFromEmpty,
     CreateVolumeRequestFromSnapshot,
-    ImportSnapshotFromS3Request,
     ListSnapshotsResponse,
     ListVolumeTypesResponse,
     ListVolumesResponse,
     Snapshot,
-    SnapshotSummary,
     UpdateSnapshotRequest,
     UpdateVolumeRequest,
     Volume,
     VolumeType,
 )
 from .content import (
     SNAPSHOT_TRANSIENT_STATUSES,
     VOLUME_TRANSIENT_STATUSES,
 )
 from .marshalling import (
+    unmarshal_Snapshot,
     unmarshal_Volume,
     unmarshal_ListSnapshotsResponse,
     unmarshal_ListVolumeTypesResponse,
     unmarshal_ListVolumesResponse,
-    unmarshal_Snapshot,
     marshal_CreateSnapshotRequest,
     marshal_CreateVolumeRequest,
-    marshal_ImportSnapshotFromS3Request,
     marshal_UpdateSnapshotRequest,
     marshal_UpdateVolumeRequest,
 )
 
 
 class BlockV1Alpha1API(API):
     """
@@ -233,17 +230,20 @@
         """
         Create a volume.
         To create a new volume from scratch, you must specify `from_empty` and the `size`.
         To create a volume from an existing snapshot, specify `from_snapshot` and the `snapshot_id` in the request payload instead, size is optional and can be specified if you need to extend the original size. The volume will take on the same volume class and underlying IOPS limitations as the original snapshot.
         :param name: Name of the volume.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param perf_iops: The maximum IO/s expected, according to the different options available in stock (`5000 | 15000`).
+        One-Of ('requirements'): at most one of 'perf_iops' could be set.
         :param project_id: UUID of the project the volume belongs to.
         :param from_empty: Specify the size of the new volume if creating a new one from scratch.
+        One-Of ('from'): at most one of 'from_empty', 'from_snapshot' could be set.
         :param from_snapshot: Specify the snapshot ID of the original snapshot.
+        One-Of ('from'): at most one of 'from_empty', 'from_snapshot' could be set.
         :param tags: List of tags assigned to the volume.
         :return: :class:`Volume <Volume>`
 
         Usage:
         ::
 
             result = await api.create_volume(
@@ -483,27 +483,27 @@
         order_by: Optional[ListSnapshotsRequestOrderBy] = None,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         volume_id: Optional[str] = None,
         name: Optional[str] = None,
-    ) -> List[SnapshotSummary]:
+    ) -> List[Snapshot]:
         """
         List all snapshots.
         List all available snapshots in a specified zone. By default, the snapshots listed are ordered by creation date in ascending order. This can be modified via the `order_by` field.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Criteria to use when ordering the list.
         :param project_id: Filter by Project ID.
         :param organization_id: Filter by Organization ID.
         :param page: Page number.
         :param page_size: Page size, defines how many entries are returned in one page, must be lower or equal to 100.
         :param volume_id: Filter snapshots by the ID of the original volume.
         :param name: Filter snapshots by their names.
-        :return: :class:`List[SnapshotSummary] <List[SnapshotSummary]>`
+        :return: :class:`List[Snapshot] <List[Snapshot]>`
 
         Usage:
         ::
 
             result = await api.list_snapshots_all()
         """
 
@@ -634,64 +634,14 @@
                     name=name,
                     zone=zone,
                     project_id=project_id,
                     tags=tags,
                 ),
                 self.client,
             ),
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_Snapshot(res.json())
-
-    async def import_snapshot_from_s3(
-        self,
-        *,
-        bucket: str,
-        key: str,
-        name: str,
-        zone: Optional[Zone] = None,
-        project_id: Optional[str] = None,
-        tags: Optional[List[str]] = None,
-    ) -> Snapshot:
-        """
-        :param bucket:
-        :param key:
-        :param name:
-        :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param project_id:
-        :param tags:
-        :return: :class:`Snapshot <Snapshot>`
-
-        Usage:
-        ::
-
-            result = await api.import_snapshot_from_s3(
-                bucket="example",
-                key="example",
-                name="example",
-            )
-        """
-
-        param_zone = validate_path_param("zone", zone or self.client.default_zone)
-
-        res = self._request(
-            "POST",
-            f"/block/v1alpha1/zones/{param_zone}/snapshots/import-from-s3",
-            body=marshal_ImportSnapshotFromS3Request(
-                ImportSnapshotFromS3Request(
-                    bucket=bucket,
-                    key=key,
-                    name=name,
-                    zone=zone,
-                    project_id=project_id,
-                    tags=tags,
-                ),
-                self.client,
-            ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Snapshot(res.json())
 
     async def delete_snapshot(
         self,
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/content.py` & `scaleway_async-2.1.0/scaleway_async/block/v1alpha1/content.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,15 +7,15 @@
     SnapshotStatus,
     VolumeStatus,
 )
 
 REFERENCE_TRANSIENT_STATUSES: List[ReferenceStatus] = [
     ReferenceStatus.ATTACHING,
     ReferenceStatus.DETACHING,
-    ReferenceStatus.SNAPSHOTTING,
+    ReferenceStatus.CREATING,
 ]
 """
 Lists transient statutes of the enum :class:`ReferenceStatus <ReferenceStatus>`.
 """
 SNAPSHOT_TRANSIENT_STATUSES: List[SnapshotStatus] = [
     SnapshotStatus.CREATING,
     SnapshotStatus.DELETING,
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/marshalling.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,316 +1,316 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 from dateutil import parser
 
 from scaleway_core.profile import ProfileDefaults
-from scaleway_core.bridge import (
-    unmarshal_Money,
-)
-from scaleway_core.utils import (
-    OneOfPossibility,
-    resolve_one_of,
-)
 from .types import (
-    Reference,
-    VolumeSpecifications,
+    Name,
+    PinCIDMeta,
+    PinCID,
+    PinInfo,
+    Pin,
     Volume,
-    SnapshotParentVolume,
-    SnapshotSummary,
-    ListSnapshotsResponse,
-    VolumeType,
-    ListVolumeTypesResponse,
+    ExportKeyNameResponse,
+    ListNamesResponse,
+    ListPinsResponse,
     ListVolumesResponse,
-    Snapshot,
-    CreateSnapshotRequest,
-    CreateVolumeRequestFromEmpty,
-    CreateVolumeRequestFromSnapshot,
+    ReplacePinResponse,
+    CreatePinByCIDRequest,
+    CreatePinByURLRequest,
     CreateVolumeRequest,
-    ImportSnapshotFromS3Request,
-    UpdateSnapshotRequest,
+    IpnsApiCreateNameRequest,
+    IpnsApiImportKeyNameRequest,
+    IpnsApiUpdateNameRequest,
+    ReplacePinRequest,
     UpdateVolumeRequest,
 )
 
 
-def unmarshal_Reference(data: Any) -> Reference:
+def unmarshal_Name(data: Any) -> Name:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Reference' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Name' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id", None)
+    field = data.get("name_id", None)
     if field is not None:
-        args["id"] = field
+        args["name_id"] = field
 
-    field = data.get("product_resource_type", None)
+    field = data.get("project_id", None)
     if field is not None:
-        args["product_resource_type"] = field
+        args["project_id"] = field
 
-    field = data.get("product_resource_id", None)
+    field = data.get("tags", None)
     if field is not None:
-        args["product_resource_id"] = field
+        args["tags"] = field
+
+    field = data.get("name", None)
+    if field is not None:
+        args["name"] = field
 
-    field = data.get("type_", None)
+    field = data.get("key", None)
     if field is not None:
-        args["type_"] = field
+        args["key"] = field
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
+    field = data.get("value", None)
+    if field is not None:
+        args["value"] = field
+
+    field = data.get("region", None)
+    if field is not None:
+        args["region"] = field
+
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
 
-    return Reference(**args)
+    field = data.get("updated_at", None)
+    if field is not None:
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+
+    return Name(**args)
 
 
-def unmarshal_VolumeSpecifications(data: Any) -> VolumeSpecifications:
+def unmarshal_PinCIDMeta(data: Any) -> PinCIDMeta:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'VolumeSpecifications' failed as data isn't a dictionary."
+            "Unmarshalling the type 'PinCIDMeta' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("class_", None)
-    if field is not None:
-        args["class_"] = field
-
-    field = data.get("perf_iops", None)
+    field = data.get("id", None)
     if field is not None:
-        args["perf_iops"] = field
+        args["id"] = field
 
-    return VolumeSpecifications(**args)
+    return PinCIDMeta(**args)
 
 
-def unmarshal_Volume(data: Any) -> Volume:
+def unmarshal_PinCID(data: Any) -> PinCID:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Volume' failed as data isn't a dictionary."
+            "Unmarshalling the type 'PinCID' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id", None)
+    field = data.get("origins", None)
     if field is not None:
-        args["id"] = field
+        args["origins"] = field
+
+    field = data.get("cid", None)
+    if field is not None:
+        args["cid"] = field
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
-    field = data.get("type_", None)
+    field = data.get("meta", None)
     if field is not None:
-        args["type_"] = field
+        args["meta"] = unmarshal_PinCIDMeta(field)
 
-    field = data.get("size", None)
-    if field is not None:
-        args["size"] = field
+    return PinCID(**args)
 
-    field = data.get("project_id", None)
-    if field is not None:
-        args["project_id"] = field
 
-    field = data.get("references", None)
-    if field is not None:
-        args["references"] = (
-            [unmarshal_Reference(v) for v in field] if field is not None else None
+def unmarshal_PinInfo(data: Any) -> PinInfo:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'PinInfo' failed as data isn't a dictionary."
         )
 
-    field = data.get("created_at", None)
-    if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("updated_at", None)
-    if field is not None:
-        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("parent_snapshot_id", None)
-    if field is not None:
-        args["parent_snapshot_id"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("status", None)
+    field = data.get("status_details", None)
     if field is not None:
-        args["status"] = field
+        args["status_details"] = field
 
-    field = data.get("tags", None)
+    field = data.get("id", None)
     if field is not None:
-        args["tags"] = field
+        args["id"] = field
 
-    field = data.get("zone", None)
+    field = data.get("url", None)
     if field is not None:
-        args["zone"] = field
+        args["url"] = field
 
-    field = data.get("specs", None)
+    field = data.get("size", None)
     if field is not None:
-        args["specs"] = unmarshal_VolumeSpecifications(field)
+        args["size"] = field
 
-    field = data.get("last_detached_at", None)
+    field = data.get("progress", None)
     if field is not None:
-        args["last_detached_at"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["progress"] = field
 
-    return Volume(**args)
+    return PinInfo(**args)
 
 
-def unmarshal_SnapshotParentVolume(data: Any) -> SnapshotParentVolume:
+def unmarshal_Pin(data: Any) -> Pin:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'SnapshotParentVolume' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Pin' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id", None)
+    field = data.get("pin_id", None)
     if field is not None:
-        args["id"] = field
+        args["pin_id"] = field
 
-    field = data.get("name", None)
+    field = data.get("status", None)
     if field is not None:
-        args["name"] = field
+        args["status"] = field
 
-    field = data.get("type_", None)
+    field = data.get("delegates", None)
     if field is not None:
-        args["type_"] = field
+        args["delegates"] = field
 
-    field = data.get("status", None)
+    field = data.get("created_at", None)
     if field is not None:
-        args["status"] = field
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
 
-    return SnapshotParentVolume(**args)
+    field = data.get("cid", None)
+    if field is not None:
+        args["cid"] = unmarshal_PinCID(field)
+
+    field = data.get("info", None)
+    if field is not None:
+        args["info"] = unmarshal_PinInfo(field)
 
+    return Pin(**args)
 
-def unmarshal_SnapshotSummary(data: Any) -> SnapshotSummary:
+
+def unmarshal_Volume(data: Any) -> Volume:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'SnapshotSummary' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Volume' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
-    field = data.get("size", None)
-    if field is not None:
-        args["size"] = field
-
     field = data.get("project_id", None)
     if field is not None:
         args["project_id"] = field
 
-    field = data.get("status", None)
+    field = data.get("region", None)
     if field is not None:
-        args["status"] = field
+        args["region"] = field
 
-    field = data.get("tags", None)
-    if field is not None:
-        args["tags"] = field
-
-    field = data.get("zone", None)
+    field = data.get("count_pin", None)
     if field is not None:
-        args["zone"] = field
+        args["count_pin"] = field
 
-    field = data.get("class_", None)
+    field = data.get("tags", None)
     if field is not None:
-        args["class_"] = field
+        args["tags"] = field
 
-    field = data.get("parent_volume", None)
+    field = data.get("name", None)
     if field is not None:
-        args["parent_volume"] = unmarshal_SnapshotParentVolume(field)
+        args["name"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
 
-    return SnapshotSummary(**args)
+    field = data.get("size", None)
+    if field is not None:
+        args["size"] = field
+
+    return Volume(**args)
 
 
-def unmarshal_ListSnapshotsResponse(data: Any) -> ListSnapshotsResponse:
+def unmarshal_ExportKeyNameResponse(data: Any) -> ExportKeyNameResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListSnapshotsResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ExportKeyNameResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("snapshots", None)
+    field = data.get("name_id", None)
     if field is not None:
-        args["snapshots"] = (
-            [unmarshal_SnapshotSummary(v) for v in field] if field is not None else None
-        )
+        args["name_id"] = field
 
-    field = data.get("total_count", None)
+    field = data.get("project_id", None)
     if field is not None:
-        args["total_count"] = field
+        args["project_id"] = field
 
-    return ListSnapshotsResponse(**args)
+    field = data.get("public_key", None)
+    if field is not None:
+        args["public_key"] = field
 
+    field = data.get("private_key", None)
+    if field is not None:
+        args["private_key"] = field
 
-def unmarshal_VolumeType(data: Any) -> VolumeType:
+    field = data.get("created_at", None)
+    if field is not None:
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+
+    field = data.get("updated_at", None)
+    if field is not None:
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+
+    return ExportKeyNameResponse(**args)
+
+
+def unmarshal_ListNamesResponse(data: Any) -> ListNamesResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'VolumeType' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListNamesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
-    if field is not None:
-        args["type_"] = field
-
-    field = data.get("pricing", None)
+    field = data.get("names", None)
     if field is not None:
-        args["pricing"] = unmarshal_Money(field)
-
-    field = data.get("snapshot_pricing", None)
-    if field is not None:
-        args["snapshot_pricing"] = unmarshal_Money(field)
+        args["names"] = (
+            [unmarshal_Name(v) for v in field] if field is not None else None
+        )
 
-    field = data.get("specs", None)
+    field = data.get("total_count", None)
     if field is not None:
-        args["specs"] = unmarshal_VolumeSpecifications(field)
+        args["total_count"] = field
 
-    return VolumeType(**args)
+    return ListNamesResponse(**args)
 
 
-def unmarshal_ListVolumeTypesResponse(data: Any) -> ListVolumeTypesResponse:
+def unmarshal_ListPinsResponse(data: Any) -> ListPinsResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListVolumeTypesResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListPinsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("volume_types", None)
-    if field is not None:
-        args["volume_types"] = (
-            [unmarshal_VolumeType(v) for v in field] if field is not None else None
-        )
-
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    return ListVolumeTypesResponse(**args)
+    field = data.get("pins", None)
+    if field is not None:
+        args["pins"] = [unmarshal_Pin(v) for v in field] if field is not None else None
+
+    return ListPinsResponse(**args)
 
 
 def unmarshal_ListVolumesResponse(data: Any) -> ListVolumesResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ListVolumesResponse' failed as data isn't a dictionary."
         )
@@ -326,207 +326,167 @@
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
     return ListVolumesResponse(**args)
 
 
-def unmarshal_Snapshot(data: Any) -> Snapshot:
+def unmarshal_ReplacePinResponse(data: Any) -> ReplacePinResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Snapshot' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ReplacePinResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id", None)
-    if field is not None:
-        args["id"] = field
-
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
-    field = data.get("size", None)
-    if field is not None:
-        args["size"] = field
-
-    field = data.get("project_id", None)
-    if field is not None:
-        args["project_id"] = field
-
-    field = data.get("references", None)
+    field = data.get("pin", None)
     if field is not None:
-        args["references"] = (
-            [unmarshal_Reference(v) for v in field] if field is not None else None
-        )
+        args["pin"] = unmarshal_Pin(field)
 
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
+    return ReplacePinResponse(**args)
 
-    field = data.get("tags", None)
-    if field is not None:
-        args["tags"] = field
 
-    field = data.get("zone", None)
-    if field is not None:
-        args["zone"] = field
+def marshal_CreatePinByCIDRequest(
+    request: CreatePinByCIDRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("class_", None)
-    if field is not None:
-        args["class_"] = field
+    if request.volume_id is not None:
+        output["volume_id"] = request.volume_id
 
-    field = data.get("parent_volume", None)
-    if field is not None:
-        args["parent_volume"] = unmarshal_SnapshotParentVolume(field)
+    if request.cid is not None:
+        output["cid"] = request.cid
 
-    field = data.get("created_at", None)
-    if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    if request.origins is not None:
+        output["origins"] = request.origins
 
-    field = data.get("updated_at", None)
-    if field is not None:
-        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    if request.name is not None:
+        output["name"] = request.name
 
-    return Snapshot(**args)
+    return output
 
 
-def marshal_CreateSnapshotRequest(
-    request: CreateSnapshotRequest,
+def marshal_CreatePinByURLRequest(
+    request: CreatePinByURLRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.volume_id is not None:
         output["volume_id"] = request.volume_id
 
+    if request.url is not None:
+        output["url"] = request.url
+
     if request.name is not None:
         output["name"] = request.name
 
-    if request.project_id is not None:
-        output["project_id"] = request.project_id or defaults.default_project_id
-
-    if request.tags is not None:
-        output["tags"] = request.tags
-
     return output
 
 
-def marshal_CreateVolumeRequestFromEmpty(
-    request: CreateVolumeRequestFromEmpty,
+def marshal_CreateVolumeRequest(
+    request: CreateVolumeRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.size is not None:
-        output["size"] = request.size
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
 
     return output
 
 
-def marshal_CreateVolumeRequestFromSnapshot(
-    request: CreateVolumeRequestFromSnapshot,
+def marshal_IpnsApiCreateNameRequest(
+    request: IpnsApiCreateNameRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.snapshot_id is not None:
-        output["snapshot_id"] = request.snapshot_id
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.value is not None:
+        output["value"] = request.value
 
-    if request.size is not None:
-        output["size"] = request.size
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
 
     return output
 
 
-def marshal_CreateVolumeRequest(
-    request: CreateVolumeRequest,
+def marshal_IpnsApiImportKeyNameRequest(
+    request: IpnsApiImportKeyNameRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
-    output.update(
-        resolve_one_of(
-            [
-                OneOfPossibility("from_empty", request.from_empty),
-                OneOfPossibility("from_snapshot", request.from_snapshot),
-            ]
-        ),
-    )
-    output.update(
-        resolve_one_of(
-            [
-                OneOfPossibility("perf_iops", request.perf_iops),
-            ]
-        ),
-    )
 
     if request.name is not None:
         output["name"] = request.name
 
+    if request.private_key is not None:
+        output["private_key"] = request.private_key
+
+    if request.value is not None:
+        output["value"] = request.value
+
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
-    if request.tags is not None:
-        output["tags"] = request.tags
-
     return output
 
 
-def marshal_ImportSnapshotFromS3Request(
-    request: ImportSnapshotFromS3Request,
+def marshal_IpnsApiUpdateNameRequest(
+    request: IpnsApiUpdateNameRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.bucket is not None:
-        output["bucket"] = request.bucket
-
-    if request.key is not None:
-        output["key"] = request.key
-
     if request.name is not None:
         output["name"] = request.name
 
-    if request.project_id is not None:
-        output["project_id"] = request.project_id or defaults.default_project_id
-
     if request.tags is not None:
         output["tags"] = request.tags
 
+    if request.value is not None:
+        output["value"] = request.value
+
     return output
 
 
-def marshal_UpdateSnapshotRequest(
-    request: UpdateSnapshotRequest,
+def marshal_ReplacePinRequest(
+    request: ReplacePinRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
+    if request.volume_id is not None:
+        output["volume_id"] = request.volume_id
+
+    if request.cid is not None:
+        output["cid"] = request.cid
+
     if request.name is not None:
         output["name"] = request.name
 
-    if request.tags is not None:
-        output["tags"] = request.tags
+    if request.origins is not None:
+        output["origins"] = request.origins
 
     return output
 
 
 def marshal_UpdateVolumeRequest(
     request: UpdateVolumeRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.name is not None:
         output["name"] = request.name
 
-    if request.size is not None:
-        output["size"] = request.size
-
     if request.tags is not None:
         output["tags"] = request.tags
 
-    if request.perf_iops is not None:
-        output["perf_iops"] = request.perf_iops
-
     return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/block/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/block/v1alpha1/types.py`

 * *Files 8% similar despite different names*

```diff
@@ -38,15 +38,15 @@
 
 class ReferenceStatus(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN_STATUS = "unknown_status"
     ATTACHING = "attaching"
     ATTACHED = "attached"
     DETACHING = "detaching"
     DETACHED = "detached"
-    SNAPSHOTTING = "snapshotting"
+    CREATING = "creating"
     ERROR = "error"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class ReferenceType(str, Enum, metaclass=StrEnumMeta):
@@ -96,79 +96,79 @@
     LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
-class SnapshotParentVolume:
+class Reference:
     id: str
     """
-    Parent volume UUID (volume from which the snapshot originates).
+    UUID of the reference.
     """
 
-    name: str
+    product_resource_type: str
     """
-    Name of the parent volume.
+    Type of resource to which the reference is associated.
     """
 
-    type_: str
+    product_resource_id: str
     """
-    Volume type of the parent volume.
+    UUID of the product resource it refers to (according to the product_resource_type).
     """
 
-    status: VolumeStatus
+    type_: ReferenceType
     """
-    Current status the parent volume.
+    Type of reference (link, exclusive, read_only).
     """
 
-
-@dataclass
-class VolumeSpecifications:
-    class_: StorageClass
+    status: ReferenceStatus
     """
-    The storage class of the volume.
+    Status of reference (attaching, attached, detaching).
     """
 
-    perf_iops: Optional[int]
+    created_at: Optional[datetime]
     """
-    The maximum IO/s expected, according to the different options available in stock (`5000 | 15000`).
+    Creation date of the reference.
     """
 
 
 @dataclass
-class Reference:
+class SnapshotParentVolume:
     id: str
     """
-    UUID of the reference.
+    Parent volume UUID (volume from which the snapshot originates).
     """
 
-    product_resource_type: str
+    name: str
     """
-    Type of resoruce to which the reference is associated (snapshot or volume).
+    Name of the parent volume.
     """
 
-    product_resource_id: str
+    type_: str
     """
-    UUID of the volume or the snapshot it refers to (according to the product_resource_type).
+    Volume type of the parent volume.
     """
 
-    type_: ReferenceType
+    status: VolumeStatus
     """
-    Type of reference (link, exclusive, read_only).
+    Current status the parent volume.
     """
 
-    status: ReferenceStatus
+
+@dataclass
+class VolumeSpecifications:
+    class_: StorageClass
     """
-    Status of reference (attaching, attached, detaching).
+    The storage class of the volume.
     """
 
-    created_at: Optional[datetime]
+    perf_iops: Optional[int]
     """
-    Creation date of the reference.
+    The maximum IO/s expected, according to the different options available in stock (`5000 | 15000`).
     """
 
 
 @dataclass
 class CreateVolumeRequestFromEmpty:
     size: int
     """
@@ -187,58 +187,63 @@
     """
     Must be compliant with the minimum (1 GB) and maximum (10 TB) allowed size.
 Size is optional and is used only if a resize of the volume is requested, otherwise original snapshot size will be used.
     """
 
 
 @dataclass
-class SnapshotSummary:
+class Snapshot:
     id: str
     """
     UUID of the snapshot.
     """
 
     name: str
     """
     Name of the snapshot.
     """
 
     size: int
     """
-    Size of the snapshot in bytes.
+    Size in bytes of the snapshot.
     """
 
     project_id: str
     """
     UUID of the project the snapshot belongs to.
     """
 
+    references: List[Reference]
+    """
+    List of the references to the snapshot.
+    """
+
     status: SnapshotStatus
     """
     Current status of the snapshot (available, in_use, ...).
     """
 
     tags: List[str]
     """
     List of tags assigned to the volume.
     """
 
     zone: Zone
     """
-    Snapshot Availability Zone.
+    Snapshot zone.
     """
 
     class_: StorageClass
     """
     Storage class of the snapshot.
     """
 
     parent_volume: Optional[SnapshotParentVolume]
     """
-    If the parent volume has been deleted, value is null.
+    If the parent volume was deleted, value is null.
     """
 
     created_at: Optional[datetime]
     """
     Creation date of the snapshot.
     """
 
@@ -450,32 +455,14 @@
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
 
 @dataclass
-class ImportSnapshotFromS3Request:
-    bucket: str
-
-    key: str
-
-    name: str
-
-    zone: Optional[Zone]
-    """
-    Zone to target. If none is passed will use default zone from the config.
-    """
-
-    project_id: Optional[str]
-
-    tags: Optional[List[str]]
-
-
-@dataclass
 class ListSnapshotsRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     order_by: Optional[ListSnapshotsRequestOrderBy]
@@ -512,15 +499,15 @@
     """
     Filter snapshots by their names.
     """
 
 
 @dataclass
 class ListSnapshotsResponse:
-    snapshots: List[SnapshotSummary]
+    snapshots: List[Snapshot]
     """
     Paginated returned list of snapshots.
     """
 
     total_count: int
     """
     Total number of snpashots in the project.
@@ -611,77 +598,14 @@
     total_count: int
     """
     Total number of volumes in the project.
     """
 
 
 @dataclass
-class Snapshot:
-    id: str
-    """
-    UUID of the snapshot.
-    """
-
-    name: str
-    """
-    Name of the snapshot.
-    """
-
-    size: int
-    """
-    Size in bytes of the snapshot.
-    """
-
-    project_id: str
-    """
-    UUID of the project the snapshot belongs to.
-    """
-
-    references: List[Reference]
-    """
-    List of the references to the snapshot.
-    """
-
-    status: SnapshotStatus
-    """
-    Current status of the snapshot (available, in_use, ...).
-    """
-
-    tags: List[str]
-    """
-    List of tags assigned to the volume.
-    """
-
-    zone: Zone
-    """
-    Snapshot zone.
-    """
-
-    class_: StorageClass
-    """
-    Storage class of the snapshot.
-    """
-
-    parent_volume: Optional[SnapshotParentVolume]
-    """
-    If the parent volume was deleted, value is null.
-    """
-
-    created_at: Optional[datetime]
-    """
-    Creation date of the snapshot.
-    """
-
-    updated_at: Optional[datetime]
-    """
-    Last modification date of the properties of a snapshot.
-    """
-
-
-@dataclass
 class UpdateSnapshotRequest:
     snapshot_id: str
     """
     UUID of the snapshot.
     """
 
     zone: Optional[Zone]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/cockpit/v1beta1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/cockpit/v1beta1/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -23,14 +23,15 @@
 from .types import CockpitMetrics
 from .types import CreateContactPointRequest
 from .types import CreateDatasourceRequest
 from .types import CreateGrafanaUserRequest
 from .types import CreateTokenRequest
 from .types import DeactivateCockpitRequest
 from .types import DeleteContactPointRequest
+from .types import DeleteDatasourceRequest
 from .types import DeleteGrafanaUserRequest
 from .types import DeleteTokenRequest
 from .types import DisableManagedAlertsRequest
 from .types import EnableManagedAlertsRequest
 from .types import GetCockpitMetricsRequest
 from .types import GetCockpitRequest
 from .types import GetGrafanaProductDashboardRequest
@@ -77,14 +78,15 @@
     "CockpitMetrics",
     "CreateContactPointRequest",
     "CreateDatasourceRequest",
     "CreateGrafanaUserRequest",
     "CreateTokenRequest",
     "DeactivateCockpitRequest",
     "DeleteContactPointRequest",
+    "DeleteDatasourceRequest",
     "DeleteGrafanaUserRequest",
     "DeleteTokenRequest",
     "DisableManagedAlertsRequest",
     "EnableManagedAlertsRequest",
     "GetCockpitMetricsRequest",
     "GetCockpitRequest",
     "GetGrafanaProductDashboardRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/cockpit/v1beta1/api.py` & `scaleway_async-2.1.0/scaleway_async/cockpit/v1beta1/api.py`

 * *Files 4% similar despite different names*

```diff
@@ -81,25 +81,24 @@
     marshal_SelectPlanRequest,
     marshal_TriggerTestAlertRequest,
 )
 
 
 class CockpitV1Beta1API(API):
     """
-    Cockpit's API allows you to activate your Cockpit on your Projects. Scaleway's Cockpit stores metrics and logs and provides a dedicated Grafana for dashboarding to visualize them.
+    The Cockpit API allows you to activate your Cockpit to store metrics and logs. It also provides you with a dedicated Grafana for dashboarding to visualize your metrics and logs.
     """
 
     async def activate_cockpit(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Cockpit:
         """
-        Activate the Cockpit of the specified Project ID.
-        Activate the Cockpit of the specified Project ID.
+        Activate the Cockpit of a given Project specified by the Project ID.
         :param project_id: ID of the Project the Cockpit belongs to.
         :return: :class:`Cockpit <Cockpit>`
 
         Usage:
         ::
 
             result = await api.activate_cockpit()
@@ -121,16 +120,15 @@
 
     async def get_cockpit(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Cockpit:
         """
-        Retrieve the Cockpit of the specified Project ID.
-        Retrieve the Cockpit of the specified Project ID.
+        Retrieve the Cockpit of a given Project specified by the Project ID.
         :param project_id: ID of the Project the Cockpit belongs to.
         :return: :class:`Cockpit <Cockpit>`
 
         Usage:
         ::
 
             result = await api.get_cockpit()
@@ -150,16 +148,15 @@
     async def wait_for_cockpit(
         self,
         *,
         project_id: Optional[str] = None,
         options: Optional[WaitForOptions[Cockpit, Union[bool, Awaitable[bool]]]] = None,
     ) -> Cockpit:
         """
-        Retrieve the Cockpit of the specified Project ID.
-        Retrieve the Cockpit of the specified Project ID.
+        Retrieve the Cockpit of a given Project specified by the Project ID.
         :param project_id: ID of the Project the Cockpit belongs to.
         :return: :class:`Cockpit <Cockpit>`
 
         Usage:
         ::
 
             result = await api.get_cockpit()
@@ -184,16 +181,15 @@
         *,
         project_id: Optional[str] = None,
         start_date: Optional[datetime] = None,
         end_date: Optional[datetime] = None,
         metric_name: Optional[str] = None,
     ) -> CockpitMetrics:
         """
-        Get metrics from your Cockpit with the specified Project ID.
-        Get metrics from your Cockpit with the specified Project ID.
+        Retrieve metrics from your Cockpit specified by the ID of the Project the Cockpit belongs to.
         :param project_id: ID of the Project the Cockpit belongs to.
         :param start_date: Desired time range's start date for the metrics.
         :param end_date: Desired time range's end date for the metrics.
         :param metric_name: Name of the metric requested.
         :return: :class:`CockpitMetrics <CockpitMetrics>`
 
         Usage:
@@ -218,16 +214,15 @@
 
     async def deactivate_cockpit(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Cockpit:
         """
-        Deactivate the Cockpit of the specified Project ID.
-        Deactivate the Cockpit of the specified Project ID.
+        Deactivate the Cockpit of a given Project specified by the Project ID.
         :param project_id: ID of the Project the Cockpit belongs to.
         :return: :class:`Cockpit <Cockpit>`
 
         Usage:
         ::
 
             result = await api.deactivate_cockpit()
@@ -252,20 +247,19 @@
         *,
         name: str,
         is_default: bool,
         project_id: Optional[str] = None,
         type_: Optional[DatasourceType] = None,
     ) -> Datasource:
         """
-        Create a datasource for the specified Project ID and the given type.
-        Create a datasource for the specified Project ID and the given type.
-        :param name: Datasource name.
-        :param is_default: Specifies that the returned output is the default datasource per type.
+        Create a data source for a given Project specified by the Project ID and the data source type.
+        :param name: Data source name.
+        :param is_default: Specifies that the returned output is the default data source per type.
         :param project_id: ID of the Project the Cockpit belongs to.
-        :param type_: Datasource type.
+        :param type_: Data source type.
         :return: :class:`Datasource <Datasource>`
 
         Usage:
         ::
 
             result = await api.create_datasource(
                 name="example",
@@ -286,27 +280,52 @@
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Datasource(res.json())
 
+    async def delete_datasource(
+        self,
+        *,
+        datasource_id: str,
+    ) -> None:
+        """
+        Delete a given data source specified by the data source ID.
+        :param datasource_id: ID of the data source.
+
+        Usage:
+        ::
+
+            result = await api.delete_datasource(
+                datasource_id="example",
+            )
+        """
+
+        param_datasource_id = validate_path_param("datasource_id", datasource_id)
+
+        res = self._request(
+            "DELETE",
+            f"/cockpit/v1beta1/datasources/{param_datasource_id}",
+        )
+
+        self._throw_on_error(res)
+
     async def list_datasources(
         self,
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListDatasourcesRequestOrderBy] = None,
         project_id: Optional[str] = None,
         types: Optional[List[DatasourceType]] = None,
         is_managed_by_scaleway: Optional[bool] = None,
     ) -> ListDatasourcesResponse:
         """
-        Get a list of datasources for the specified Project ID.
-        Get a list of datasources for the specified Project ID.
+        Get a list of data sources for the specified Project ID.
         :param page: Page number.
         :param page_size: Page size.
         :param order_by: How the response is ordered.
         :param project_id: ID of the Project.
         :param types: Filter by datasource types.
         :param is_managed_by_scaleway: Filter by managed datasources.
         :return: :class:`ListDatasourcesResponse <ListDatasourcesResponse>`
@@ -340,16 +359,15 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListDatasourcesRequestOrderBy] = None,
         project_id: Optional[str] = None,
         types: Optional[List[DatasourceType]] = None,
         is_managed_by_scaleway: Optional[bool] = None,
     ) -> List[Datasource]:
         """
-        Get a list of datasources for the specified Project ID.
-        Get a list of datasources for the specified Project ID.
+        Get a list of data sources for the specified Project ID.
         :param page: Page number.
         :param page_size: Page size.
         :param order_by: How the response is ordered.
         :param project_id: ID of the Project.
         :param types: Filter by datasource types.
         :param is_managed_by_scaleway: Filter by managed datasources.
         :return: :class:`List[Datasource] <List[Datasource]>`
@@ -378,16 +396,15 @@
         self,
         *,
         project_id: Optional[str] = None,
         name: Optional[str] = None,
         scopes: Optional[TokenScopes] = None,
     ) -> Token:
         """
-        Create a token associated with the specified Project ID.
-        Create a token associated with the specified Project ID.
+        Create a token in a given Project specified by the Project ID.
         :param project_id: ID of the Project.
         :param name: Name of the token.
         :param scopes: Token's permissions.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
@@ -416,16 +433,15 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListTokensRequestOrderBy] = None,
         project_id: Optional[str] = None,
     ) -> ListTokensResponse:
         """
-        Get a list of tokens associated with the specified Project ID.
-        Get a list of tokens associated with the specified Project ID.
+        Get a list of tokens in a given Project specified by the Project ID.
         :param page: Page number.
         :param page_size: Page size.
         :param order_by: How the response is ordered.
         :param project_id: ID of the Project.
         :return: :class:`ListTokensResponse <ListTokensResponse>`
 
         Usage:
@@ -453,16 +469,15 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListTokensRequestOrderBy] = None,
         project_id: Optional[str] = None,
     ) -> List[Token]:
         """
-        Get a list of tokens associated with the specified Project ID.
-        Get a list of tokens associated with the specified Project ID.
+        Get a list of tokens in a given Project specified by the Project ID.
         :param page: Page number.
         :param page_size: Page size.
         :param order_by: How the response is ordered.
         :param project_id: ID of the Project.
         :return: :class:`List[Token] <List[Token]>`
 
         Usage:
@@ -485,16 +500,15 @@
 
     async def get_token(
         self,
         *,
         token_id: str,
     ) -> Token:
         """
-        Retrieve the token associated with the specified token ID.
-        Retrieve the token associated with the specified token ID.
+        Retrieve a given token specified by the token ID.
         :param token_id: ID of the token.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = await api.get_token(
@@ -514,16 +528,15 @@
 
     async def delete_token(
         self,
         *,
         token_id: str,
     ) -> None:
         """
-        Delete the token associated with the specified token ID.
-        Delete the token associated with the specified token ID.
+        Delete a given token specified by the token ID.
         :param token_id: ID of the token.
 
         Usage:
         ::
 
             result = await api.delete_token(
                 token_id="example",
@@ -542,16 +555,15 @@
     async def create_contact_point(
         self,
         *,
         project_id: Optional[str] = None,
         contact_point: Optional[ContactPoint] = None,
     ) -> ContactPoint:
         """
-        Create a contact point to receive alerts for the default receiver.
-        Create a contact point to receive alerts for the default receiver.
+        Create a contact point associated with the default receiver, to receive alerts.
         :param project_id: ID of the Project in which to create the contact point.
         :param contact_point: Contact point to create.
         :return: :class:`ContactPoint <ContactPoint>`
 
         Usage:
         ::
 
@@ -577,16 +589,15 @@
         self,
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         project_id: Optional[str] = None,
     ) -> ListContactPointsResponse:
         """
-        Get a list of contact points for the Cockpit associated with the specified Project ID.
-        Get a list of contact points for the Cockpit associated with the specified Project ID.
+        Get a list of contact points created for a given Cockpit, specified by the ID of the Project the Cockpit belongs to.
         :param page: Page number.
         :param page_size: Page size.
         :param project_id: ID of the Project from which to list the contact points.
         :return: :class:`ListContactPointsResponse <ListContactPointsResponse>`
 
         Usage:
         ::
@@ -611,16 +622,15 @@
         self,
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         project_id: Optional[str] = None,
     ) -> List[ContactPoint]:
         """
-        Get a list of contact points for the Cockpit associated with the specified Project ID.
-        Get a list of contact points for the Cockpit associated with the specified Project ID.
+        Get a list of contact points created for a given Cockpit, specified by the ID of the Project the Cockpit belongs to.
         :param page: Page number.
         :param page_size: Page size.
         :param project_id: ID of the Project from which to list the contact points.
         :return: :class:`List[ContactPoint] <List[ContactPoint]>`
 
         Usage:
         ::
@@ -642,16 +652,15 @@
     async def delete_contact_point(
         self,
         *,
         project_id: Optional[str] = None,
         contact_point: Optional[ContactPoint] = None,
     ) -> None:
         """
-        Delete a contact point for the default receiver.
-        Delete a contact point for the default receiver.
+        Delete a contact point associated with the default receiver.
         :param project_id: ID of the Project.
         :param contact_point: Contact point to delete.
 
         Usage:
         ::
 
             result = await api.delete_contact_point()
@@ -673,16 +682,15 @@
 
     async def enable_managed_alerts(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> None:
         """
-        Enable the sending of managed alerts for the specified Project's Cockpit.
-        Enable the sending of managed alerts for the specified Project's Cockpit.
+        Enable the sending of managed alerts for a given Cockpit, specified by the ID of the Project the Cockpit belongs to.
         :param project_id: ID of the Project.
 
         Usage:
         ::
 
             result = await api.enable_managed_alerts()
         """
@@ -702,16 +710,15 @@
 
     async def disable_managed_alerts(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> None:
         """
-        Disable the sending of managed alerts for the specified Project's Cockpit.
-        Disable the sending of managed alerts for the specified Project's Cockpit.
+        Disable the sending of managed alerts for a given Cockpit, specified by the ID of the Project the Cockpit belongs to.
         :param project_id: ID of the Project.
 
         Usage:
         ::
 
             result = await api.disable_managed_alerts()
         """
@@ -731,16 +738,15 @@
 
     async def trigger_test_alert(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> None:
         """
-        Trigger a test alert to all of the Cockpit's receivers.
-        Trigger a test alert to all of the Cockpit's receivers.
+        Send a test alert to make sure your contact points get notified when an actual alert is triggered.
         :param project_id:
 
         Usage:
         ::
 
             result = await api.trigger_test_alert()
         """
@@ -762,16 +768,15 @@
         self,
         *,
         login: str,
         project_id: Optional[str] = None,
         role: Optional[GrafanaUserRole] = None,
     ) -> GrafanaUser:
         """
-        Create a Grafana user for your Cockpit's Grafana instance. Make sure you save the automatically-generated password and the Grafana user ID.
-        Create a Grafana user for your Cockpit's Grafana instance. Make sure you save the automatically-generated password and the Grafana user ID.
+        Create a Grafana user for your Cockpit's Grafana. Make sure you save the automatically-generated password and the Grafana user ID.
         :param login: Username of the Grafana user.
         :param project_id: ID of the Project.
         :param role: Role assigned to the Grafana user.
         :return: :class:`GrafanaUser <GrafanaUser>`
 
         Usage:
         ::
@@ -802,16 +807,15 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListGrafanaUsersRequestOrderBy] = None,
         project_id: Optional[str] = None,
     ) -> ListGrafanaUsersResponse:
         """
-        Get a list of Grafana users who are able to connect to the Cockpit's Grafana instance.
-        Get a list of Grafana users who are able to connect to the Cockpit's Grafana instance.
+        Get a list of all Grafana users created in your Cockpit's Grafana.
         :param page: Page number.
         :param page_size: Page size.
         :param order_by:
         :param project_id: ID of the Project.
         :return: :class:`ListGrafanaUsersResponse <ListGrafanaUsersResponse>`
 
         Usage:
@@ -839,16 +843,15 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListGrafanaUsersRequestOrderBy] = None,
         project_id: Optional[str] = None,
     ) -> List[GrafanaUser]:
         """
-        Get a list of Grafana users who are able to connect to the Cockpit's Grafana instance.
-        Get a list of Grafana users who are able to connect to the Cockpit's Grafana instance.
+        Get a list of all Grafana users created in your Cockpit's Grafana.
         :param page: Page number.
         :param page_size: Page size.
         :param order_by:
         :param project_id: ID of the Project.
         :return: :class:`List[GrafanaUser] <List[GrafanaUser]>`
 
         Usage:
@@ -872,16 +875,15 @@
     async def delete_grafana_user(
         self,
         *,
         project_id: Optional[str] = None,
         grafana_user_id: int,
     ) -> None:
         """
-        Delete a Grafana user from a Grafana instance, specified by the Cockpit's Project ID and the Grafana user ID.
-        Delete a Grafana user from a Grafana instance, specified by the Cockpit's Project ID and the Grafana user ID.
+        Delete a Grafana user from your Cockpit's Grafana, specified by the ID of the Project the Cockpit belongs to, and the ID of the Grafana user.
         :param project_id: ID of the Project.
         :param grafana_user_id: ID of the Grafana user.
 
         Usage:
         ::
 
             result = await api.delete_grafana_user(
@@ -908,16 +910,15 @@
     async def reset_grafana_user_password(
         self,
         *,
         project_id: Optional[str] = None,
         grafana_user_id: int,
     ) -> GrafanaUser:
         """
-        Reset a Grafana user's password specified by the Cockpit's Project ID and the Grafana user ID.
-        Reset a Grafana user's password specified by the Cockpit's Project ID and the Grafana user ID.
+        Reset the password of a Grafana user, specified by the ID of the Project the Cockpit belongs to, and the ID of the Grafana user.
         :param project_id: ID of the Project.
         :param grafana_user_id: ID of the Grafana user.
         :return: :class:`GrafanaUser <GrafanaUser>`
 
         Usage:
         ::
 
@@ -948,15 +949,14 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListPlansRequestOrderBy] = None,
     ) -> ListPlansResponse:
         """
         Get a list of all pricing plans available.
-        Get a list of all pricing plans available.
         :param page: Page number.
         :param page_size: Page size.
         :param order_by:
         :return: :class:`ListPlansResponse <ListPlansResponse>`
 
         Usage:
         ::
@@ -982,15 +982,14 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListPlansRequestOrderBy] = None,
     ) -> List[Plan]:
         """
         Get a list of all pricing plans available.
-        Get a list of all pricing plans available.
         :param page: Page number.
         :param page_size: Page size.
         :param order_by:
         :return: :class:`List[Plan] <List[Plan]>`
 
         Usage:
         ::
@@ -1013,15 +1012,14 @@
         self,
         *,
         plan_id: str,
         project_id: Optional[str] = None,
     ) -> SelectPlanResponse:
         """
         Select your chosen pricing plan for your Cockpit, specifying the Cockpit's Project ID and the pricing plan's ID in the request.
-        Select your chosen pricing plan for your Cockpit, specifying the Cockpit's Project ID and the pricing plan's ID in the request.
         :param plan_id: ID of the pricing plan.
         :param project_id: ID of the Project.
         :return: :class:`SelectPlanResponse <SelectPlanResponse>`
 
         Usage:
         ::
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/cockpit/v1beta1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/cockpit/v1/marshalling.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,53 +1,50 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 from dateutil import parser
 
 from scaleway_core.profile import ProfileDefaults
-from scaleway_core.bridge import (
-    unmarshal_TimeSeries,
-)
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from .types import (
+    TokenScope,
     ContactPointEmail,
     ContactPoint,
-    Datasource,
+    DataSource,
     GrafanaProductDashboard,
     GrafanaUser,
-    TokenScopes,
-    Token,
-    CockpitEndpoints,
     Plan,
-    Cockpit,
-    CockpitMetrics,
+    Token,
+    AlertManager,
+    Grafana,
     ListContactPointsResponse,
-    ListDatasourcesResponse,
+    ListDataSourcesResponse,
     ListGrafanaProductDashboardsResponse,
     ListGrafanaUsersResponse,
     ListPlansResponse,
     ListTokensResponse,
-    SelectPlanResponse,
-    ActivateCockpitRequest,
-    CreateContactPointRequest,
-    CreateDatasourceRequest,
-    CreateGrafanaUserRequest,
-    CreateTokenRequest,
-    DeactivateCockpitRequest,
-    DeleteContactPointRequest,
-    DeleteGrafanaUserRequest,
-    DisableManagedAlertsRequest,
-    EnableManagedAlertsRequest,
-    ResetGrafanaUserPasswordRequest,
-    SelectPlanRequest,
-    TriggerTestAlertRequest,
+    Usage,
+    UsageOverview,
+    GlobalApiCreateGrafanaUserRequest,
+    GlobalApiResetGrafanaUserPasswordRequest,
+    GlobalApiSelectPlanRequest,
+    GlobalApiSyncGrafanaDataSourcesRequest,
+    RegionalApiCreateContactPointRequest,
+    RegionalApiCreateDataSourceRequest,
+    RegionalApiCreateTokenRequest,
+    RegionalApiDeleteContactPointRequest,
+    RegionalApiDisableAlertManagerRequest,
+    RegionalApiDisableManagedAlertsRequest,
+    RegionalApiEnableAlertManagerRequest,
+    RegionalApiEnableManagedAlertsRequest,
+    RegionalApiTriggerTestAlertRequest,
 )
 
 
 def unmarshal_ContactPointEmail(data: Any) -> ContactPointEmail:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ContactPointEmail' failed as data isn't a dictionary."
@@ -66,25 +63,31 @@
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ContactPoint' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
+    field = data.get("region", None)
+    if field is not None:
+        args["region"] = field
+
     field = data.get("email", None)
     if field is not None:
         args["email"] = unmarshal_ContactPointEmail(field)
+    else:
+        args["email"] = None
 
     return ContactPoint(**args)
 
 
-def unmarshal_Datasource(data: Any) -> Datasource:
+def unmarshal_DataSource(data: Any) -> DataSource:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Datasource' failed as data isn't a dictionary."
+            "Unmarshalling the type 'DataSource' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
@@ -97,36 +100,56 @@
     if field is not None:
         args["name"] = field
 
     field = data.get("url", None)
     if field is not None:
         args["url"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
-    field = data.get("is_managed_by_scaleway", None)
+    field = data.get("origin", None)
+    if field is not None:
+        args["origin"] = field
+
+    field = data.get("synchronized_with_grafana", None)
+    if field is not None:
+        args["synchronized_with_grafana"] = field
+
+    field = data.get("region", None)
+    if field is not None:
+        args["region"] = field
+
+    field = data.get("created_at", None)
+    if field is not None:
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
+
+    field = data.get("updated_at", None)
     if field is not None:
-        args["is_managed_by_scaleway"] = field
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
-    return Datasource(**args)
+    return DataSource(**args)
 
 
 def unmarshal_GrafanaProductDashboard(data: Any) -> GrafanaProductDashboard:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'GrafanaProductDashboard' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("dashboard_name", None)
+    field = data.get("name", None)
     if field is not None:
-        args["dashboard_name"] = field
+        args["name"] = field
 
     field = data.get("title", None)
     if field is not None:
         args["title"] = field
 
     field = data.get("url", None)
     if field is not None:
@@ -162,63 +185,67 @@
     field = data.get("role", None)
     if field is not None:
         args["role"] = field
 
     field = data.get("password", None)
     if field is not None:
         args["password"] = field
+    else:
+        args["password"] = None
 
     return GrafanaUser(**args)
 
 
-def unmarshal_TokenScopes(data: Any) -> TokenScopes:
+def unmarshal_Plan(data: Any) -> Plan:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'TokenScopes' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Plan' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("query_metrics", None)
-    if field is not None:
-        args["query_metrics"] = field
-
-    field = data.get("write_metrics", None)
+    field = data.get("name", None)
     if field is not None:
-        args["write_metrics"] = field
+        args["name"] = field
 
-    field = data.get("setup_metrics_rules", None)
+    field = data.get("sample_ingestion_price", None)
     if field is not None:
-        args["setup_metrics_rules"] = field
+        args["sample_ingestion_price"] = field
 
-    field = data.get("query_logs", None)
+    field = data.get("logs_ingestion_price", None)
     if field is not None:
-        args["query_logs"] = field
+        args["logs_ingestion_price"] = field
 
-    field = data.get("write_logs", None)
+    field = data.get("traces_ingestion_price", None)
     if field is not None:
-        args["write_logs"] = field
+        args["traces_ingestion_price"] = field
 
-    field = data.get("setup_logs_rules", None)
+    field = data.get("monthly_price", None)
     if field is not None:
-        args["setup_logs_rules"] = field
+        args["monthly_price"] = field
 
-    field = data.get("setup_alerts", None)
+    field = data.get("retention_metrics_interval", None)
     if field is not None:
-        args["setup_alerts"] = field
+        args["retention_metrics_interval"] = field
+    else:
+        args["retention_metrics_interval"] = None
 
-    field = data.get("query_traces", None)
+    field = data.get("retention_logs_interval", None)
     if field is not None:
-        args["query_traces"] = field
+        args["retention_logs_interval"] = field
+    else:
+        args["retention_logs_interval"] = None
 
-    field = data.get("write_traces", None)
+    field = data.get("retention_traces_interval", None)
     if field is not None:
-        args["write_traces"] = field
+        args["retention_traces_interval"] = field
+    else:
+        args["retention_traces_interval"] = None
 
-    return TokenScopes(**args)
+    return Plan(**args)
 
 
 def unmarshal_Token(data: Any) -> Token:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Token' failed as data isn't a dictionary."
         )
@@ -233,165 +260,85 @@
     if field is not None:
         args["project_id"] = field
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
+    field = data.get("scopes", None)
+    if field is not None:
+        args["scopes"] = [TokenScope(v) for v in field] if field is not None else None
+
+    field = data.get("region", None)
+    if field is not None:
+        args["region"] = field
+
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("scopes", None)
-    if field is not None:
-        args["scopes"] = unmarshal_TokenScopes(field)
+    else:
+        args["updated_at"] = None
 
     field = data.get("secret_key", None)
     if field is not None:
         args["secret_key"] = field
+    else:
+        args["secret_key"] = None
 
     return Token(**args)
 
 
-def unmarshal_CockpitEndpoints(data: Any) -> CockpitEndpoints:
+def unmarshal_AlertManager(data: Any) -> AlertManager:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'CockpitEndpoints' failed as data isn't a dictionary."
+            "Unmarshalling the type 'AlertManager' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("metrics_url", None)
-    if field is not None:
-        args["metrics_url"] = field
-
-    field = data.get("logs_url", None)
-    if field is not None:
-        args["logs_url"] = field
-
-    field = data.get("traces_url", None)
-    if field is not None:
-        args["traces_url"] = field
-
-    field = data.get("alertmanager_url", None)
+    field = data.get("alert_manager_enabled", None)
     if field is not None:
-        args["alertmanager_url"] = field
-
-    field = data.get("grafana_url", None)
-    if field is not None:
-        args["grafana_url"] = field
-
-    return CockpitEndpoints(**args)
-
-
-def unmarshal_Plan(data: Any) -> Plan:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Plan' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("id", None)
-    if field is not None:
-        args["id"] = field
-
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
-    field = data.get("sample_ingestion_price", None)
-    if field is not None:
-        args["sample_ingestion_price"] = field
-
-    field = data.get("logs_ingestion_price", None)
-    if field is not None:
-        args["logs_ingestion_price"] = field
-
-    field = data.get("traces_ingestion_price", None)
-    if field is not None:
-        args["traces_ingestion_price"] = field
-
-    field = data.get("retention_price", None)
-    if field is not None:
-        args["retention_price"] = field
-
-    field = data.get("retention_metrics_interval", None)
-    if field is not None:
-        args["retention_metrics_interval"] = field
-
-    field = data.get("retention_logs_interval", None)
-    if field is not None:
-        args["retention_logs_interval"] = field
-
-    field = data.get("retention_traces_interval", None)
-    if field is not None:
-        args["retention_traces_interval"] = field
-
-    return Plan(**args)
-
-
-def unmarshal_Cockpit(data: Any) -> Cockpit:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Cockpit' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("project_id", None)
-    if field is not None:
-        args["project_id"] = field
-
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
+        args["alert_manager_enabled"] = field
 
     field = data.get("managed_alerts_enabled", None)
     if field is not None:
         args["managed_alerts_enabled"] = field
 
-    field = data.get("created_at", None)
+    field = data.get("region", None)
     if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["region"] = field
 
-    field = data.get("updated_at", None)
+    field = data.get("alert_manager_url", None)
     if field is not None:
-        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["alert_manager_url"] = field
+    else:
+        args["alert_manager_url"] = None
 
-    field = data.get("endpoints", None)
-    if field is not None:
-        args["endpoints"] = unmarshal_CockpitEndpoints(field)
-
-    field = data.get("plan", None)
-    if field is not None:
-        args["plan"] = unmarshal_Plan(field)
-
-    return Cockpit(**args)
+    return AlertManager(**args)
 
 
-def unmarshal_CockpitMetrics(data: Any) -> CockpitMetrics:
+def unmarshal_Grafana(data: Any) -> Grafana:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'CockpitMetrics' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Grafana' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("timeseries", None)
+    field = data.get("grafana_url", None)
     if field is not None:
-        args["timeseries"] = (
-            [unmarshal_TimeSeries(v) for v in field] if field is not None else None
-        )
+        args["grafana_url"] = field
 
-    return CockpitMetrics(**args)
+    return Grafana(**args)
 
 
 def unmarshal_ListContactPointsResponse(data: Any) -> ListContactPointsResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ListContactPointsResponse' failed as data isn't a dictionary."
         )
@@ -415,33 +362,33 @@
     field = data.get("has_additional_contact_points", None)
     if field is not None:
         args["has_additional_contact_points"] = field
 
     return ListContactPointsResponse(**args)
 
 
-def unmarshal_ListDatasourcesResponse(data: Any) -> ListDatasourcesResponse:
+def unmarshal_ListDataSourcesResponse(data: Any) -> ListDataSourcesResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListDatasourcesResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListDataSourcesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    field = data.get("datasources", None)
+    field = data.get("data_sources", None)
     if field is not None:
-        args["datasources"] = (
-            [unmarshal_Datasource(v) for v in field] if field is not None else None
+        args["data_sources"] = (
+            [unmarshal_DataSource(v) for v in field] if field is not None else None
         )
 
-    return ListDatasourcesResponse(**args)
+    return ListDataSourcesResponse(**args)
 
 
 def unmarshal_ListGrafanaProductDashboardsResponse(
     data: Any,
 ) -> ListGrafanaProductDashboardsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -524,269 +471,295 @@
         args["tokens"] = (
             [unmarshal_Token(v) for v in field] if field is not None else None
         )
 
     return ListTokensResponse(**args)
 
 
-def unmarshal_SelectPlanResponse(data: Any) -> SelectPlanResponse:
+def unmarshal_Usage(data: Any) -> Usage:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'SelectPlanResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Usage' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    return SelectPlanResponse(**args)
+    field = data.get("project_id", None)
+    if field is not None:
+        args["project_id"] = field
 
+    field = data.get("data_source_origin", None)
+    if field is not None:
+        args["data_source_origin"] = field
 
-def marshal_ActivateCockpitRequest(
-    request: ActivateCockpitRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
+    field = data.get("data_source_type", None)
+    if field is not None:
+        args["data_source_type"] = field
 
-    if request.project_id is not None:
-        output["project_id"] = request.project_id or defaults.default_project_id
+    field = data.get("unit", None)
+    if field is not None:
+        args["unit"] = field
 
-    return output
+    field = data.get("quantity_over_interval", None)
+    if field is not None:
+        args["quantity_over_interval"] = field
 
+    field = data.get("region", None)
+    if field is not None:
+        args["region"] = field
 
-def marshal_ContactPointEmail(
-    request: ContactPointEmail,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
+    field = data.get("data_source_id", None)
+    if field is not None:
+        args["data_source_id"] = field
+    else:
+        args["data_source_id"] = None
 
-    if request.to is not None:
-        output["to"] = request.to
+    field = data.get("interval", None)
+    if field is not None:
+        args["interval"] = field
+    else:
+        args["interval"] = None
 
-    return output
+    return Usage(**args)
 
 
-def marshal_ContactPoint(
-    request: ContactPoint,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
-    output.update(
-        resolve_one_of(
-            [
-                OneOfPossibility("email", request.email),
-            ]
-        ),
-    )
+def unmarshal_UsageOverview(data: Any) -> UsageOverview:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'UsageOverview' failed as data isn't a dictionary."
+        )
 
-    return output
+    args: Dict[str, Any] = {}
+
+    field = data.get("scaleway_metrics_usage", None)
+    if field is not None:
+        args["scaleway_metrics_usage"] = unmarshal_Usage(field)
+    else:
+        args["scaleway_metrics_usage"] = None
+
+    field = data.get("scaleway_logs_usage", None)
+    if field is not None:
+        args["scaleway_logs_usage"] = unmarshal_Usage(field)
+    else:
+        args["scaleway_logs_usage"] = None
+
+    field = data.get("external_metrics_usage", None)
+    if field is not None:
+        args["external_metrics_usage"] = unmarshal_Usage(field)
+    else:
+        args["external_metrics_usage"] = None
 
+    field = data.get("external_logs_usage", None)
+    if field is not None:
+        args["external_logs_usage"] = unmarshal_Usage(field)
+    else:
+        args["external_logs_usage"] = None
+
+    field = data.get("external_traces_usage", None)
+    if field is not None:
+        args["external_traces_usage"] = unmarshal_Usage(field)
+    else:
+        args["external_traces_usage"] = None
+
+    return UsageOverview(**args)
 
-def marshal_CreateContactPointRequest(
-    request: CreateContactPointRequest,
+
+def marshal_GlobalApiCreateGrafanaUserRequest(
+    request: GlobalApiCreateGrafanaUserRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
+    if request.login is not None:
+        output["login"] = request.login
+
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
-    if request.contact_point is not None:
-        output["contact_point"] = (
-            marshal_ContactPoint(request.contact_point, defaults),
-        )
+    if request.role is not None:
+        output["role"] = str(request.role)
 
     return output
 
 
-def marshal_CreateDatasourceRequest(
-    request: CreateDatasourceRequest,
+def marshal_GlobalApiResetGrafanaUserPasswordRequest(
+    request: GlobalApiResetGrafanaUserPasswordRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.name is not None:
-        output["name"] = request.name
-
-    if request.is_default is not None:
-        output["is_default"] = request.is_default
-
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
-    if request.type_ is not None:
-        output["type"] = str(request.type_)
-
     return output
 
 
-def marshal_CreateGrafanaUserRequest(
-    request: CreateGrafanaUserRequest,
+def marshal_GlobalApiSelectPlanRequest(
+    request: GlobalApiSelectPlanRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.login is not None:
-        output["login"] = request.login
-
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
-    if request.role is not None:
-        output["role"] = str(request.role)
+    if request.plan_name is not None:
+        output["plan_name"] = str(request.plan_name)
 
     return output
 
 
-def marshal_TokenScopes(
-    request: TokenScopes,
+def marshal_GlobalApiSyncGrafanaDataSourcesRequest(
+    request: GlobalApiSyncGrafanaDataSourcesRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.query_metrics is not None:
-        output["query_metrics"] = request.query_metrics
-
-    if request.write_metrics is not None:
-        output["write_metrics"] = request.write_metrics
-
-    if request.setup_metrics_rules is not None:
-        output["setup_metrics_rules"] = request.setup_metrics_rules
-
-    if request.query_logs is not None:
-        output["query_logs"] = request.query_logs
-
-    if request.write_logs is not None:
-        output["write_logs"] = request.write_logs
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
 
-    if request.setup_logs_rules is not None:
-        output["setup_logs_rules"] = request.setup_logs_rules
+    return output
 
-    if request.setup_alerts is not None:
-        output["setup_alerts"] = request.setup_alerts
 
-    if request.query_traces is not None:
-        output["query_traces"] = request.query_traces
+def marshal_ContactPointEmail(
+    request: ContactPointEmail,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    if request.write_traces is not None:
-        output["write_traces"] = request.write_traces
+    if request.to is not None:
+        output["to"] = request.to
 
     return output
 
 
-def marshal_CreateTokenRequest(
-    request: CreateTokenRequest,
+def marshal_RegionalApiCreateContactPointRequest(
+    request: RegionalApiCreateContactPointRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility("email", request.email),
+            ]
+        ),
+    )
 
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
-    if request.name is not None:
-        output["name"] = request.name
-
-    if request.scopes is not None:
-        output["scopes"] = (marshal_TokenScopes(request.scopes, defaults),)
-
     return output
 
 
-def marshal_DeactivateCockpitRequest(
-    request: DeactivateCockpitRequest,
+def marshal_RegionalApiCreateDataSourceRequest(
+    request: RegionalApiCreateDataSourceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
+    if request.name is not None:
+        output["name"] = request.name
+
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
+    if request.type_ is not None:
+        output["type"] = str(request.type_)
+
     return output
 
 
-def marshal_DeleteContactPointRequest(
-    request: DeleteContactPointRequest,
+def marshal_RegionalApiCreateTokenRequest(
+    request: RegionalApiCreateTokenRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
+    if request.name is not None:
+        output["name"] = request.name
+
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
-    if request.contact_point is not None:
-        output["contact_point"] = (
-            marshal_ContactPoint(request.contact_point, defaults),
-        )
+    if request.token_scopes is not None:
+        output["token_scopes"] = [str(item) for item in request.token_scopes]
 
     return output
 
 
-def marshal_DeleteGrafanaUserRequest(
-    request: DeleteGrafanaUserRequest,
+def marshal_RegionalApiDeleteContactPointRequest(
+    request: RegionalApiDeleteContactPointRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility("email", request.email),
+            ]
+        ),
+    )
 
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
     return output
 
 
-def marshal_DisableManagedAlertsRequest(
-    request: DisableManagedAlertsRequest,
+def marshal_RegionalApiDisableAlertManagerRequest(
+    request: RegionalApiDisableAlertManagerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
     return output
 
 
-def marshal_EnableManagedAlertsRequest(
-    request: EnableManagedAlertsRequest,
+def marshal_RegionalApiDisableManagedAlertsRequest(
+    request: RegionalApiDisableManagedAlertsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
     return output
 
 
-def marshal_ResetGrafanaUserPasswordRequest(
-    request: ResetGrafanaUserPasswordRequest,
+def marshal_RegionalApiEnableAlertManagerRequest(
+    request: RegionalApiEnableAlertManagerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
     return output
 
 
-def marshal_SelectPlanRequest(
-    request: SelectPlanRequest,
+def marshal_RegionalApiEnableManagedAlertsRequest(
+    request: RegionalApiEnableManagedAlertsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.plan_id is not None:
-        output["plan_id"] = request.plan_id
-
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
     return output
 
 
-def marshal_TriggerTestAlertRequest(
-    request: TriggerTestAlertRequest,
+def marshal_RegionalApiTriggerTestAlertRequest(
+    request: RegionalApiTriggerTestAlertRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/cockpit/v1beta1/types.py` & `scaleway_async-2.1.0/scaleway_async/cockpit/v1beta1/types.py`

 * *Files 2% similar despite different names*

```diff
@@ -234,45 +234,45 @@
 
     email: Optional[ContactPointEmail]
 
 
 @dataclass
 class Datasource:
     """
-    Datasource.
+    Data source.
     """
 
     id: str
     """
-    ID of the datasource.
+    ID of the data source.
     """
 
     project_id: str
     """
     ID of the Project the Cockpit belongs to.
     """
 
     name: str
     """
-    Datasource name.
+    Data source name.
     """
 
     url: str
     """
-    Datasource URL.
+    Data source URL.
     """
 
     type_: DatasourceType
     """
-    Datasource type.
+    Data source type.
     """
 
     is_managed_by_scaleway: bool
     """
-    Specifies that the datasource receives data from Scaleway products and is managed by Scaleway.
+    Specifies that the data source receives data from Scaleway products and is managed by Scaleway.
     """
 
 
 @dataclass
 class GrafanaProductDashboard:
     """
     Grafana dashboard.
@@ -447,35 +447,35 @@
     Contact point to create.
     """
 
 
 @dataclass
 class CreateDatasourceRequest:
     """
-    Request to create a datasource.
+    Request to create a data source.
     """
 
     name: str
     """
-    Datasource name.
+    Data source name.
     """
 
     is_default: bool
     """
-    Specifies that the returned output is the default datasource per type.
+    Specifies that the returned output is the default data source per type.
     """
 
     project_id: Optional[str]
     """
     ID of the Project the Cockpit belongs to.
     """
 
     type_: Optional[DatasourceType]
     """
-    Datasource type.
+    Data source type.
     """
 
 
 @dataclass
 class CreateGrafanaUserRequest:
     """
     Request to create a Grafana user.
@@ -537,14 +537,26 @@
     contact_point: Optional[ContactPoint]
     """
     Contact point to delete.
     """
 
 
 @dataclass
+class DeleteDatasourceRequest:
+    """
+    Request to delete a data source.
+    """
+
+    datasource_id: str
+    """
+    ID of the data source.
+    """
+
+
+@dataclass
 class DeleteGrafanaUserRequest:
     """
     Request to delete a Grafana user.
     """
 
     project_id: Optional[str]
     """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/container/v1beta1/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,19 +8,17 @@
 from .types import CronStatus
 from .content import CRON_TRANSIENT_STATUSES
 from .types import DomainStatus
 from .content import DOMAIN_TRANSIENT_STATUSES
 from .types import ListContainersRequestOrderBy
 from .types import ListCronsRequestOrderBy
 from .types import ListDomainsRequestOrderBy
-from .types import ListLogsRequestOrderBy
 from .types import ListNamespacesRequestOrderBy
 from .types import ListTokensRequestOrderBy
 from .types import ListTriggersRequestOrderBy
-from .types import LogStream
 from .types import NamespaceStatus
 from .content import NAMESPACE_TRANSIENT_STATUSES
 from .types import TokenStatus
 from .content import TOKEN_TRANSIENT_STATUSES
 from .types import TriggerInputType
 from .types import TriggerStatus
 from .content import TRIGGER_TRANSIENT_STATUSES
@@ -31,15 +29,14 @@
 from .types import Secret
 from .types import CreateTriggerRequestMnqNatsClientConfig
 from .types import CreateTriggerRequestMnqSqsClientConfig
 from .types import CreateTriggerRequestSqsClientConfig
 from .types import Container
 from .types import Cron
 from .types import Domain
-from .types import Log
 from .types import Namespace
 from .types import Token
 from .types import Trigger
 from .types import UpdateTriggerRequestSqsClientConfig
 from .types import CreateContainerRequest
 from .types import CreateCronRequest
 from .types import CreateDomainRequest
@@ -62,16 +59,14 @@
 from .types import IssueJWTRequest
 from .types import ListContainersRequest
 from .types import ListContainersResponse
 from .types import ListCronsRequest
 from .types import ListCronsResponse
 from .types import ListDomainsRequest
 from .types import ListDomainsResponse
-from .types import ListLogsRequest
-from .types import ListLogsResponse
 from .types import ListNamespacesRequest
 from .types import ListNamespacesResponse
 from .types import ListTokensRequest
 from .types import ListTokensResponse
 from .types import ListTriggersRequest
 from .types import ListTriggersResponse
 from .types import UpdateContainerRequest
@@ -89,19 +84,17 @@
     "CronStatus",
     "CRON_TRANSIENT_STATUSES",
     "DomainStatus",
     "DOMAIN_TRANSIENT_STATUSES",
     "ListContainersRequestOrderBy",
     "ListCronsRequestOrderBy",
     "ListDomainsRequestOrderBy",
-    "ListLogsRequestOrderBy",
     "ListNamespacesRequestOrderBy",
     "ListTokensRequestOrderBy",
     "ListTriggersRequestOrderBy",
-    "LogStream",
     "NamespaceStatus",
     "NAMESPACE_TRANSIENT_STATUSES",
     "TokenStatus",
     "TOKEN_TRANSIENT_STATUSES",
     "TriggerInputType",
     "TriggerStatus",
     "TRIGGER_TRANSIENT_STATUSES",
@@ -112,15 +105,14 @@
     "Secret",
     "CreateTriggerRequestMnqNatsClientConfig",
     "CreateTriggerRequestMnqSqsClientConfig",
     "CreateTriggerRequestSqsClientConfig",
     "Container",
     "Cron",
     "Domain",
-    "Log",
     "Namespace",
     "Token",
     "Trigger",
     "UpdateTriggerRequestSqsClientConfig",
     "CreateContainerRequest",
     "CreateCronRequest",
     "CreateDomainRequest",
@@ -143,16 +135,14 @@
     "IssueJWTRequest",
     "ListContainersRequest",
     "ListContainersResponse",
     "ListCronsRequest",
     "ListCronsResponse",
     "ListDomainsRequest",
     "ListDomainsResponse",
-    "ListLogsRequest",
-    "ListLogsResponse",
     "ListNamespacesRequest",
     "ListNamespacesResponse",
     "ListTokensRequest",
     "ListTokensResponse",
     "ListTriggersRequest",
     "ListTriggersResponse",
     "UpdateContainerRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/api.py` & `scaleway_async-2.1.0/scaleway_async/container/v1beta1/api.py`

 * *Files 4% similar despite different names*

```diff
@@ -20,15 +20,14 @@
 from .types import (
     ContainerHttpOption,
     ContainerPrivacy,
     ContainerProtocol,
     ListContainersRequestOrderBy,
     ListCronsRequestOrderBy,
     ListDomainsRequestOrderBy,
-    ListLogsRequestOrderBy,
     ListNamespacesRequestOrderBy,
     ListTokensRequestOrderBy,
     ListTriggersRequestOrderBy,
     Container,
     CreateContainerRequest,
     CreateCronRequest,
     CreateDomainRequest,
@@ -39,19 +38,17 @@
     CreateTriggerRequestMnqSqsClientConfig,
     CreateTriggerRequestSqsClientConfig,
     Cron,
     Domain,
     ListContainersResponse,
     ListCronsResponse,
     ListDomainsResponse,
-    ListLogsResponse,
     ListNamespacesResponse,
     ListTokensResponse,
     ListTriggersResponse,
-    Log,
     Namespace,
     Secret,
     Token,
     Trigger,
     UpdateContainerRequest,
     UpdateCronRequest,
     UpdateNamespaceRequest,
@@ -72,15 +69,14 @@
     unmarshal_Domain,
     unmarshal_Namespace,
     unmarshal_Token,
     unmarshal_Trigger,
     unmarshal_ListContainersResponse,
     unmarshal_ListCronsResponse,
     unmarshal_ListDomainsResponse,
-    unmarshal_ListLogsResponse,
     unmarshal_ListNamespacesResponse,
     unmarshal_ListTokensResponse,
     unmarshal_ListTriggersResponse,
     marshal_CreateContainerRequest,
     marshal_CreateCronRequest,
     marshal_CreateDomainRequest,
     marshal_CreateNamespaceRequest,
@@ -828,15 +824,14 @@
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListCronsRequestOrderBy] = None,
     ) -> ListCronsResponse:
         """
         List all your crons.
-        List all your crons.
         :param container_id: UUID of the container invoked by the cron.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number.
         :param page_size: Number of crons per page.
         :param order_by: Order of the crons.
         :return: :class:`ListCronsResponse <ListCronsResponse>`
 
@@ -873,15 +868,14 @@
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListCronsRequestOrderBy] = None,
     ) -> List[Cron]:
         """
         List all your crons.
-        List all your crons.
         :param container_id: UUID of the container invoked by the cron.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number.
         :param page_size: Number of crons per page.
         :param order_by: Order of the crons.
         :return: :class:`List[Cron] <List[Cron]>`
 
@@ -984,15 +978,14 @@
         schedule: str,
         region: Optional[Region] = None,
         args: Optional[Dict[str, Any]] = None,
         name: Optional[str] = None,
     ) -> Cron:
         """
         Create a new cron.
-        Create a new cron.
         :param container_id: UUID of the container to invoke by the cron.
         :param schedule: UNIX cron shedule.
         :param region: Region to target. If none is passed will use default region from the config.
         :param args: Arguments to pass with the cron.
         :param name: Name of the cron to create.
         :return: :class:`Cron <Cron>`
 
@@ -1110,99 +1103,14 @@
             "DELETE",
             f"/containers/v1beta1/regions/{param_region}/crons/{param_cron_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Cron(res.json())
 
-    async def list_logs(
-        self,
-        *,
-        container_id: str,
-        region: Optional[Region] = None,
-        page: Optional[int] = None,
-        page_size: Optional[int] = None,
-        order_by: Optional[ListLogsRequestOrderBy] = None,
-    ) -> ListLogsResponse:
-        """
-        List your container logs.
-        List the logs of the container with the specified ID.
-        :param container_id: UUID of the container.
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param page: Page number.
-        :param page_size: Number of logs per page.
-        :param order_by: Order of the logs.
-        :return: :class:`ListLogsResponse <ListLogsResponse>`
-
-        Usage:
-        ::
-
-            result = await api.list_logs(
-                container_id="example",
-            )
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_container_id = validate_path_param("container_id", container_id)
-
-        res = self._request(
-            "GET",
-            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}/logs",
-            params={
-                "order_by": order_by,
-                "page": page,
-                "page_size": page_size or self.client.default_page_size,
-            },
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_ListLogsResponse(res.json())
-
-    async def list_logs_all(
-        self,
-        *,
-        container_id: str,
-        region: Optional[Region] = None,
-        page: Optional[int] = None,
-        page_size: Optional[int] = None,
-        order_by: Optional[ListLogsRequestOrderBy] = None,
-    ) -> List[Log]:
-        """
-        List your container logs.
-        List the logs of the container with the specified ID.
-        :param container_id: UUID of the container.
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param page: Page number.
-        :param page_size: Number of logs per page.
-        :param order_by: Order of the logs.
-        :return: :class:`List[Log] <List[Log]>`
-
-        Usage:
-        ::
-
-            result = await api.list_logs_all(
-                container_id="example",
-            )
-        """
-
-        return await fetch_all_pages_async(
-            type=ListLogsResponse,
-            key="logs",
-            fetcher=self.list_logs,
-            args={
-                "container_id": container_id,
-                "region": region,
-                "page": page,
-                "page_size": page_size,
-                "order_by": order_by,
-            },
-        )
-
     async def list_domains(
         self,
         *,
         container_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
@@ -1442,15 +1350,17 @@
         expires_at: Optional[datetime] = None,
     ) -> Token:
         """
         Create a JWT token.
         Deprecated in favor of CreateToken.
         :param region: Region to target. If none is passed will use default region from the config.
         :param container_id:
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
         :param namespace_id:
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
         :param expires_at:
         :return: :class:`Token <Token>`
         :deprecated
 
         Usage:
         ::
 
@@ -1485,18 +1395,19 @@
         container_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
         description: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> Token:
         """
         Create a new revocable token.
-        Create a new revocable token.
         :param region: Region to target. If none is passed will use default region from the config.
         :param container_id: UUID of the container to create the token for.
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
         :param namespace_id: UUID of the namespace to create the token for.
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
         :param description: Description of the token.
         :param expires_at: Expiry date of the token.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
@@ -1732,16 +1643,19 @@
         Create a trigger.
         Create a new trigger for a specified container.
         :param name: Name of the trigger.
         :param container_id: ID of the container to trigger.
         :param region: Region to target. If none is passed will use default region from the config.
         :param description: Description of the trigger.
         :param scw_sqs_config: Configuration for a Scaleway Messaging and Queuing SQS queue.
+        One-Of ('config'): at most one of 'scw_sqs_config', 'scw_nats_config', 'sqs_config' could be set.
         :param scw_nats_config: Configuration for a Scaleway Messaging and Queuing NATS subject.
+        One-Of ('config'): at most one of 'scw_sqs_config', 'scw_nats_config', 'sqs_config' could be set.
         :param sqs_config: Configuration for an AWS SQS queue.
+        One-Of ('config'): at most one of 'scw_sqs_config', 'scw_nats_config', 'sqs_config' could be set.
         :return: :class:`Trigger <Trigger>`
 
         Usage:
         ::
 
             result = await api.create_trigger(
                 name="example",
@@ -1859,16 +1773,19 @@
         List all triggers.
         List all triggers belonging to a specified Organization or Project.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number to return.
         :param page_size: Maximum number of triggers to return per page.
         :param order_by: Order in which to return results.
         :param container_id: ID of the container the triggers belongs to.
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
         :param namespace_id: ID of the namespace the triggers belongs to.
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
         :param project_id: ID of the project the triggers belongs to.
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
         :return: :class:`ListTriggersResponse <ListTriggersResponse>`
 
         Usage:
         ::
 
             result = await api.list_triggers()
         """
@@ -1912,16 +1829,19 @@
         List all triggers.
         List all triggers belonging to a specified Organization or Project.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number to return.
         :param page_size: Maximum number of triggers to return per page.
         :param order_by: Order in which to return results.
         :param container_id: ID of the container the triggers belongs to.
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
         :param namespace_id: ID of the namespace the triggers belongs to.
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
         :param project_id: ID of the project the triggers belongs to.
+        One-Of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
         :return: :class:`List[Trigger] <List[Trigger]>`
 
         Usage:
         ::
 
             result = await api.list_triggers_all()
         """
@@ -1954,14 +1874,15 @@
         Update a trigger.
         Update a trigger with a specified ID.
         :param trigger_id: ID of the trigger to update.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the trigger.
         :param description: Description of the trigger.
         :param sqs_config: Configuration for an AWS SQS queue.
+        One-Of ('config'): at most one of 'sqs_config' could be set.
         :return: :class:`Trigger <Trigger>`
 
         Usage:
         ::
 
             result = await api.update_trigger(
                 trigger_id="example",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/content.py` & `scaleway_async-2.1.0/scaleway_async/container/v1beta1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/function/v1beta1/marshalling.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,50 +6,126 @@
 
 from scaleway_core.profile import ProfileDefaults
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from .types import (
-    SecretHashedValue,
-    Container,
     Cron,
     Domain,
+    SecretHashedValue,
+    Function,
     Namespace,
     Token,
     TriggerMnqNatsClientConfig,
     TriggerMnqSqsClientConfig,
     TriggerSqsClientConfig,
     Trigger,
-    ListContainersResponse,
+    DownloadURL,
     ListCronsResponse,
     ListDomainsResponse,
-    Log,
-    ListLogsResponse,
+    Runtime,
+    ListFunctionRuntimesResponse,
+    ListFunctionsResponse,
     ListNamespacesResponse,
     ListTokensResponse,
     ListTriggersResponse,
-    Secret,
-    CreateContainerRequest,
+    UploadURL,
     CreateCronRequest,
     CreateDomainRequest,
+    Secret,
+    CreateFunctionRequest,
     CreateNamespaceRequest,
     CreateTokenRequest,
     CreateTriggerRequestMnqNatsClientConfig,
     CreateTriggerRequestMnqSqsClientConfig,
     CreateTriggerRequestSqsClientConfig,
     CreateTriggerRequest,
-    UpdateContainerRequest,
     UpdateCronRequest,
+    UpdateFunctionRequest,
     UpdateNamespaceRequest,
     UpdateTriggerRequestSqsClientConfig,
     UpdateTriggerRequest,
 )
 
 
+def unmarshal_Cron(data: Any) -> Cron:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'Cron' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("id", None)
+    if field is not None:
+        args["id"] = field
+
+    field = data.get("function_id", None)
+    if field is not None:
+        args["function_id"] = field
+
+    field = data.get("schedule", None)
+    if field is not None:
+        args["schedule"] = field
+
+    field = data.get("status", None)
+    if field is not None:
+        args["status"] = field
+
+    field = data.get("name", None)
+    if field is not None:
+        args["name"] = field
+
+    field = data.get("args", None)
+    if field is not None:
+        args["args"] = field
+    else:
+        args["args"] = None
+
+    return Cron(**args)
+
+
+def unmarshal_Domain(data: Any) -> Domain:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'Domain' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("id", None)
+    if field is not None:
+        args["id"] = field
+
+    field = data.get("hostname", None)
+    if field is not None:
+        args["hostname"] = field
+
+    field = data.get("function_id", None)
+    if field is not None:
+        args["function_id"] = field
+
+    field = data.get("url", None)
+    if field is not None:
+        args["url"] = field
+
+    field = data.get("status", None)
+    if field is not None:
+        args["status"] = field
+
+    field = data.get("error_message", None)
+    if field is not None:
+        args["error_message"] = field
+    else:
+        args["error_message"] = None
+
+    return Domain(**args)
+
+
 def unmarshal_SecretHashedValue(data: Any) -> SecretHashedValue:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'SecretHashedValue' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -61,18 +137,18 @@
     field = data.get("hashed_value", None)
     if field is not None:
         args["hashed_value"] = field
 
     return SecretHashedValue(**args)
 
 
-def unmarshal_Container(data: Any) -> Container:
+def unmarshal_Function(data: Any) -> Function:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Container' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Function' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
@@ -97,145 +173,83 @@
     if field is not None:
         args["min_scale"] = field
 
     field = data.get("max_scale", None)
     if field is not None:
         args["max_scale"] = field
 
+    field = data.get("runtime", None)
+    if field is not None:
+        args["runtime"] = field
+
     field = data.get("memory_limit", None)
     if field is not None:
         args["memory_limit"] = field
 
     field = data.get("cpu_limit", None)
     if field is not None:
         args["cpu_limit"] = field
 
-    field = data.get("privacy", None)
-    if field is not None:
-        args["privacy"] = field
-
-    field = data.get("registry_image", None)
-    if field is not None:
-        args["registry_image"] = field
-
-    field = data.get("max_concurrency", None)
-    if field is not None:
-        args["max_concurrency"] = field
-
-    field = data.get("timeout", None)
-    if field is not None:
-        args["timeout"] = field
-
-    field = data.get("error_message", None)
+    field = data.get("handler", None)
     if field is not None:
-        args["error_message"] = field
+        args["handler"] = field
 
-    field = data.get("description", None)
+    field = data.get("privacy", None)
     if field is not None:
-        args["description"] = field
+        args["privacy"] = field
 
     field = data.get("domain_name", None)
     if field is not None:
         args["domain_name"] = field
 
-    field = data.get("protocol", None)
-    if field is not None:
-        args["protocol"] = field
-
-    field = data.get("port", None)
-    if field is not None:
-        args["port"] = field
-
     field = data.get("secret_environment_variables", None)
     if field is not None:
         args["secret_environment_variables"] = (
             [unmarshal_SecretHashedValue(v) for v in field]
             if field is not None
             else None
         )
 
-    field = data.get("http_option", None)
-    if field is not None:
-        args["http_option"] = field
-
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
-    return Container(**args)
-
-
-def unmarshal_Cron(data: Any) -> Cron:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Cron' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("id", None)
-    if field is not None:
-        args["id"] = field
-
-    field = data.get("container_id", None)
-    if field is not None:
-        args["container_id"] = field
-
-    field = data.get("schedule", None)
-    if field is not None:
-        args["schedule"] = field
-
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
-
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
-    field = data.get("args", None)
+    field = data.get("http_option", None)
     if field is not None:
-        args["args"] = field
-
-    return Cron(**args)
-
-
-def unmarshal_Domain(data: Any) -> Domain:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Domain' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
+        args["http_option"] = field
 
-    field = data.get("id", None)
+    field = data.get("runtime_message", None)
     if field is not None:
-        args["id"] = field
+        args["runtime_message"] = field
 
-    field = data.get("hostname", None)
-    if field is not None:
-        args["hostname"] = field
-
-    field = data.get("container_id", None)
+    field = data.get("timeout", None)
     if field is not None:
-        args["container_id"] = field
+        args["timeout"] = field
+    else:
+        args["timeout"] = None
 
-    field = data.get("url", None)
+    field = data.get("error_message", None)
     if field is not None:
-        args["url"] = field
+        args["error_message"] = field
+    else:
+        args["error_message"] = None
 
-    field = data.get("status", None)
+    field = data.get("build_message", None)
     if field is not None:
-        args["status"] = field
+        args["build_message"] = field
+    else:
+        args["build_message"] = None
 
-    field = data.get("error_message", None)
+    field = data.get("description", None)
     if field is not None:
-        args["error_message"] = field
+        args["description"] = field
+    else:
+        args["description"] = None
 
-    return Domain(**args)
+    return Function(**args)
 
 
 def unmarshal_Namespace(data: Any) -> Namespace:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Namespace' failed as data isn't a dictionary."
         )
@@ -285,18 +299,22 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("error_message", None)
     if field is not None:
         args["error_message"] = field
+    else:
+        args["error_message"] = None
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
+    else:
+        args["description"] = None
 
     return Namespace(**args)
 
 
 def unmarshal_Token(data: Any) -> Token:
     if not isinstance(data, dict):
         raise TypeError(
@@ -313,33 +331,43 @@
     if field is not None:
         args["token"] = field
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
-    field = data.get("container_id", None)
+    field = data.get("function_id", None)
     if field is not None:
-        args["container_id"] = field
+        args["function_id"] = field
+    else:
+        args["function_id"] = None
 
     field = data.get("namespace_id", None)
     if field is not None:
         args["namespace_id"] = field
+    else:
+        args["namespace_id"] = None
 
     field = data.get("public_key", None)
     if field is not None:
         args["public_key"] = field
+    else:
+        args["public_key"] = None
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
+    else:
+        args["description"] = None
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     return Token(**args)
 
 
 def unmarshal_TriggerMnqNatsClientConfig(data: Any) -> TriggerMnqNatsClientConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -360,21 +388,19 @@
     if field is not None:
         args["mnq_project_id"] = field
 
     field = data.get("mnq_region", None)
     if field is not None:
         args["mnq_region"] = field
 
-    field = data.get("mnq_namespace_id", None)
-    if field is not None:
-        args["mnq_namespace_id"] = field
-
     field = data.get("mnq_credential_id", None)
     if field is not None:
         args["mnq_credential_id"] = field
+    else:
+        args["mnq_credential_id"] = None
 
     return TriggerMnqNatsClientConfig(**args)
 
 
 def unmarshal_TriggerMnqSqsClientConfig(data: Any) -> TriggerMnqSqsClientConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -391,21 +417,19 @@
     if field is not None:
         args["mnq_project_id"] = field
 
     field = data.get("mnq_region", None)
     if field is not None:
         args["mnq_region"] = field
 
-    field = data.get("mnq_namespace_id", None)
-    if field is not None:
-        args["mnq_namespace_id"] = field
-
     field = data.get("mnq_credential_id", None)
     if field is not None:
         args["mnq_credential_id"] = field
+    else:
+        args["mnq_credential_id"] = None
 
     return TriggerMnqSqsClientConfig(**args)
 
 
 def unmarshal_TriggerSqsClientConfig(data: Any) -> TriggerSqsClientConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -449,64 +473,70 @@
     if field is not None:
         args["name"] = field
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
-    field = data.get("container_id", None)
+    field = data.get("function_id", None)
     if field is not None:
-        args["container_id"] = field
+        args["function_id"] = field
 
     field = data.get("input_type", None)
     if field is not None:
         args["input_type"] = field
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("error_message", None)
     if field is not None:
         args["error_message"] = field
+    else:
+        args["error_message"] = None
 
     field = data.get("scw_sqs_config", None)
     if field is not None:
         args["scw_sqs_config"] = unmarshal_TriggerMnqSqsClientConfig(field)
+    else:
+        args["scw_sqs_config"] = None
 
     field = data.get("scw_nats_config", None)
     if field is not None:
         args["scw_nats_config"] = unmarshal_TriggerMnqNatsClientConfig(field)
+    else:
+        args["scw_nats_config"] = None
 
     field = data.get("sqs_config", None)
     if field is not None:
         args["sqs_config"] = unmarshal_TriggerSqsClientConfig(field)
+    else:
+        args["sqs_config"] = None
 
     return Trigger(**args)
 
 
-def unmarshal_ListContainersResponse(data: Any) -> ListContainersResponse:
+def unmarshal_DownloadURL(data: Any) -> DownloadURL:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListContainersResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'DownloadURL' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("containers", None)
+    field = data.get("url", None)
     if field is not None:
-        args["containers"] = (
-            [unmarshal_Container(v) for v in field] if field is not None else None
-        )
+        args["url"] = field
 
-    field = data.get("total_count", None)
+    field = data.get("headers", None)
     if field is not None:
-        args["total_count"] = field
+        args["headers"] = field
 
-    return ListContainersResponse(**args)
+    return DownloadURL(**args)
 
 
 def unmarshal_ListCronsResponse(data: Any) -> ListCronsResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ListCronsResponse' failed as data isn't a dictionary."
         )
@@ -543,66 +573,105 @@
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
     return ListDomainsResponse(**args)
 
 
-def unmarshal_Log(data: Any) -> Log:
+def unmarshal_Runtime(data: Any) -> Runtime:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Log' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Runtime' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("message", None)
+    field = data.get("name", None)
     if field is not None:
-        args["message"] = field
+        args["name"] = field
 
-    field = data.get("id", None)
+    field = data.get("language", None)
     if field is not None:
-        args["id"] = field
+        args["language"] = field
+
+    field = data.get("version", None)
+    if field is not None:
+        args["version"] = field
+
+    field = data.get("default_handler", None)
+    if field is not None:
+        args["default_handler"] = field
+
+    field = data.get("code_sample", None)
+    if field is not None:
+        args["code_sample"] = field
+
+    field = data.get("status", None)
+    if field is not None:
+        args["status"] = field
+
+    field = data.get("status_message", None)
+    if field is not None:
+        args["status_message"] = field
+
+    field = data.get("extension", None)
+    if field is not None:
+        args["extension"] = field
 
-    field = data.get("level", None)
+    field = data.get("implementation", None)
     if field is not None:
-        args["level"] = field
+        args["implementation"] = field
 
-    field = data.get("source", None)
+    field = data.get("logo_url", None)
     if field is not None:
-        args["source"] = field
+        args["logo_url"] = field
 
-    field = data.get("stream", None)
+    return Runtime(**args)
+
+
+def unmarshal_ListFunctionRuntimesResponse(data: Any) -> ListFunctionRuntimesResponse:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'ListFunctionRuntimesResponse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("runtimes", None)
     if field is not None:
-        args["stream"] = field
+        args["runtimes"] = (
+            [unmarshal_Runtime(v) for v in field] if field is not None else None
+        )
 
-    field = data.get("timestamp", None)
+    field = data.get("total_count", None)
     if field is not None:
-        args["timestamp"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["total_count"] = field
 
-    return Log(**args)
+    return ListFunctionRuntimesResponse(**args)
 
 
-def unmarshal_ListLogsResponse(data: Any) -> ListLogsResponse:
+def unmarshal_ListFunctionsResponse(data: Any) -> ListFunctionsResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListLogsResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListFunctionsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("logs", None)
+    field = data.get("functions", None)
     if field is not None:
-        args["logs"] = [unmarshal_Log(v) for v in field] if field is not None else None
+        args["functions"] = (
+            [unmarshal_Function(v) for v in field] if field is not None else None
+        )
 
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    return ListLogsResponse(**args)
+    return ListFunctionsResponse(**args)
 
 
 def unmarshal_ListNamespacesResponse(data: Any) -> ListNamespacesResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary."
         )
@@ -660,14 +729,69 @@
         args["triggers"] = (
             [unmarshal_Trigger(v) for v in field] if field is not None else None
         )
 
     return ListTriggersResponse(**args)
 
 
+def unmarshal_UploadURL(data: Any) -> UploadURL:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'UploadURL' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("url", None)
+    if field is not None:
+        args["url"] = field
+
+    field = data.get("headers", None)
+    if field is not None:
+        args["headers"] = field
+
+    return UploadURL(**args)
+
+
+def marshal_CreateCronRequest(
+    request: CreateCronRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.function_id is not None:
+        output["function_id"] = request.function_id
+
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
+
+    if request.args is not None:
+        output["args"] = request.args
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
+
+
+def marshal_CreateDomainRequest(
+    request: CreateDomainRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.hostname is not None:
+        output["hostname"] = request.hostname
+
+    if request.function_id is not None:
+        output["function_id"] = request.function_id
+
+    return output
+
+
 def marshal_Secret(
     request: Secret,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.key is not None:
@@ -675,16 +799,16 @@
 
     if request.value is not None:
         output["value"] = request.value
 
     return output
 
 
-def marshal_CreateContainerRequest(
-    request: CreateContainerRequest,
+def marshal_CreateFunctionRequest(
+    request: CreateFunctionRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.namespace_id is not None:
         output["namespace_id"] = request.namespace_id
 
@@ -696,89 +820,44 @@
 
     if request.min_scale is not None:
         output["min_scale"] = request.min_scale
 
     if request.max_scale is not None:
         output["max_scale"] = request.max_scale
 
+    if request.runtime is not None:
+        output["runtime"] = str(request.runtime)
+
     if request.memory_limit is not None:
         output["memory_limit"] = request.memory_limit
 
-    if request.cpu_limit is not None:
-        output["cpu_limit"] = request.cpu_limit
-
     if request.timeout is not None:
         output["timeout"] = request.timeout
 
+    if request.handler is not None:
+        output["handler"] = request.handler
+
     if request.privacy is not None:
         output["privacy"] = str(request.privacy)
 
     if request.description is not None:
         output["description"] = request.description
 
-    if request.registry_image is not None:
-        output["registry_image"] = request.registry_image
-
-    if request.max_concurrency is not None:
-        output["max_concurrency"] = request.max_concurrency
-
-    if request.protocol is not None:
-        output["protocol"] = str(request.protocol)
-
-    if request.port is not None:
-        output["port"] = request.port
-
     if request.secret_environment_variables is not None:
         output["secret_environment_variables"] = [
             marshal_Secret(item, defaults)
             for item in request.secret_environment_variables
         ]
 
     if request.http_option is not None:
         output["http_option"] = str(request.http_option)
 
     return output
 
 
-def marshal_CreateCronRequest(
-    request: CreateCronRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
-
-    if request.container_id is not None:
-        output["container_id"] = request.container_id
-
-    if request.schedule is not None:
-        output["schedule"] = request.schedule
-
-    if request.args is not None:
-        output["args"] = request.args
-
-    if request.name is not None:
-        output["name"] = request.name
-
-    return output
-
-
-def marshal_CreateDomainRequest(
-    request: CreateDomainRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
-
-    if request.hostname is not None:
-        output["hostname"] = request.hostname
-
-    if request.container_id is not None:
-        output["container_id"] = request.container_id
-
-    return output
-
-
 def marshal_CreateNamespaceRequest(
     request: CreateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.name is not None:
@@ -806,15 +885,15 @@
     request: CreateTokenRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
     output.update(
         resolve_one_of(
             [
-                OneOfPossibility("container_id", request.container_id),
+                OneOfPossibility("function_id", request.function_id),
                 OneOfPossibility("namespace_id", request.namespace_id),
             ]
         ),
     )
 
     if request.description is not None:
         output["description"] = request.description
@@ -839,17 +918,14 @@
 
     if request.mnq_project_id is not None:
         output["mnq_project_id"] = request.mnq_project_id
 
     if request.mnq_region is not None:
         output["mnq_region"] = request.mnq_region
 
-    if request.mnq_namespace_id is not None:
-        output["mnq_namespace_id"] = request.mnq_namespace_id
-
     return output
 
 
 def marshal_CreateTriggerRequestMnqSqsClientConfig(
     request: CreateTriggerRequestMnqSqsClientConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
@@ -860,17 +936,14 @@
 
     if request.mnq_project_id is not None:
         output["mnq_project_id"] = request.mnq_project_id
 
     if request.mnq_region is not None:
         output["mnq_region"] = request.mnq_region
 
-    if request.mnq_namespace_id is not None:
-        output["mnq_namespace_id"] = request.mnq_namespace_id
-
     return output
 
 
 def marshal_CreateTriggerRequestSqsClientConfig(
     request: CreateTriggerRequestSqsClientConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
@@ -905,101 +978,92 @@
             ]
         ),
     )
 
     if request.name is not None:
         output["name"] = request.name
 
-    if request.container_id is not None:
-        output["container_id"] = request.container_id
+    if request.function_id is not None:
+        output["function_id"] = request.function_id
 
     if request.description is not None:
         output["description"] = request.description
 
     return output
 
 
-def marshal_UpdateContainerRequest(
-    request: UpdateContainerRequest,
+def marshal_UpdateCronRequest(
+    request: UpdateCronRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.function_id is not None:
+        output["function_id"] = request.function_id
+
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
+
+    if request.args is not None:
+        output["args"] = request.args
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
+
+
+def marshal_UpdateFunctionRequest(
+    request: UpdateFunctionRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.environment_variables is not None:
         output["environment_variables"] = request.environment_variables
 
     if request.min_scale is not None:
         output["min_scale"] = request.min_scale
 
     if request.max_scale is not None:
         output["max_scale"] = request.max_scale
 
+    if request.runtime is not None:
+        output["runtime"] = str(request.runtime)
+
     if request.memory_limit is not None:
         output["memory_limit"] = request.memory_limit
 
-    if request.cpu_limit is not None:
-        output["cpu_limit"] = request.cpu_limit
-
     if request.timeout is not None:
         output["timeout"] = request.timeout
 
     if request.redeploy is not None:
         output["redeploy"] = request.redeploy
 
+    if request.handler is not None:
+        output["handler"] = request.handler
+
     if request.privacy is not None:
         output["privacy"] = str(request.privacy)
 
     if request.description is not None:
         output["description"] = request.description
 
-    if request.registry_image is not None:
-        output["registry_image"] = request.registry_image
-
-    if request.max_concurrency is not None:
-        output["max_concurrency"] = request.max_concurrency
-
-    if request.protocol is not None:
-        output["protocol"] = str(request.protocol)
-
-    if request.port is not None:
-        output["port"] = request.port
-
     if request.secret_environment_variables is not None:
         output["secret_environment_variables"] = [
             marshal_Secret(item, defaults)
             for item in request.secret_environment_variables
         ]
 
     if request.http_option is not None:
         output["http_option"] = str(request.http_option)
 
     return output
 
 
-def marshal_UpdateCronRequest(
-    request: UpdateCronRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
-
-    if request.container_id is not None:
-        output["container_id"] = request.container_id
-
-    if request.schedule is not None:
-        output["schedule"] = request.schedule
-
-    if request.args is not None:
-        output["args"] = request.args
-
-    if request.name is not None:
-        output["name"] = request.name
-
-    return output
-
-
 def marshal_UpdateNamespaceRequest(
     request: UpdateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.environment_variables is not None:
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/container/v1beta1/types.py` & `scaleway_async-2.1.0/scaleway_async/container/v1beta1/types.py`

 * *Files 4% similar despite different names*

```diff
@@ -105,22 +105,14 @@
     HOSTNAME_ASC = "hostname_asc"
     HOSTNAME_DESC = "hostname_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListLogsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
-    TIMESTAMP_DESC = "timestamp_desc"
-    TIMESTAMP_ASC = "timestamp_asc"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
 class ListNamespacesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
@@ -139,23 +131,14 @@
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class LogStream(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN = "unknown"
-    STDOUT = "stdout"
-    STDERR = "stderr"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
 class NamespaceStatus(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN = "unknown"
     READY = "ready"
     DELETING = "deleting"
     ERROR = "error"
     LOCKED = "locked"
     CREATING = "creating"
@@ -221,19 +204,17 @@
     mnq_project_id: str
     """
     ID of the Messaging and Queuing project.
     """
 
     mnq_region: str
     """
-    Currently, only the `fr-par` region is available.
+    Currently, only the `fr-par` and `nl-ams` regions are available.
     """
 
-    mnq_namespace_id: Optional[str]
-
     mnq_credential_id: Optional[str]
     """
     ID of the Messaging and Queuing credentials used to subscribe to the NATS subject.
     """
 
 
 @dataclass
@@ -246,19 +227,17 @@
     mnq_project_id: str
     """
     ID of the Messaging and Queuing project.
     """
 
     mnq_region: str
     """
-    Currently, only the `fr-par` region is available.
+    Currently, only the `fr-par` and `nl-ams` regions are available.
     """
 
-    mnq_namespace_id: Optional[str]
-
     mnq_credential_id: Optional[str]
     """
     ID of the Messaging and Queuing credentials used to read from the SQS queue.
     """
 
 
 @dataclass
@@ -294,19 +273,17 @@
     mnq_project_id: str
     """
     ID of the Messaging and Queuing project.
     """
 
     mnq_region: str
     """
-    Currently, only the `fr-par` region is available.
+    Currently, only the `fr-par` and `nl-ams` regions are available.
     """
 
-    mnq_namespace_id: Optional[str]
-
 
 @dataclass
 class CreateTriggerRequestMnqSqsClientConfig:
     queue: str
     """
     Name of the SQS queue the trigger should listen to.
     """
@@ -314,19 +291,17 @@
     mnq_project_id: str
     """
     You must have activated SQS on this project.
     """
 
     mnq_region: str
     """
-    Currently, only the `fr-par` region is available.
+    Currently, only the `fr-par` and `nl-ams` regions are available.
     """
 
-    mnq_namespace_id: Optional[str]
-
 
 @dataclass
 class CreateTriggerRequestSqsClientConfig:
     endpoint: str
 
     queue_url: str
 
@@ -508,38 +483,14 @@
     error_message: Optional[str]
     """
     Last error message of the domain.
     """
 
 
 @dataclass
-class Log:
-    message: str
-
-    id: str
-
-    level: str
-    """
-    Contains the severity of the log (info, debug, error, ...).
-    """
-
-    source: str
-    """
-    Source of the log (core runtime or user code).
-    """
-
-    stream: LogStream
-    """
-    Can be stdout or stderr.
-    """
-
-    timestamp: Optional[datetime]
-
-
-@dataclass
 class Namespace:
     id: str
     """
     UUID of the namespace.
     """
 
     name: str
@@ -1224,49 +1175,14 @@
     total_count: int
     """
     Total number of domains.
     """
 
 
 @dataclass
-class ListLogsRequest:
-    container_id: str
-    """
-    UUID of the container.
-    """
-
-    region: Optional[Region]
-    """
-    Region to target. If none is passed will use default region from the config.
-    """
-
-    page: Optional[int]
-    """
-    Page number.
-    """
-
-    page_size: Optional[int]
-    """
-    Number of logs per page.
-    """
-
-    order_by: Optional[ListLogsRequestOrderBy]
-    """
-    Order of the logs.
-    """
-
-
-@dataclass
-class ListLogsResponse:
-    logs: List[Log]
-
-    total_count: int
-
-
-@dataclass
 class ListNamespacesRequest:
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,32 +1,33 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import ACLRuleAction
 from .types import ACLRuleDirection
 from .types import ACLRuleProtocol
 from .types import EngineSettingPropertyType
 from .types import InstanceLogStatus
-from .content import INSTANCELOG_TRANSIENT_STATUSES
+from .content import INSTANCE_LOG_TRANSIENT_STATUSES
 from .types import InstanceStatus
 from .content import INSTANCE_TRANSIENT_STATUSES
 from .types import ListDatabasesRequestOrderBy
 from .types import ListInstanceLogsRequestOrderBy
 from .types import ListInstancesRequestOrderBy
 from .types import ListPrivilegesRequestOrderBy
 from .types import ListSnapshotsRequestOrderBy
 from .types import ListUsersRequestOrderBy
 from .types import MaintenanceStatus
 from .content import MAINTENANCE_TRANSIENT_STATUSES
 from .types import NodeTypeGeneration
 from .types import NodeTypeStock
 from .types import Permission
 from .types import ReadReplicaStatus
-from .content import READREPLICA_TRANSIENT_STATUSES
+from .content import READ_REPLICA_TRANSIENT_STATUSES
 from .types import SnapshotStatus
 from .content import SNAPSHOT_TRANSIENT_STATUSES
+from .types import StorageClass
 from .types import VolumeType
 from .types import EndpointDirectAccessDetails
 from .types import EndpointLoadBalancerDetails
 from .types import EndpointPrivateNetworkDetails
 from .types import EndpointSpecPrivateNetworkIpamConfig
 from .types import ReadReplicaEndpointSpecPrivateNetworkIpamConfig
 from .types import EngineSetting
@@ -41,31 +42,34 @@
 from .types import LogsPolicy
 from .types import Maintenance
 from .types import ReadReplica
 from .types import UpgradableVersion
 from .types import Volume
 from .types import NodeTypeVolumeConstraintSizes
 from .types import NodeTypeVolumeType
+from .types import SnapshotVolumeType
 from .types import ACLRuleRequest
 from .types import ACLRule
 from .types import EndpointSpec
 from .types import ReadReplicaEndpointSpec
 from .types import DatabaseEngine
 from .types import Database
 from .types import ListInstanceLogsDetailsResponseInstanceLogDetail
 from .types import InstanceLog
 from .types import Instance
 from .types import NodeType
 from .types import Privilege
 from .types import Snapshot
 from .types import User
+from .types import UpgradeInstanceRequestMajorUpgradeWorkflow
 from .types import AddInstanceACLRulesRequest
 from .types import AddInstanceACLRulesResponse
 from .types import AddInstanceSettingsRequest
 from .types import AddInstanceSettingsResponse
+from .types import ApplyInstanceMaintenanceRequest
 from .types import CloneInstanceRequest
 from .types import CreateDatabaseRequest
 from .types import CreateEndpointRequest
 from .types import CreateInstanceFromSnapshotRequest
 from .types import CreateInstanceRequest
 from .types import CreateReadReplicaEndpointRequest
 from .types import CreateReadReplicaRequest
@@ -128,32 +132,33 @@
 
 __all__ = [
     "ACLRuleAction",
     "ACLRuleDirection",
     "ACLRuleProtocol",
     "EngineSettingPropertyType",
     "InstanceLogStatus",
-    "INSTANCELOG_TRANSIENT_STATUSES",
+    "INSTANCE_LOG_TRANSIENT_STATUSES",
     "InstanceStatus",
     "INSTANCE_TRANSIENT_STATUSES",
     "ListDatabasesRequestOrderBy",
     "ListInstanceLogsRequestOrderBy",
     "ListInstancesRequestOrderBy",
     "ListPrivilegesRequestOrderBy",
     "ListSnapshotsRequestOrderBy",
     "ListUsersRequestOrderBy",
     "MaintenanceStatus",
     "MAINTENANCE_TRANSIENT_STATUSES",
     "NodeTypeGeneration",
     "NodeTypeStock",
     "Permission",
     "ReadReplicaStatus",
-    "READREPLICA_TRANSIENT_STATUSES",
+    "READ_REPLICA_TRANSIENT_STATUSES",
     "SnapshotStatus",
     "SNAPSHOT_TRANSIENT_STATUSES",
+    "StorageClass",
     "VolumeType",
     "EndpointDirectAccessDetails",
     "EndpointLoadBalancerDetails",
     "EndpointPrivateNetworkDetails",
     "EndpointSpecPrivateNetworkIpamConfig",
     "ReadReplicaEndpointSpecPrivateNetworkIpamConfig",
     "EngineSetting",
@@ -168,31 +173,34 @@
     "LogsPolicy",
     "Maintenance",
     "ReadReplica",
     "UpgradableVersion",
     "Volume",
     "NodeTypeVolumeConstraintSizes",
     "NodeTypeVolumeType",
+    "SnapshotVolumeType",
     "ACLRuleRequest",
     "ACLRule",
     "EndpointSpec",
     "ReadReplicaEndpointSpec",
     "DatabaseEngine",
     "Database",
     "ListInstanceLogsDetailsResponseInstanceLogDetail",
     "InstanceLog",
     "Instance",
     "NodeType",
     "Privilege",
     "Snapshot",
     "User",
+    "UpgradeInstanceRequestMajorUpgradeWorkflow",
     "AddInstanceACLRulesRequest",
     "AddInstanceACLRulesResponse",
     "AddInstanceSettingsRequest",
     "AddInstanceSettingsResponse",
+    "ApplyInstanceMaintenanceRequest",
     "CloneInstanceRequest",
     "CreateDatabaseRequest",
     "CreateEndpointRequest",
     "CreateInstanceFromSnapshotRequest",
     "CreateInstanceRequest",
     "CreateReadReplicaEndpointRequest",
     "CreateReadReplicaRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/api.py` & `scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/api.py`

 * *Files 1% similar despite different names*

```diff
@@ -60,14 +60,15 @@
     ListInstanceLogsResponse,
     ListInstancesResponse,
     ListNodeTypesResponse,
     ListPrivilegesResponse,
     ListSnapshotsResponse,
     ListUsersResponse,
     LogsPolicy,
+    Maintenance,
     MigrateEndpointRequest,
     NodeType,
     Privilege,
     PurgeInstanceLogsRequest,
     ReadReplica,
     ReadReplicaEndpointSpec,
     SetInstanceACLRulesRequest,
@@ -76,24 +77,26 @@
     SetInstanceSettingsResponse,
     SetPrivilegeRequest,
     Snapshot,
     UpdateInstanceRequest,
     UpdateSnapshotRequest,
     UpdateUserRequest,
     UpgradeInstanceRequest,
+    UpgradeInstanceRequestMajorUpgradeWorkflow,
     User,
 )
 from .content import (
-    INSTANCELOG_TRANSIENT_STATUSES,
+    INSTANCE_LOG_TRANSIENT_STATUSES,
     INSTANCE_TRANSIENT_STATUSES,
-    READREPLICA_TRANSIENT_STATUSES,
+    READ_REPLICA_TRANSIENT_STATUSES,
     SNAPSHOT_TRANSIENT_STATUSES,
 )
 from .marshalling import (
     unmarshal_Endpoint,
+    unmarshal_Maintenance,
     unmarshal_ReadReplica,
     unmarshal_Database,
     unmarshal_InstanceLog,
     unmarshal_Instance,
     unmarshal_Privilege,
     unmarshal_Snapshot,
     unmarshal_User,
@@ -308,25 +311,35 @@
         instance_id: str,
         region: Optional[Region] = None,
         node_type: Optional[str] = None,
         enable_ha: Optional[bool] = None,
         volume_size: Optional[int] = None,
         volume_type: Optional[VolumeType] = None,
         upgradable_version_id: Optional[str] = None,
+        major_upgrade_workflow: Optional[
+            UpgradeInstanceRequestMajorUpgradeWorkflow
+        ] = None,
     ) -> Instance:
         """
         Upgrade a Database Instance.
         Upgrade your current Database Instance specifications like node type, high availability, volume, or the database engine version. Note that upon upgrade the `enable_ha` parameter can only be set to `true`.
         :param instance_id: UUID of the Database Instance you want to upgrade.
         :param region: Region to target. If none is passed will use default region from the config.
         :param node_type: Node type of the Database Instance you want to upgrade to.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :param enable_ha: Defines whether or not High Availability should be enabled on the Database Instance.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :param volume_size: Increase your Block volume size.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :param volume_type: Change your Database Instance storage type.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :param upgradable_version_id: This will create a new Database Instance with same specifications as the current one and perform a Database Engine upgrade.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
+        :param major_upgrade_workflow: Upgrade your database engine to a new major version including instance endpoints.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = await api.upgrade_instance(
                 instance_id="example",
@@ -346,14 +359,15 @@
                     instance_id=instance_id,
                     region=region,
                     node_type=node_type,
                     enable_ha=enable_ha,
                     volume_size=volume_size,
                     volume_type=volume_type,
                     upgradable_version_id=upgradable_version_id,
+                    major_upgrade_workflow=major_upgrade_workflow,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Instance(res.json())
@@ -556,15 +570,17 @@
         Create a new Database Instance. You must set the `engine`, `user_name`, `password` and `node_type` parameters. Optionally, you can specify the volume type and size.
         :param engine: Database engine of the Database Instance.
         :param user_name: Username created when the Database Instance is created.
         :param password: Password of the user.
         :param node_type: Type of node to use for the Database Instance.
         :param region: Region to target. If none is passed will use default region from the config.
         :param organization_id: Please use project_id instead.
+        One-Of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
         :param project_id: The Project ID on which the Database Instance will be created.
+        One-Of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
         :param name: Name of the Database Instance.
         :param is_ha_cluster: Defines whether or not High-Availability is enabled.
         :param disable_backup: Defines whether or not backups are disabled.
         :param volume_size: Volume size when volume_type is not lssd.
         :param backup_same_region: Defines whether to or not to store logical backups in the same region as the Database Instance.
         :param tags: Tags to apply to the Database Instance.
         :param init_settings: List of engine settings to be set upon Database Instance initialization.
@@ -1018,15 +1034,15 @@
             )
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
-            options.stop = lambda res: res.status not in READREPLICA_TRANSIENT_STATUSES
+            options.stop = lambda res: res.status not in READ_REPLICA_TRANSIENT_STATUSES
 
         return await wait_for_resource_async(
             fetcher=self.get_read_replica,
             options=options,
             args={
                 "read_replica_id": read_replica_id,
                 "region": region,
@@ -1280,15 +1296,15 @@
             )
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
-            options.stop = lambda res: res.status not in INSTANCELOG_TRANSIENT_STATUSES
+            options.stop = lambda res: res.status not in INSTANCE_LOG_TRANSIENT_STATUSES
 
         return await wait_for_resource_async(
             fetcher=self.get_instance_log,
             options=options,
             args={
                 "instance_log_id": instance_log_id,
                 "region": region,
@@ -2787,7 +2803,42 @@
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Endpoint(res.json())
+
+    async def apply_instance_maintenance(
+        self,
+        *,
+        instance_id: str,
+        region: Optional[Region] = None,
+    ) -> Maintenance:
+        """
+        Apply an instance maintenance.
+        Apply a pending instance maintenance on your instance. This action can generate some service interruption.
+        :param instance_id: UUID of the Database Instance to which you want to apply maintenance.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :return: :class:`Maintenance <Maintenance>`
+
+        Usage:
+        ::
+
+            result = await api.apply_instance_maintenance(
+                instance_id="example",
+            )
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_instance_id = validate_path_param("instance_id", instance_id)
+
+        res = self._request(
+            "POST",
+            f"/document-db/v1beta1/regions/{param_region}/instances/{param_instance_id}/apply-maintenance",
+            body={},
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Maintenance(res.json())
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/content.py` & `scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/content.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,15 @@
     InstanceLogStatus,
     InstanceStatus,
     MaintenanceStatus,
     ReadReplicaStatus,
     SnapshotStatus,
 )
 
-INSTANCELOG_TRANSIENT_STATUSES: List[InstanceLogStatus] = [
+INSTANCE_LOG_TRANSIENT_STATUSES: List[InstanceLogStatus] = [
     InstanceLogStatus.CREATING,
 ]
 """
 Lists transient statutes of the enum :class:`InstanceLogStatus <InstanceLogStatus>`.
 """
 INSTANCE_TRANSIENT_STATUSES: List[InstanceStatus] = [
     InstanceStatus.PROVISIONING,
@@ -26,20 +26,20 @@
     InstanceStatus.SNAPSHOTTING,
     InstanceStatus.RESTARTING,
 ]
 """
 Lists transient statutes of the enum :class:`InstanceStatus <InstanceStatus>`.
 """
 MAINTENANCE_TRANSIENT_STATUSES: List[MaintenanceStatus] = [
-    MaintenanceStatus.PENDING,
+    MaintenanceStatus.ONGOING,
 ]
 """
 Lists transient statutes of the enum :class:`MaintenanceStatus <MaintenanceStatus>`.
 """
-READREPLICA_TRANSIENT_STATUSES: List[ReadReplicaStatus] = [
+READ_REPLICA_TRANSIENT_STATUSES: List[ReadReplicaStatus] = [
     ReadReplicaStatus.PROVISIONING,
     ReadReplicaStatus.INITIALIZING,
     ReadReplicaStatus.DELETING,
     ReadReplicaStatus.CONFIGURING,
     ReadReplicaStatus.PROMOTING,
 ]
 """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/marshalling.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,25 +13,26 @@
     resolve_one_of,
 )
 from .types import (
     EndpointDirectAccessDetails,
     EndpointLoadBalancerDetails,
     EndpointPrivateNetworkDetails,
     Endpoint,
+    Maintenance,
     ReadReplica,
     Database,
     InstanceLog,
     BackupSchedule,
     InstanceSetting,
     LogsPolicy,
-    Maintenance,
     UpgradableVersion,
     Volume,
     Instance,
     Privilege,
+    SnapshotVolumeType,
     Snapshot,
     User,
     ACLRule,
     AddInstanceACLRulesResponse,
     AddInstanceSettingsResponse,
     DeleteInstanceACLRulesResponse,
     DeleteInstanceSettingsResponse,
@@ -81,14 +82,15 @@
     PurgeInstanceLogsRequest,
     SetInstanceACLRulesRequest,
     SetInstanceSettingsRequest,
     SetPrivilegeRequest,
     UpdateInstanceRequest,
     UpdateSnapshotRequest,
     UpdateUserRequest,
+    UpgradeInstanceRequestMajorUpgradeWorkflow,
     UpgradeInstanceRequest,
 )
 
 
 def unmarshal_EndpointDirectAccessDetails(data: Any) -> EndpointDirectAccessDetails:
     if not isinstance(data, dict):
         raise TypeError(
@@ -149,38 +151,93 @@
     field = data.get("port", None)
     if field is not None:
         args["port"] = field
 
     field = data.get("ip", None)
     if field is not None:
         args["ip"] = field
+    else:
+        args["ip"] = None
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
+    else:
+        args["name"] = None
 
     field = data.get("private_network", None)
     if field is not None:
         args["private_network"] = unmarshal_EndpointPrivateNetworkDetails(field)
+    else:
+        args["private_network"] = None
 
     field = data.get("load_balancer", None)
     if field is not None:
         args["load_balancer"] = unmarshal_EndpointLoadBalancerDetails(field)
+    else:
+        args["load_balancer"] = None
 
     field = data.get("direct_access", None)
     if field is not None:
         args["direct_access"] = unmarshal_EndpointDirectAccessDetails(field)
+    else:
+        args["direct_access"] = None
 
     field = data.get("hostname", None)
     if field is not None:
         args["hostname"] = field
+    else:
+        args["hostname"] = None
 
     return Endpoint(**args)
 
 
+def unmarshal_Maintenance(data: Any) -> Maintenance:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'Maintenance' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("reason", None)
+    if field is not None:
+        args["reason"] = field
+
+    field = data.get("status", None)
+    if field is not None:
+        args["status"] = field
+
+    field = data.get("starts_at", None)
+    if field is not None:
+        args["starts_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["starts_at"] = None
+
+    field = data.get("stops_at", None)
+    if field is not None:
+        args["stops_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["stops_at"] = None
+
+    field = data.get("closed_at", None)
+    if field is not None:
+        args["closed_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["closed_at"] = None
+
+    field = data.get("forced_at", None)
+    if field is not None:
+        args["forced_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["forced_at"] = None
+
+    return Maintenance(**args)
+
+
 def unmarshal_ReadReplica(data: Any) -> ReadReplica:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ReadReplica' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -260,22 +317,28 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("download_url", None)
     if field is not None:
         args["download_url"] = field
+    else:
+        args["download_url"] = None
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return InstanceLog(**args)
 
 
 def unmarshal_BackupSchedule(data: Any) -> BackupSchedule:
     if not isinstance(data, dict):
         raise TypeError(
@@ -297,14 +360,16 @@
         args["disabled"] = field
 
     field = data.get("next_run_at", None)
     if field is not None:
         args["next_run_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["next_run_at"] = None
 
     return BackupSchedule(**args)
 
 
 def unmarshal_InstanceSetting(data: Any) -> InstanceSetting:
     if not isinstance(data, dict):
         raise TypeError(
@@ -331,53 +396,26 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("max_age_retention", None)
     if field is not None:
         args["max_age_retention"] = field
+    else:
+        args["max_age_retention"] = None
 
     field = data.get("total_disk_retention", None)
     if field is not None:
         args["total_disk_retention"] = field
+    else:
+        args["total_disk_retention"] = None
 
     return LogsPolicy(**args)
 
 
-def unmarshal_Maintenance(data: Any) -> Maintenance:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Maintenance' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("reason", None)
-    if field is not None:
-        args["reason"] = field
-
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
-
-    field = data.get("starts_at", None)
-    if field is not None:
-        args["starts_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("stops_at", None)
-    if field is not None:
-        args["stops_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("closed_at", None)
-    if field is not None:
-        args["closed_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    return Maintenance(**args)
-
-
 def unmarshal_UpgradableVersion(data: Any) -> UpgradableVersion:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'UpgradableVersion' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -405,22 +443,26 @@
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Volume' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("size", None)
     if field is not None:
         args["size"] = field
 
+    field = data.get("class", None)
+    if field is not None:
+        args["class_"] = field
+
     return Volume(**args)
 
 
 def unmarshal_Instance(data: Any) -> Instance:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Instance' failed as data isn't a dictionary."
@@ -443,18 +485,22 @@
     field = data.get("organization_id", None)
     if field is not None:
         args["organization_id"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("volume", None)
     if field is not None:
         args["volume"] = unmarshal_Volume(field)
+    else:
+        args["volume"] = None
 
     field = data.get("project_id", None)
     if field is not None:
         args["project_id"] = field
 
     field = data.get("status", None)
     if field is not None:
@@ -485,18 +531,22 @@
     field = data.get("is_ha_cluster", None)
     if field is not None:
         args["is_ha_cluster"] = field
 
     field = data.get("endpoint", None)
     if field is not None:
         args["endpoint"] = unmarshal_Endpoint(field)
+    else:
+        args["endpoint"] = None
 
     field = data.get("backup_schedule", None)
     if field is not None:
         args["backup_schedule"] = unmarshal_BackupSchedule(field)
+    else:
+        args["backup_schedule"] = None
 
     field = data.get("read_replicas", None)
     if field is not None:
         args["read_replicas"] = (
             [unmarshal_ReadReplica(v) for v in field] if field is not None else None
         )
 
@@ -525,14 +575,16 @@
         args["maintenances"] = (
             [unmarshal_Maintenance(v) for v in field] if field is not None else None
         )
 
     field = data.get("logs_policy", None)
     if field is not None:
         args["logs_policy"] = unmarshal_LogsPolicy(field)
+    else:
+        args["logs_policy"] = None
 
     return Instance(**args)
 
 
 def unmarshal_Privilege(data: Any) -> Privilege:
     if not isinstance(data, dict):
         raise TypeError(
@@ -552,14 +604,33 @@
     field = data.get("user_name", None)
     if field is not None:
         args["user_name"] = field
 
     return Privilege(**args)
 
 
+def unmarshal_SnapshotVolumeType(data: Any) -> SnapshotVolumeType:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'SnapshotVolumeType' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("type", None)
+    if field is not None:
+        args["type_"] = field
+
+    field = data.get("class", None)
+    if field is not None:
+        args["class_"] = field
+
+    return SnapshotVolumeType(**args)
+
+
 def unmarshal_Snapshot(data: Any) -> Snapshot:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Snapshot' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -591,26 +662,40 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("size", None)
     if field is not None:
         args["size"] = field
+    else:
+        args["size"] = None
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
+
+    field = data.get("volume_type", None)
+    if field is not None:
+        args["volume_type"] = unmarshal_SnapshotVolumeType(field)
+    else:
+        args["volume_type"] = None
 
     return Snapshot(**args)
 
 
 def unmarshal_User(data: Any) -> User:
     if not isinstance(data, dict):
         raise TypeError(
@@ -657,14 +742,16 @@
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
     field = data.get("port", None)
     if field is not None:
         args["port"] = field
+    else:
+        args["port"] = None
 
     return ACLRule(**args)
 
 
 def unmarshal_AddInstanceACLRulesResponse(data: Any) -> AddInstanceACLRulesResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -781,34 +868,46 @@
     field = data.get("property_type", None)
     if field is not None:
         args["property_type"] = field
 
     field = data.get("unit", None)
     if field is not None:
         args["unit"] = field
+    else:
+        args["unit"] = None
 
     field = data.get("string_constraint", None)
     if field is not None:
         args["string_constraint"] = field
+    else:
+        args["string_constraint"] = None
 
     field = data.get("int_min", None)
     if field is not None:
         args["int_min"] = field
+    else:
+        args["int_min"] = None
 
     field = data.get("int_max", None)
     if field is not None:
         args["int_max"] = field
+    else:
+        args["int_max"] = None
 
     field = data.get("float_min", None)
     if field is not None:
         args["float_min"] = field
+    else:
+        args["float_min"] = None
 
     field = data.get("float_max", None)
     if field is not None:
         args["float_max"] = field
+    else:
+        args["float_max"] = None
 
     return EngineSetting(**args)
 
 
 def unmarshal_EngineVersion(data: Any) -> EngineVersion:
     if not isinstance(data, dict):
         raise TypeError(
@@ -846,14 +945,16 @@
         )
 
     field = data.get("end_of_life", None)
     if field is not None:
         args["end_of_life"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["end_of_life"] = None
 
     return EngineVersion(**args)
 
 
 def unmarshal_DatabaseEngine(data: Any) -> DatabaseEngine:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1052,15 +1153,15 @@
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'NodeTypeVolumeType' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
@@ -1072,14 +1173,18 @@
     if field is not None:
         args["max_size"] = field
 
     field = data.get("chunk_size", None)
     if field is not None:
         args["chunk_size"] = field
 
+    field = data.get("class", None)
+    if field is not None:
+        args["class_"] = field
+
     return NodeTypeVolumeType(**args)
 
 
 def unmarshal_NodeType(data: Any) -> NodeType:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'NodeType' failed as data isn't a dictionary."
@@ -1114,18 +1219,22 @@
     field = data.get("beta", None)
     if field is not None:
         args["beta"] = field
 
     field = data.get("volume_constraint", None)
     if field is not None:
         args["volume_constraint"] = unmarshal_NodeTypeVolumeConstraintSizes(field)
+    else:
+        args["volume_constraint"] = None
 
     field = data.get("is_bssd_compatible", None)
     if field is not None:
         args["is_bssd_compatible"] = field
+    else:
+        args["is_bssd_compatible"] = None
 
     field = data.get("available_volume_types", None)
     if field is not None:
         args["available_volume_types"] = (
             [unmarshal_NodeTypeVolumeType(v) for v in field]
             if field is not None
             else None
@@ -1798,14 +1907,29 @@
 
     if request.is_admin is not None:
         output["is_admin"] = request.is_admin
 
     return output
 
 
+def marshal_UpgradeInstanceRequestMajorUpgradeWorkflow(
+    request: UpgradeInstanceRequestMajorUpgradeWorkflow,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.upgradable_version_id is not None:
+        output["upgradable_version_id"] = request.upgradable_version_id
+
+    if request.with_endpoints is not None:
+        output["with_endpoints"] = request.with_endpoints
+
+    return output
+
+
 def marshal_UpgradeInstanceRequest(
     request: UpgradeInstanceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
     output.update(
         resolve_one_of(
@@ -1813,12 +1937,15 @@
                 OneOfPossibility("node_type", request.node_type),
                 OneOfPossibility("enable_ha", request.enable_ha),
                 OneOfPossibility("volume_size", request.volume_size),
                 OneOfPossibility("volume_type", request.volume_type),
                 OneOfPossibility(
                     "upgradable_version_id", request.upgradable_version_id
                 ),
+                OneOfPossibility(
+                    "major_upgrade_workflow", request.major_upgrade_workflow
+                ),
             ]
         ),
     )
 
     return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/document_db/v1beta1/types.py` & `scaleway_async-2.1.0/scaleway_async/document_db/v1beta1/types.py`

 * *Files 2% similar despite different names*

```diff
@@ -145,14 +145,15 @@
 
 
 class MaintenanceStatus(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN = "unknown"
     PENDING = "pending"
     DONE = "done"
     CANCELED = "canceled"
+    ONGOING = "ongoing"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class NodeTypeGeneration(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN_GENERATION = "unknown_generation"
@@ -208,17 +209,29 @@
     ERROR = "error"
     LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
+class StorageClass(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_STORAGE_CLASS = "unknown_storage_class"
+    LSSD = "lssd"
+    BSSD = "bssd"
+    SBS = "sbs"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 class VolumeType(str, Enum, metaclass=StrEnumMeta):
     LSSD = "lssd"
     BSSD = "bssd"
+    SBS_5K = "sbs_5k"
+    SBS_15K = "sbs_15k"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
 class EndpointDirectAccessDetails:
@@ -482,14 +495,19 @@
     """
 
     closed_at: Optional[datetime]
     """
     Closed maintenance date.
     """
 
+    forced_at: Optional[datetime]
+    """
+    Time when Scaleway-side maintenance will be applied.
+    """
+
 
 @dataclass
 class ReadReplica:
     id: str
     """
     UUID of the Read Replica.
     """
@@ -528,14 +546,16 @@
 
 @dataclass
 class Volume:
     type_: VolumeType
 
     size: int
 
+    class_: StorageClass
+
 
 @dataclass
 class NodeTypeVolumeConstraintSizes:
     min_size: int
     """
     [deprecated] Mimimum size required for the Volume.
     """
@@ -569,14 +589,26 @@
     """
 
     chunk_size: int
     """
     Minimum increment level for a Block Storage volume size.
     """
 
+    class_: StorageClass
+    """
+    The storage class of the volume.
+    """
+
+
+@dataclass
+class SnapshotVolumeType:
+    type_: VolumeType
+
+    class_: StorageClass
+
 
 @dataclass
 class ACLRuleRequest:
     ip: str
 
     description: str
 
@@ -958,14 +990,19 @@
     """
 
     updated_at: Optional[datetime]
     """
     Updated date (must follow the ISO 8601 format).
     """
 
+    volume_type: Optional[SnapshotVolumeType]
+    """
+    Type of volume where data is stored (lssd, bssd or sbs).
+    """
+
 
 @dataclass
 class User:
     name: str
     """
     Name of the user (Length must be between 1 and 63 characters. First character must be an alphabet character (a-zA-Z). Your username cannot start with '_rdb' or 'pg_'. Only a-zA-Z0-9_$- characters are accepted).
     """
@@ -973,14 +1010,27 @@
     is_admin: bool
     """
     Defines whether or not a user got administrative privileges on the Database Instance.
     """
 
 
 @dataclass
+class UpgradeInstanceRequestMajorUpgradeWorkflow:
+    upgradable_version_id: str
+    """
+    This will create a new Database Instance with same specifications as the current one and perform a Database Engine upgrade.
+    """
+
+    with_endpoints: bool
+    """
+    At the end of the migration procedure this option let you migrate all your database endpoint to the upgraded instance.
+    """
+
+
+@dataclass
 class AddInstanceACLRulesRequest:
     instance_id: str
     """
     UUID of the Database Instance you want to add ACL rules to.
     """
 
     rules: List[ACLRuleRequest]
@@ -1025,14 +1075,27 @@
     settings: List[InstanceSetting]
     """
     Settings available on the Database Instance.
     """
 
 
 @dataclass
+class ApplyInstanceMaintenanceRequest:
+    instance_id: str
+    """
+    UUID of the Database Instance to which you want to apply maintenance.
+    """
+
+    region: Optional[Region]
+    """
+    Region to target. If none is passed will use default region from the config.
+    """
+
+
+@dataclass
 class CloneInstanceRequest:
     instance_id: str
     """
     UUID of the Database Instance you want to clone.
     """
 
     name: str
@@ -2204,7 +2267,9 @@
     enable_ha: Optional[bool]
 
     volume_size: Optional[int]
 
     volume_type: Optional[VolumeType]
 
     upgradable_version_id: Optional[str]
+
+    major_upgrade_workflow: Optional[UpgradeInstanceRequestMajorUpgradeWorkflow]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/domain/v2beta1/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import ContactEmailStatus
 from .types import ContactExtensionFRMode
 from .types import ContactExtensionNLLegalForm
 from .types import ContactLegalForm
+from .types import ContactStatus
 from .types import DNSZoneStatus
-from .content import DNSZONE_TRANSIENT_STATUSES
+from .content import DNS_ZONE_TRANSIENT_STATUSES
 from .types import DSRecordAlgorithm
 from .types import DSRecordDigestType
 from .types import DomainFeatureStatus
-from .content import DOMAINFEATURE_TRANSIENT_STATUSES
+from .content import DOMAIN_FEATURE_TRANSIENT_STATUSES
 from .types import DomainRegistrationStatusTransferStatus
-from .content import DOMAINREGISTRATIONSTATUSTRANSFER_TRANSIENT_STATUSES
+from .content import DOMAIN_REGISTRATION_STATUS_TRANSFER_TRANSIENT_STATUSES
 from .types import DomainStatus
 from .content import DOMAIN_TRANSIENT_STATUSES
 from .types import HostStatus
 from .content import HOST_TRANSIENT_STATUSES
 from .types import LinkedProduct
 from .types import ListContactsRequestRole
 from .types import ListDNSZoneRecordsRequestOrderBy
@@ -25,15 +26,15 @@
 from .types import ListTasksRequestOrderBy
 from .types import ListTldsRequestOrderBy
 from .types import RawFormat
 from .types import RecordHTTPServiceConfigStrategy
 from .types import RecordType
 from .types import RenewableDomainStatus
 from .types import SSLCertificateStatus
-from .content import SSLCERTIFICATE_TRANSIENT_STATUSES
+from .content import SSL_CERTIFICATE_TRANSIENT_STATUSES
 from .types import TaskStatus
 from .content import TASK_TRANSIENT_STATUSES
 from .types import TaskType
 from .types import RecordGeoIPConfigMatch
 from .types import RecordViewConfigView
 from .types import RecordWeightedConfigWeightedIP
 from .types import DSRecordPublicKey
@@ -170,22 +171,23 @@
 from .api import DomainV2Beta1RegistrarAPI
 
 __all__ = [
     "ContactEmailStatus",
     "ContactExtensionFRMode",
     "ContactExtensionNLLegalForm",
     "ContactLegalForm",
+    "ContactStatus",
     "DNSZoneStatus",
-    "DNSZONE_TRANSIENT_STATUSES",
+    "DNS_ZONE_TRANSIENT_STATUSES",
     "DSRecordAlgorithm",
     "DSRecordDigestType",
     "DomainFeatureStatus",
-    "DOMAINFEATURE_TRANSIENT_STATUSES",
+    "DOMAIN_FEATURE_TRANSIENT_STATUSES",
     "DomainRegistrationStatusTransferStatus",
-    "DOMAINREGISTRATIONSTATUSTRANSFER_TRANSIENT_STATUSES",
+    "DOMAIN_REGISTRATION_STATUS_TRANSFER_TRANSIENT_STATUSES",
     "DomainStatus",
     "DOMAIN_TRANSIENT_STATUSES",
     "HostStatus",
     "HOST_TRANSIENT_STATUSES",
     "LinkedProduct",
     "ListContactsRequestRole",
     "ListDNSZoneRecordsRequestOrderBy",
@@ -195,15 +197,15 @@
     "ListTasksRequestOrderBy",
     "ListTldsRequestOrderBy",
     "RawFormat",
     "RecordHTTPServiceConfigStrategy",
     "RecordType",
     "RenewableDomainStatus",
     "SSLCertificateStatus",
-    "SSLCERTIFICATE_TRANSIENT_STATUSES",
+    "SSL_CERTIFICATE_TRANSIENT_STATUSES",
     "TaskStatus",
     "TASK_TRANSIENT_STATUSES",
     "TaskType",
     "RecordGeoIPConfigMatch",
     "RecordViewConfigView",
     "RecordWeightedConfigWeightedIP",
     "DSRecordPublicKey",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/api.py` & `scaleway_async-2.1.0/scaleway_async/domain/v2beta1/api.py`

 * *Files 4% similar despite different names*

```diff
@@ -101,15 +101,15 @@
     UpdateDNSZoneNameserversResponse,
     UpdateDNSZoneRecordsRequest,
     UpdateDNSZoneRecordsResponse,
     UpdateDNSZoneRequest,
 )
 from .content import (
     DOMAIN_TRANSIENT_STATUSES,
-    SSLCERTIFICATE_TRANSIENT_STATUSES,
+    SSL_CERTIFICATE_TRANSIENT_STATUSES,
 )
 from .marshalling import (
     unmarshal_Contact,
     unmarshal_DNSZone,
     unmarshal_Host,
     unmarshal_SSLCertificate,
     unmarshal_CheckContactsCompatibilityResponse,
@@ -772,15 +772,17 @@
         Import a raw DNS zone.
         Import and replace the format of records from a given provider, with default name servers.
         :param dns_zone: DNS zone to import.
         :param content:
         :param project_id:
         :param format:
         :param bind_source: Import a bind file format.
+        One-Of ('source'): at most one of 'bind_source', 'axfr_source' could be set.
         :param axfr_source: Import from the name server given with TSIG, to use or not.
+        One-Of ('source'): at most one of 'bind_source', 'axfr_source' could be set.
         :return: :class:`ImportRawDNSZoneResponse <ImportRawDNSZoneResponse>`
 
         Usage:
         ::
 
             result = await api.import_raw_dns_zone(
                 dns_zone="example",
@@ -815,14 +817,15 @@
         online_v1: Optional[ImportProviderDNSZoneRequestOnlineV1] = None,
     ) -> ImportProviderDNSZoneResponse:
         """
         Import a DNS zone from another provider.
         Import and replace the format of records from a given provider, with default name servers.
         :param dns_zone:
         :param online_v1:
+        One-Of ('provider'): at most one of 'online_v1' could be set.
         :return: :class:`ImportProviderDNSZoneResponse <ImportProviderDNSZoneResponse>`
 
         Usage:
         ::
 
             result = await api.import_provider_dns_zone(
                 dns_zone="example",
@@ -1151,15 +1154,15 @@
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
             options.stop = (
-                lambda res: res.status not in SSLCERTIFICATE_TRANSIENT_STATUSES
+                lambda res: res.status not in SSL_CERTIFICATE_TRANSIENT_STATUSES
             )
 
         return await wait_for_resource_async(
             fetcher=self.get_ssl_certificate,
             options=options,
             args={
                 "dns_zone": dns_zone,
@@ -1485,19 +1488,25 @@
         Purchase domains.
         Request the registration of domain names.
         You can provide a domain's already existing contact or a new contact.
         :param domains:
         :param duration_in_years:
         :param project_id:
         :param owner_contact_id:
+        One-Of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param owner_contact:
+        One-Of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param administrative_contact_id:
+        One-Of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param administrative_contact:
+        One-Of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param technical_contact_id:
+        One-Of ('technical_contact_type'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :param technical_contact:
+        One-Of ('technical_contact_type'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :return: :class:`OrderResponse <OrderResponse>`
 
         Usage:
         ::
 
             result = await api.buy_domains(
                 domains=[],
@@ -1581,19 +1590,25 @@
     ) -> OrderResponse:
         """
         Transfer a domain.
         Request the transfer of a domain from another registrar to Scaleway Domains and DNS.
         :param domains:
         :param project_id:
         :param owner_contact_id:
+        One-Of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param owner_contact:
+        One-Of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param administrative_contact_id:
+        One-Of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param administrative_contact:
+        One-Of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param technical_contact_id:
+        One-Of ('technical_contact_type'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :param technical_contact:
+        One-Of ('technical_contact_type'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :return: :class:`OrderResponse <OrderResponse>`
 
         Usage:
         ::
 
             result = await api.transfer_in_domain(
                 domains=[],
@@ -1634,15 +1649,17 @@
         Request to change a domain's contact owner.<br/>
         If you specify the `organization_id` of the domain's new owner, the contact will change from the current owner's Scaleway account to the new owner's Scaleway account.<br/>
         If the new owner's current contact information is not available, the first ever contact they have created for previous domains is taken into account to operate the change.<br/>
         If the new owner has never created a contact to register domains before, an error message displays.
         :param domain:
         :param project_id:
         :param new_owner_contact_id:
+        One-Of ('new_owner_contact_type'): at most one of 'new_owner_contact_id', 'new_owner_contact' could be set.
         :param new_owner_contact:
+        One-Of ('new_owner_contact_type'): at most one of 'new_owner_contact_id', 'new_owner_contact' could be set.
         :return: :class:`OrderResponse <OrderResponse>`
 
         Usage:
         ::
 
             result = await api.trade_domain(
                 domain="example",
@@ -1748,19 +1765,25 @@
         """
         Check if contacts are compatible with a domain or a TLD.
         Check whether contacts are compatible with a domain or a TLD.
         If contacts are not compatible with either the domain or the TLD, the information that needs to be corrected is returned.
         :param domains:
         :param tlds:
         :param owner_contact_id:
+        One-Of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param owner_contact:
+        One-Of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param administrative_contact_id:
+        One-Of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param administrative_contact:
+        One-Of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param technical_contact_id:
+        One-Of ('technical_contact_type'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :param technical_contact:
+        One-Of ('technical_contact_type'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :return: :class:`CheckContactsCompatibilityResponse <CheckContactsCompatibilityResponse>`
 
         Usage:
         ::
 
             result = await api.check_contacts_compatibility()
         """
@@ -2258,19 +2281,25 @@
     ) -> Domain:
         """
         Update a domain's contacts.
         Update contacts for a specific domain or create a new contact.<br/>
         If you add the same contact for multiple roles (owner, administrative, technical), only one ID will be created and used for all of the roles.
         :param domain:
         :param technical_contact_id:
+        One-Of ('technical_contact_info'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :param technical_contact:
+        One-Of ('technical_contact_info'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :param owner_contact_id:
+        One-Of ('owner_contact_info'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param owner_contact:
+        One-Of ('owner_contact_info'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param administrative_contact_id:
+        One-Of ('administrative_contact_info'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param administrative_contact:
+        One-Of ('administrative_contact_info'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.update_domain(
                 domain="example",
@@ -2788,15 +2817,14 @@
         self,
         *,
         domain: str,
         name: str,
     ) -> Host:
         """
         Delete a domain's hostname.
-        Delete a domain's hostname.
         :param domain:
         :param name:
         :return: :class:`Host <Host>`
 
         Usage:
         ::
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/content.py` & `scaleway_async-2.1.0/scaleway_async/domain/v2beta1/content.py`

 * *Files 10% similar despite different names*

```diff
@@ -8,28 +8,28 @@
     DomainRegistrationStatusTransferStatus,
     DomainStatus,
     HostStatus,
     SSLCertificateStatus,
     TaskStatus,
 )
 
-DNSZONE_TRANSIENT_STATUSES: List[DNSZoneStatus] = [
+DNS_ZONE_TRANSIENT_STATUSES: List[DNSZoneStatus] = [
     DNSZoneStatus.PENDING,
 ]
 """
 Lists transient statutes of the enum :class:`DNSZoneStatus <DNSZoneStatus>`.
 """
-DOMAINFEATURE_TRANSIENT_STATUSES: List[DomainFeatureStatus] = [
+DOMAIN_FEATURE_TRANSIENT_STATUSES: List[DomainFeatureStatus] = [
     DomainFeatureStatus.ENABLING,
     DomainFeatureStatus.DISABLING,
 ]
 """
 Lists transient statutes of the enum :class:`DomainFeatureStatus <DomainFeatureStatus>`.
 """
-DOMAINREGISTRATIONSTATUSTRANSFER_TRANSIENT_STATUSES: List[
+DOMAIN_REGISTRATION_STATUS_TRANSFER_TRANSIENT_STATUSES: List[
     DomainRegistrationStatusTransferStatus
 ] = [
     DomainRegistrationStatusTransferStatus.PENDING,
     DomainRegistrationStatusTransferStatus.PROCESSING,
 ]
 """
 Lists transient statutes of the enum :class:`DomainRegistrationStatusTransferStatus <DomainRegistrationStatusTransferStatus>`.
@@ -49,15 +49,15 @@
 HOST_TRANSIENT_STATUSES: List[HostStatus] = [
     HostStatus.UPDATING,
     HostStatus.DELETING,
 ]
 """
 Lists transient statutes of the enum :class:`HostStatus <HostStatus>`.
 """
-SSLCERTIFICATE_TRANSIENT_STATUSES: List[SSLCertificateStatus] = [
+SSL_CERTIFICATE_TRANSIENT_STATUSES: List[SSLCertificateStatus] = [
     SSLCertificateStatus.PENDING,
 ]
 """
 Lists transient statutes of the enum :class:`SSLCertificateStatus <SSLCertificateStatus>`.
 """
 TASK_TRANSIENT_STATUSES: List[TaskStatus] = [
     TaskStatus.PENDING,
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/domain/v2beta1/marshalling.py`

 * *Files 4% similar despite different names*

```diff
@@ -133,14 +133,16 @@
         args["publication_jo_page"] = field
 
     field = data.get("publication_jo", None)
     if field is not None:
         args["publication_jo"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["publication_jo"] = None
 
     return ContactExtensionFRAssociationInfo(**args)
 
 
 def unmarshal_ContactExtensionFRCodeAuthAfnicInfo(
     data: Any,
 ) -> ContactExtensionFRCodeAuthAfnicInfo:
@@ -237,32 +239,42 @@
     field = data.get("mode", None)
     if field is not None:
         args["mode"] = field
 
     field = data.get("individual_info", None)
     if field is not None:
         args["individual_info"] = unmarshal_ContactExtensionFRIndividualInfo(field)
+    else:
+        args["individual_info"] = None
 
     field = data.get("duns_info", None)
     if field is not None:
         args["duns_info"] = unmarshal_ContactExtensionFRDunsInfo(field)
+    else:
+        args["duns_info"] = None
 
     field = data.get("association_info", None)
     if field is not None:
         args["association_info"] = unmarshal_ContactExtensionFRAssociationInfo(field)
+    else:
+        args["association_info"] = None
 
     field = data.get("trademark_info", None)
     if field is not None:
         args["trademark_info"] = unmarshal_ContactExtensionFRTrademarkInfo(field)
+    else:
+        args["trademark_info"] = None
 
     field = data.get("code_auth_afnic_info", None)
     if field is not None:
         args["code_auth_afnic_info"] = unmarshal_ContactExtensionFRCodeAuthAfnicInfo(
             field
         )
+    else:
+        args["code_auth_afnic_info"] = None
 
     return ContactExtensionFR(**args)
 
 
 def unmarshal_ContactExtensionNL(data: Any) -> ContactExtensionNL:
     if not isinstance(data, dict):
         raise TypeError(
@@ -381,39 +393,51 @@
     if field is not None:
         args["resale"] = field
 
     field = data.get("whois_opt_in", None)
     if field is not None:
         args["whois_opt_in"] = field
 
-    field = data.get("email_status", None)
-    if field is not None:
-        args["email_status"] = field
-
-    field = data.get("state", None)
-    if field is not None:
-        args["state"] = field
-
     field = data.get("questions", None)
     if field is not None:
         args["questions"] = (
             [unmarshal_ContactQuestion(v) for v in field] if field is not None else None
         )
+    else:
+        args["questions"] = None
 
     field = data.get("extension_fr", None)
     if field is not None:
         args["extension_fr"] = unmarshal_ContactExtensionFR(field)
+    else:
+        args["extension_fr"] = None
 
     field = data.get("extension_eu", None)
     if field is not None:
         args["extension_eu"] = unmarshal_ContactExtensionEU(field)
+    else:
+        args["extension_eu"] = None
+
+    field = data.get("email_status", None)
+    if field is not None:
+        args["email_status"] = field
+
+    field = data.get("state", None)
+    if field is not None:
+        args["state"] = field
+
+    field = data.get("status", None)
+    if field is not None:
+        args["status"] = field
 
     field = data.get("extension_nl", None)
     if field is not None:
         args["extension_nl"] = unmarshal_ContactExtensionNL(field)
+    else:
+        args["extension_nl"] = None
 
     return Contact(**args)
 
 
 def unmarshal_DNSZone(data: Any) -> DNSZone:
     if not isinstance(data, dict):
         raise TypeError(
@@ -455,18 +479,22 @@
         args["linked_products"] = (
             [LinkedProduct(v) for v in field] if field is not None else None
         )
 
     field = data.get("message", None)
     if field is not None:
         args["message"] = field
+    else:
+        args["message"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return DNSZone(**args)
 
 
 def unmarshal_Host(data: Any) -> Host:
     if not isinstance(data, dict):
         raise TypeError(
@@ -521,18 +549,22 @@
     field = data.get("certificate_chain", None)
     if field is not None:
         args["certificate_chain"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("expired_at", None)
     if field is not None:
         args["expired_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expired_at"] = None
 
     return SSLCertificate(**args)
 
 
 def unmarshal_CheckContactsCompatibilityResponseContactCheckResult(
     data: Any,
 ) -> CheckContactsCompatibilityResponseContactCheckResult:
@@ -546,14 +578,16 @@
     field = data.get("compatible", None)
     if field is not None:
         args["compatible"] = field
 
     field = data.get("error_message", None)
     if field is not None:
         args["error_message"] = field
+    else:
+        args["error_message"] = None
 
     return CheckContactsCompatibilityResponseContactCheckResult(**args)
 
 
 def unmarshal_CheckContactsCompatibilityResponse(
     data: Any,
 ) -> CheckContactsCompatibilityResponse:
@@ -566,29 +600,35 @@
 
     field = data.get("compatible", None)
     if field is not None:
         args["compatible"] = field
 
     field = data.get("owner_check_result", None)
     if field is not None:
-        args[
-            "owner_check_result"
-        ] = unmarshal_CheckContactsCompatibilityResponseContactCheckResult(field)
+        args["owner_check_result"] = (
+            unmarshal_CheckContactsCompatibilityResponseContactCheckResult(field)
+        )
+    else:
+        args["owner_check_result"] = None
 
     field = data.get("administrative_check_result", None)
     if field is not None:
-        args[
-            "administrative_check_result"
-        ] = unmarshal_CheckContactsCompatibilityResponseContactCheckResult(field)
+        args["administrative_check_result"] = (
+            unmarshal_CheckContactsCompatibilityResponseContactCheckResult(field)
+        )
+    else:
+        args["administrative_check_result"] = None
 
     field = data.get("technical_check_result", None)
     if field is not None:
-        args[
-            "technical_check_result"
-        ] = unmarshal_CheckContactsCompatibilityResponseContactCheckResult(field)
+        args["technical_check_result"] = (
+            unmarshal_CheckContactsCompatibilityResponseContactCheckResult(field)
+        )
+    else:
+        args["technical_check_result"] = None
 
     return CheckContactsCompatibilityResponse(**args)
 
 
 def unmarshal_ClearDNSZoneRecordsResponse(data: Any) -> ClearDNSZoneRecordsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -652,25 +692,27 @@
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'DSRecordDigest' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("digest", None)
     if field is not None:
         args["digest"] = field
 
     field = data.get("public_key", None)
     if field is not None:
         args["public_key"] = unmarshal_DSRecordPublicKey(field)
+    else:
+        args["public_key"] = None
 
     return DSRecordDigest(**args)
 
 
 def unmarshal_DSRecord(data: Any) -> DSRecord:
     if not isinstance(data, dict):
         raise TypeError(
@@ -686,18 +728,22 @@
     field = data.get("algorithm", None)
     if field is not None:
         args["algorithm"] = field
 
     field = data.get("digest", None)
     if field is not None:
         args["digest"] = unmarshal_DSRecordDigest(field)
+    else:
+        args["digest"] = None
 
     field = data.get("public_key", None)
     if field is not None:
         args["public_key"] = unmarshal_DSRecordPublicKey(field)
+    else:
+        args["public_key"] = None
 
     return DSRecord(**args)
 
 
 def unmarshal_TldOffer(data: Any) -> TldOffer:
     if not isinstance(data, dict):
         raise TypeError(
@@ -713,14 +759,16 @@
     field = data.get("operation_path", None)
     if field is not None:
         args["operation_path"] = field
 
     field = data.get("price", None)
     if field is not None:
         args["price"] = unmarshal_Money(field)
+    else:
+        args["price"] = None
 
     return TldOffer(**args)
 
 
 def unmarshal_DomainDNSSEC(data: Any) -> DomainDNSSEC:
     if not isinstance(data, dict):
         raise TypeError(
@@ -851,33 +899,39 @@
     if field is not None:
         args["auto_renew_status"] = field
 
     field = data.get("epp_code", None)
     if field is not None:
         args["epp_code"] = field
 
+    field = data.get("registrar", None)
+    if field is not None:
+        args["registrar"] = field
+
+    field = data.get("is_external", None)
+    if field is not None:
+        args["is_external"] = field
+
     field = data.get("dnssec", None)
     if field is not None:
         args["dnssec"] = unmarshal_DomainDNSSEC(field)
+    else:
+        args["dnssec"] = None
 
     field = data.get("expired_at", None)
     if field is not None:
         args["expired_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expired_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("registrar", None)
-    if field is not None:
-        args["registrar"] = field
-
-    field = data.get("is_external", None)
-    if field is not None:
-        args["is_external"] = field
+    else:
+        args["updated_at"] = None
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("dns_zones", None)
     if field is not None:
@@ -887,41 +941,57 @@
 
     field = data.get("linked_products", None)
     if field is not None:
         args["linked_products"] = (
             [LinkedProduct(v) for v in field] if field is not None else None
         )
 
+    field = data.get("pending_trade", None)
+    if field is not None:
+        args["pending_trade"] = field
+
     field = data.get("owner_contact", None)
     if field is not None:
         args["owner_contact"] = unmarshal_Contact(field)
+    else:
+        args["owner_contact"] = None
 
     field = data.get("technical_contact", None)
     if field is not None:
         args["technical_contact"] = unmarshal_Contact(field)
+    else:
+        args["technical_contact"] = None
 
     field = data.get("administrative_contact", None)
     if field is not None:
         args["administrative_contact"] = unmarshal_Contact(field)
+    else:
+        args["administrative_contact"] = None
 
     field = data.get("external_domain_registration_status", None)
     if field is not None:
-        args[
-            "external_domain_registration_status"
-        ] = unmarshal_DomainRegistrationStatusExternalDomain(field)
+        args["external_domain_registration_status"] = (
+            unmarshal_DomainRegistrationStatusExternalDomain(field)
+        )
+    else:
+        args["external_domain_registration_status"] = None
 
     field = data.get("transfer_registration_status", None)
     if field is not None:
-        args[
-            "transfer_registration_status"
-        ] = unmarshal_DomainRegistrationStatusTransfer(field)
+        args["transfer_registration_status"] = (
+            unmarshal_DomainRegistrationStatusTransfer(field)
+        )
+    else:
+        args["transfer_registration_status"] = None
 
     field = data.get("tld", None)
     if field is not None:
         args["tld"] = unmarshal_Tld(field)
+    else:
+        args["tld"] = None
 
     return Domain(**args)
 
 
 def unmarshal_GetDNSZoneTsigKeyResponse(data: Any) -> GetDNSZoneTsigKeyResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1050,18 +1120,22 @@
     field = data.get("strategy", None)
     if field is not None:
         args["strategy"] = field
 
     field = data.get("must_contain", None)
     if field is not None:
         args["must_contain"] = field
+    else:
+        args["must_contain"] = None
 
     field = data.get("user_agent", None)
     if field is not None:
         args["user_agent"] = field
+    else:
+        args["user_agent"] = None
 
     return RecordHTTPServiceConfig(**args)
 
 
 def unmarshal_RecordViewConfig(data: Any) -> RecordViewConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1120,41 +1194,51 @@
     if field is not None:
         args["priority"] = field
 
     field = data.get("ttl", None)
     if field is not None:
         args["ttl"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
     field = data.get("comment", None)
     if field is not None:
         args["comment"] = field
+    else:
+        args["comment"] = None
 
     field = data.get("geo_ip_config", None)
     if field is not None:
         args["geo_ip_config"] = unmarshal_RecordGeoIPConfig(field)
+    else:
+        args["geo_ip_config"] = None
 
     field = data.get("http_service_config", None)
     if field is not None:
         args["http_service_config"] = unmarshal_RecordHTTPServiceConfig(field)
+    else:
+        args["http_service_config"] = None
 
     field = data.get("weighted_config", None)
     if field is not None:
         args["weighted_config"] = unmarshal_RecordWeightedConfig(field)
+    else:
+        args["weighted_config"] = None
 
     field = data.get("view_config", None)
     if field is not None:
         args["view_config"] = unmarshal_RecordViewConfig(field)
+    else:
+        args["view_config"] = None
 
     return Record(**args)
 
 
 def unmarshal_RecordIdentifier(data: Any) -> RecordIdentifier:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1163,25 +1247,29 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("data", None)
     if field is not None:
         args["data"] = field
+    else:
+        args["data"] = None
 
     field = data.get("ttl", None)
     if field is not None:
         args["ttl"] = field
+    else:
+        args["ttl"] = None
 
     return RecordIdentifier(**args)
 
 
 def unmarshal_RecordChangeAdd(data: Any) -> RecordChangeAdd:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1217,18 +1305,22 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
+    else:
+        args["id"] = None
 
     field = data.get("id_fields", None)
     if field is not None:
         args["id_fields"] = unmarshal_RecordIdentifier(field)
+    else:
+        args["id_fields"] = None
 
     return RecordChangeDelete(**args)
 
 
 def unmarshal_RecordChangeSet(data: Any) -> RecordChangeSet:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1242,18 +1334,22 @@
         args["records"] = (
             [unmarshal_Record(v) for v in field] if field is not None else None
         )
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
+    else:
+        args["id"] = None
 
     field = data.get("id_fields", None)
     if field is not None:
         args["id_fields"] = unmarshal_RecordIdentifier(field)
+    else:
+        args["id_fields"] = None
 
     return RecordChangeSet(**args)
 
 
 def unmarshal_RecordChange(data: Any) -> RecordChange:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1261,26 +1357,34 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("add", None)
     if field is not None:
         args["add"] = unmarshal_RecordChangeAdd(field)
+    else:
+        args["add"] = None
 
-    field = data.get("set_", None)
+    field = data.get("set", None)
     if field is not None:
         args["set_"] = unmarshal_RecordChangeSet(field)
+    else:
+        args["set_"] = None
 
     field = data.get("delete", None)
     if field is not None:
         args["delete"] = unmarshal_RecordChangeDelete(field)
+    else:
+        args["delete"] = None
 
     field = data.get("clear", None)
     if field is not None:
         args["clear"] = unmarshal_RecordChangeClear(field)
+    else:
+        args["clear"] = None
 
     return RecordChange(**args)
 
 
 def unmarshal_GetDNSZoneVersionDiffResponse(data: Any) -> GetDNSZoneVersionDiffResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1385,14 +1489,16 @@
             if field is not None
             else None
         )
 
     field = data.get("contact", None)
     if field is not None:
         args["contact"] = unmarshal_Contact(field)
+    else:
+        args["contact"] = None
 
     return ContactRoles(**args)
 
 
 def unmarshal_ListContactsResponse(data: Any) -> ListContactsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1507,14 +1613,16 @@
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return DNSZoneVersion(**args)
 
 
 def unmarshal_ListDNSZoneVersionsResponse(data: Any) -> ListDNSZoneVersionsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1613,38 +1721,56 @@
     field = data.get("is_external", None)
     if field is not None:
         args["is_external"] = field
 
     field = data.get("expired_at", None)
     if field is not None:
         args["expired_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expired_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("organization_id", None)
     if field is not None:
         args["organization_id"] = field
 
+    field = data.get("pending_trade", None)
+    if field is not None:
+        args["pending_trade"] = field
+
     field = data.get("external_domain_registration_status", None)
     if field is not None:
-        args[
-            "external_domain_registration_status"
-        ] = unmarshal_DomainRegistrationStatusExternalDomain(field)
+        args["external_domain_registration_status"] = (
+            unmarshal_DomainRegistrationStatusExternalDomain(field)
+        )
+    else:
+        args["external_domain_registration_status"] = None
 
     field = data.get("transfer_registration_status", None)
     if field is not None:
-        args[
-            "transfer_registration_status"
-        ] = unmarshal_DomainRegistrationStatusTransfer(field)
+        args["transfer_registration_status"] = (
+            unmarshal_DomainRegistrationStatusTransfer(field)
+        )
+    else:
+        args["transfer_registration_status"] = None
+
+    field = data.get("created_at", None)
+    if field is not None:
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return DomainSummary(**args)
 
 
 def unmarshal_ListDomainsResponse(data: Any) -> ListDomainsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1689,40 +1815,52 @@
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("renewable_duration_in_years", None)
     if field is not None:
         args["renewable_duration_in_years"] = field
+    else:
+        args["renewable_duration_in_years"] = None
 
     field = data.get("expired_at", None)
     if field is not None:
         args["expired_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expired_at"] = None
 
     field = data.get("limit_renew_at", None)
     if field is not None:
         args["limit_renew_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["limit_renew_at"] = None
 
     field = data.get("limit_redemption_at", None)
     if field is not None:
         args["limit_redemption_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["limit_redemption_at"] = None
 
     field = data.get("estimated_delete_at", None)
     if field is not None:
         args["estimated_delete_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["estimated_delete_at"] = None
 
     field = data.get("tld", None)
     if field is not None:
         args["tld"] = unmarshal_Tld(field)
+    else:
+        args["tld"] = None
 
     return RenewableDomain(**args)
 
 
 def unmarshal_ListRenewableDomainsResponse(data: Any) -> ListRenewableDomainsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1781,37 +1919,51 @@
     if field is not None:
         args["project_id"] = field
 
     field = data.get("organization_id", None)
     if field is not None:
         args["organization_id"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("domain", None)
     if field is not None:
         args["domain"] = field
+    else:
+        args["domain"] = None
 
     field = data.get("started_at", None)
     if field is not None:
         args["started_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["started_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("message", None)
     if field is not None:
         args["message"] = field
+    else:
+        args["message"] = None
+
+    field = data.get("contact_identifier", None)
+    if field is not None:
+        args["contact_identifier"] = field
+    else:
+        args["contact_identifier"] = None
 
     return Task(**args)
 
 
 def unmarshal_ListTasksResponse(data: Any) -> ListTasksResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1875,14 +2027,16 @@
     field = data.get("task_id", None)
     if field is not None:
         args["task_id"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return OrderResponse(**args)
 
 
 def unmarshal_RefreshDNSZoneResponse(data: Any) -> RefreshDNSZoneResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1925,14 +2079,16 @@
     field = data.get("project_id", None)
     if field is not None:
         args["project_id"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return RegisterExternalDomainResponse(**args)
 
 
 def unmarshal_RestoreDNSZoneVersionResponse(data: Any) -> RestoreDNSZoneVersionResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1959,14 +2115,16 @@
     field = data.get("available", None)
     if field is not None:
         args["available"] = field
 
     field = data.get("tld", None)
     if field is not None:
         args["tld"] = unmarshal_Tld(field)
+    else:
+        args["tld"] = None
 
     return AvailableDomain(**args)
 
 
 def unmarshal_SearchAvailableDomainsResponse(
     data: Any,
 ) -> SearchAvailableDomainsResponse:
@@ -2296,17 +2454,17 @@
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.legal_form is not None:
         output["legal_form"] = str(request.legal_form)
 
     if request.legal_form_registration_number is not None:
-        output[
-            "legal_form_registration_number"
-        ] = request.legal_form_registration_number
+        output["legal_form_registration_number"] = (
+            request.legal_form_registration_number
+        )
 
     return output
 
 
 def marshal_ContactQuestion(
     request: ContactQuestion,
     defaults: ProfileDefaults,
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/domain/v2beta1/types.py` & `scaleway_async-2.1.0/scaleway_async/domain/v2beta1/types.py`

 * *Files 6% similar despite different names*

```diff
@@ -78,14 +78,23 @@
     ASSOCIATION = "association"
     OTHER = "other"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
+class ContactStatus(str, Enum, metaclass=StrEnumMeta):
+    STATUS_UNKNOWN = "status_unknown"
+    ACTIVE = "active"
+    PENDING = "pending"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 class DNSZoneStatus(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN = "unknown"
     ACTIVE = "active"
     PENDING = "pending"
     ERROR = "error"
     LOCKED = "locked"
 
@@ -616,24 +625,26 @@
 
     lang: StdLanguageCode
 
     resale: bool
 
     whois_opt_in: bool
 
-    email_status: ContactEmailStatus
-
-    state: str
-
     questions: Optional[List[ContactQuestion]]
 
     extension_fr: Optional[ContactExtensionFR]
 
     extension_eu: Optional[ContactExtensionEU]
 
+    email_status: ContactEmailStatus
+
+    state: str
+
+    status: ContactStatus
+
     extension_nl: Optional[ContactExtensionNL]
 
 
 @dataclass
 class ContactRolesRoles:
     is_owner: bool
 
@@ -831,21 +842,25 @@
 
     epp_code: List[str]
 
     registrar: str
 
     is_external: bool
 
+    expired_at: Optional[datetime]
+
+    updated_at: Optional[datetime]
+
     status: DomainStatus
 
     organization_id: str
 
-    expired_at: Optional[datetime]
+    pending_trade: bool
 
-    updated_at: Optional[datetime]
+    created_at: Optional[datetime]
 
     external_domain_registration_status: Optional[
         DomainRegistrationStatusExternalDomain
     ]
 
     transfer_registration_status: Optional[DomainRegistrationStatusTransfer]
 
@@ -889,30 +904,62 @@
 
     expired_at: Optional[datetime]
 
 
 @dataclass
 class Task:
     id: str
+    """
+    The unique identifier of the task.
+    """
 
     project_id: str
+    """
+    The project ID associated to the task.
+    """
 
     organization_id: str
+    """
+    The organization ID associated to the task.
+    """
 
     type_: TaskType
+    """
+    The type of the task.
+    """
 
     status: TaskStatus
+    """
+    The status of the task.
+    """
 
     domain: Optional[str]
+    """
+    The domain name associated to the task.
+    """
 
     started_at: Optional[datetime]
+    """
+    Start date of the task.
+    """
 
     updated_at: Optional[datetime]
+    """
+    Last update of the task.
+    """
 
     message: Optional[str]
+    """
+    Error message associated to the task.
+    """
+
+    contact_identifier: Optional[str]
+    """
+    Human-friendly contact identifier used when the task concerns a contact.
+    """
 
 
 @dataclass
 class TransferInDomainRequestTransferRequest:
     domain: str
 
     auth_code: str
@@ -1053,40 +1100,84 @@
     domain: str
 
     organization_id: str
 
     project_id: str
 
     auto_renew_status: DomainFeatureStatus
+    """
+    Status of the automatic renewal of the domain.
+    """
 
     epp_code: List[str]
+    """
+    List of the domain's EPP codes.
+    """
 
     dnssec: Optional[DomainDNSSEC]
+    """
+    Status of the DNSSEC configuration of the domain.
+    """
 
     expired_at: Optional[datetime]
+    """
+    Date of expiration of the domain.
+    """
 
     updated_at: Optional[datetime]
+    """
+    Domain's last modification date.
+    """
 
     registrar: str
 
     is_external: bool
+    """
+    Indicates whether Scaleway is the domain's registrar.
+    """
 
     status: DomainStatus
+    """
+    Status of the domain.
+    """
 
     dns_zones: List[DNSZone]
+    """
+    List of the domain's DNS zones.
+    """
 
     linked_products: List[LinkedProduct]
+    """
+    List of Scaleway resources linked to the domain.
+    """
+
+    pending_trade: bool
+    """
+    Indicates if a trade is ongoing.
+    """
 
     owner_contact: Optional[Contact]
+    """
+    Contact information of the domain's owner.
+    """
 
     technical_contact: Optional[Contact]
+    """
+    Contact information of the domain's technical contact.
+    """
 
     administrative_contact: Optional[Contact]
+    """
+    Contact information of the domain's administrative contact.
+    """
 
     tld: Optional[Tld]
+    """
+    Domain's TLD information.
+    """
 
     external_domain_registration_status: Optional[
         DomainRegistrationStatusExternalDomain
     ]
 
     transfer_registration_status: Optional[DomainRegistrationStatusTransfer]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import FlexibleIPStatus
-from .content import FLEXIBLEIP_TRANSIENT_STATUSES
+from .content import FLEXIBLE_IP_TRANSIENT_STATUSES
 from .types import ListFlexibleIPsRequestOrderBy
 from .types import MACAddressStatus
-from .content import MACADDRESS_TRANSIENT_STATUSES
+from .content import MAC_ADDRESS_TRANSIENT_STATUSES
 from .types import MACAddressType
 from .types import MACAddress
 from .types import FlexibleIP
 from .types import AttachFlexibleIPRequest
 from .types import AttachFlexibleIPsResponse
 from .types import CreateFlexibleIPRequest
 from .types import DeleteFlexibleIPRequest
@@ -22,18 +22,18 @@
 from .types import ListFlexibleIPsResponse
 from .types import MoveMACAddrRequest
 from .types import UpdateFlexibleIPRequest
 from .api import FlexibleipV1Alpha1API
 
 __all__ = [
     "FlexibleIPStatus",
-    "FLEXIBLEIP_TRANSIENT_STATUSES",
+    "FLEXIBLE_IP_TRANSIENT_STATUSES",
     "ListFlexibleIPsRequestOrderBy",
     "MACAddressStatus",
-    "MACADDRESS_TRANSIENT_STATUSES",
+    "MAC_ADDRESS_TRANSIENT_STATUSES",
     "MACAddressType",
     "MACAddress",
     "FlexibleIP",
     "AttachFlexibleIPRequest",
     "AttachFlexibleIPsResponse",
     "CreateFlexibleIPRequest",
     "DeleteFlexibleIPRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/api.py`

 * *Files 0% similar despite different names*

```diff
@@ -26,15 +26,15 @@
     FlexibleIP,
     GenerateMACAddrRequest,
     ListFlexibleIPsResponse,
     MoveMACAddrRequest,
     UpdateFlexibleIPRequest,
 )
 from .content import (
-    FLEXIBLEIP_TRANSIENT_STATUSES,
+    FLEXIBLE_IP_TRANSIENT_STATUSES,
 )
 from .marshalling import (
     unmarshal_FlexibleIP,
     unmarshal_AttachFlexibleIPsResponse,
     unmarshal_DetachFlexibleIPsResponse,
     unmarshal_ListFlexibleIPsResponse,
     marshal_AttachFlexibleIPRequest,
@@ -162,15 +162,15 @@
             )
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
-            options.stop = lambda res: res.status not in FLEXIBLEIP_TRANSIENT_STATUSES
+            options.stop = lambda res: res.status not in FLEXIBLE_IP_TRANSIENT_STATUSES
 
         return await wait_for_resource_async(
             fetcher=self.get_flexible_ip,
             options=options,
             args={
                 "fip_id": fip_id,
                 "zone": zone,
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/content.py` & `scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/content.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,21 +3,21 @@
 from typing import List
 
 from .types import (
     FlexibleIPStatus,
     MACAddressStatus,
 )
 
-FLEXIBLEIP_TRANSIENT_STATUSES: List[FlexibleIPStatus] = [
+FLEXIBLE_IP_TRANSIENT_STATUSES: List[FlexibleIPStatus] = [
     FlexibleIPStatus.UPDATING,
     FlexibleIPStatus.DETACHING,
 ]
 """
 Lists transient statutes of the enum :class:`FlexibleIPStatus <FlexibleIPStatus>`.
 """
-MACADDRESS_TRANSIENT_STATUSES: List[MACAddressStatus] = [
+MAC_ADDRESS_TRANSIENT_STATUSES: List[MACAddressStatus] = [
     MACAddressStatus.UPDATING,
     MACAddressStatus.DELETING,
 ]
 """
 Lists transient statutes of the enum :class:`MACAddressStatus <MACAddressStatus>`.
 """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/marshalling.py`

 * *Files 3% similar despite different names*

```diff
@@ -48,18 +48,22 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return MACAddress(**args)
 
 
 def unmarshal_FlexibleIP(data: Any) -> FlexibleIP:
     if not isinstance(data, dict):
         raise TypeError(
@@ -95,34 +99,42 @@
     field = data.get("ip_address", None)
     if field is not None:
         args["ip_address"] = field
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("reverse", None)
     if field is not None:
         args["reverse"] = field
 
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("mac_address", None)
     if field is not None:
         args["mac_address"] = unmarshal_MACAddress(field)
+    else:
+        args["mac_address"] = None
 
     field = data.get("server_id", None)
     if field is not None:
         args["server_id"] = field
+    else:
+        args["server_id"] = None
 
     return FlexibleIP(**args)
 
 
 def unmarshal_AttachFlexibleIPsResponse(data: Any) -> AttachFlexibleIPsResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/flexibleip/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/flexibleip/v1alpha1/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/function/v1beta1/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,19 +8,17 @@
 from .types import FunctionPrivacy
 from .types import FunctionRuntime
 from .types import FunctionStatus
 from .content import FUNCTION_TRANSIENT_STATUSES
 from .types import ListCronsRequestOrderBy
 from .types import ListDomainsRequestOrderBy
 from .types import ListFunctionsRequestOrderBy
-from .types import ListLogsRequestOrderBy
 from .types import ListNamespacesRequestOrderBy
 from .types import ListTokensRequestOrderBy
 from .types import ListTriggersRequestOrderBy
-from .types import LogStream
 from .types import NamespaceStatus
 from .content import NAMESPACE_TRANSIENT_STATUSES
 from .types import RuntimeStatus
 from .types import TokenStatus
 from .content import TOKEN_TRANSIENT_STATUSES
 from .types import TriggerInputType
 from .types import TriggerStatus
@@ -33,15 +31,14 @@
 from .types import CreateTriggerRequestMnqNatsClientConfig
 from .types import CreateTriggerRequestMnqSqsClientConfig
 from .types import CreateTriggerRequestSqsClientConfig
 from .types import Cron
 from .types import Domain
 from .types import Runtime
 from .types import Function
-from .types import Log
 from .types import Namespace
 from .types import Token
 from .types import Trigger
 from .types import UpdateTriggerRequestSqsClientConfig
 from .types import CreateCronRequest
 from .types import CreateDomainRequest
 from .types import CreateFunctionRequest
@@ -69,16 +66,14 @@
 from .types import ListCronsResponse
 from .types import ListDomainsRequest
 from .types import ListDomainsResponse
 from .types import ListFunctionRuntimesRequest
 from .types import ListFunctionRuntimesResponse
 from .types import ListFunctionsRequest
 from .types import ListFunctionsResponse
-from .types import ListLogsRequest
-from .types import ListLogsResponse
 from .types import ListNamespacesRequest
 from .types import ListNamespacesResponse
 from .types import ListTokensRequest
 from .types import ListTokensResponse
 from .types import ListTriggersRequest
 from .types import ListTriggersResponse
 from .types import UpdateCronRequest
@@ -97,19 +92,17 @@
     "FunctionPrivacy",
     "FunctionRuntime",
     "FunctionStatus",
     "FUNCTION_TRANSIENT_STATUSES",
     "ListCronsRequestOrderBy",
     "ListDomainsRequestOrderBy",
     "ListFunctionsRequestOrderBy",
-    "ListLogsRequestOrderBy",
     "ListNamespacesRequestOrderBy",
     "ListTokensRequestOrderBy",
     "ListTriggersRequestOrderBy",
-    "LogStream",
     "NamespaceStatus",
     "NAMESPACE_TRANSIENT_STATUSES",
     "RuntimeStatus",
     "TokenStatus",
     "TOKEN_TRANSIENT_STATUSES",
     "TriggerInputType",
     "TriggerStatus",
@@ -122,15 +115,14 @@
     "CreateTriggerRequestMnqNatsClientConfig",
     "CreateTriggerRequestMnqSqsClientConfig",
     "CreateTriggerRequestSqsClientConfig",
     "Cron",
     "Domain",
     "Runtime",
     "Function",
-    "Log",
     "Namespace",
     "Token",
     "Trigger",
     "UpdateTriggerRequestSqsClientConfig",
     "CreateCronRequest",
     "CreateDomainRequest",
     "CreateFunctionRequest",
@@ -158,16 +150,14 @@
     "ListCronsResponse",
     "ListDomainsRequest",
     "ListDomainsResponse",
     "ListFunctionRuntimesRequest",
     "ListFunctionRuntimesResponse",
     "ListFunctionsRequest",
     "ListFunctionsResponse",
-    "ListLogsRequest",
-    "ListLogsResponse",
     "ListNamespacesRequest",
     "ListNamespacesResponse",
     "ListTokensRequest",
     "ListTokensResponse",
     "ListTriggersRequest",
     "ListTriggersResponse",
     "UpdateCronRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/api.py` & `scaleway_async-2.1.0/scaleway_async/function/v1beta1/api.py`

 * *Files 8% similar despite different names*

```diff
@@ -20,15 +20,14 @@
 from .types import (
     FunctionHttpOption,
     FunctionPrivacy,
     FunctionRuntime,
     ListCronsRequestOrderBy,
     ListDomainsRequestOrderBy,
     ListFunctionsRequestOrderBy,
-    ListLogsRequestOrderBy,
     ListNamespacesRequestOrderBy,
     ListTokensRequestOrderBy,
     ListTriggersRequestOrderBy,
     CreateCronRequest,
     CreateDomainRequest,
     CreateFunctionRequest,
     CreateNamespaceRequest,
@@ -41,19 +40,17 @@
     Domain,
     DownloadURL,
     Function,
     ListCronsResponse,
     ListDomainsResponse,
     ListFunctionRuntimesResponse,
     ListFunctionsResponse,
-    ListLogsResponse,
     ListNamespacesResponse,
     ListTokensResponse,
     ListTriggersResponse,
-    Log,
     Namespace,
     Secret,
     Token,
     Trigger,
     UpdateCronRequest,
     UpdateFunctionRequest,
     UpdateNamespaceRequest,
@@ -77,15 +74,14 @@
     unmarshal_Token,
     unmarshal_Trigger,
     unmarshal_DownloadURL,
     unmarshal_ListCronsResponse,
     unmarshal_ListDomainsResponse,
     unmarshal_ListFunctionRuntimesResponse,
     unmarshal_ListFunctionsResponse,
-    unmarshal_ListLogsResponse,
     unmarshal_ListNamespacesResponse,
     unmarshal_ListTokensResponse,
     unmarshal_ListTriggersResponse,
     unmarshal_UploadURL,
     marshal_CreateCronRequest,
     marshal_CreateDomainRequest,
     marshal_CreateFunctionRequest,
@@ -413,15 +409,14 @@
         order_by: Optional[ListFunctionsRequestOrderBy] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListFunctionsResponse:
         """
         List all your functions.
-        List all your functions.
         :param namespace_id: UUID of the namespace the function belongs to.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number.
         :param page_size: Number of functions per page.
         :param order_by: Order of the functions.
         :param name: Name of the function.
         :param organization_id: UUID of the Organziation the function belongs to.
@@ -468,15 +463,14 @@
         order_by: Optional[ListFunctionsRequestOrderBy] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Function]:
         """
         List all your functions.
-        List all your functions.
         :param namespace_id: UUID of the namespace the function belongs to.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number.
         :param page_size: Number of functions per page.
         :param order_by: Order of the functions.
         :param name: Name of the function.
         :param organization_id: UUID of the Organziation the function belongs to.
@@ -1198,99 +1192,14 @@
             "DELETE",
             f"/functions/v1beta1/regions/{param_region}/crons/{param_cron_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Cron(res.json())
 
-    async def list_logs(
-        self,
-        *,
-        function_id: str,
-        region: Optional[Region] = None,
-        page: Optional[int] = None,
-        page_size: Optional[int] = None,
-        order_by: Optional[ListLogsRequestOrderBy] = None,
-    ) -> ListLogsResponse:
-        """
-        List application logs.
-        List the application logs of the function with the specified ID.
-        :param function_id: UUID of the function to get the logs for.
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param page: Page number.
-        :param page_size: Number of logs per page.
-        :param order_by: Order of the logs.
-        :return: :class:`ListLogsResponse <ListLogsResponse>`
-
-        Usage:
-        ::
-
-            result = await api.list_logs(
-                function_id="example",
-            )
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_function_id = validate_path_param("function_id", function_id)
-
-        res = self._request(
-            "GET",
-            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}/logs",
-            params={
-                "order_by": order_by,
-                "page": page,
-                "page_size": page_size or self.client.default_page_size,
-            },
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_ListLogsResponse(res.json())
-
-    async def list_logs_all(
-        self,
-        *,
-        function_id: str,
-        region: Optional[Region] = None,
-        page: Optional[int] = None,
-        page_size: Optional[int] = None,
-        order_by: Optional[ListLogsRequestOrderBy] = None,
-    ) -> List[Log]:
-        """
-        List application logs.
-        List the application logs of the function with the specified ID.
-        :param function_id: UUID of the function to get the logs for.
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param page: Page number.
-        :param page_size: Number of logs per page.
-        :param order_by: Order of the logs.
-        :return: :class:`List[Log] <List[Log]>`
-
-        Usage:
-        ::
-
-            result = await api.list_logs_all(
-                function_id="example",
-            )
-        """
-
-        return await fetch_all_pages_async(
-            type=ListLogsResponse,
-            key="logs",
-            fetcher=self.list_logs,
-            args={
-                "function_id": function_id,
-                "region": region,
-                "page": page,
-                "page_size": page_size,
-                "order_by": order_by,
-            },
-        )
-
     async def list_domains(
         self,
         *,
         function_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
@@ -1530,15 +1439,17 @@
         expires_at: Optional[datetime] = None,
     ) -> Token:
         """
         Create a JWT token.
         Deprecated in favor of CreateToken.
         :param region: Region to target. If none is passed will use default region from the config.
         :param function_id:
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id' could be set.
         :param namespace_id:
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id' could be set.
         :param expires_at:
         :return: :class:`Token <Token>`
         :deprecated
 
         Usage:
         ::
 
@@ -1573,18 +1484,19 @@
         function_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
         description: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> Token:
         """
         Create a new revocable token.
-        Create a new revocable token.
         :param region: Region to target. If none is passed will use default region from the config.
         :param function_id: UUID of the function to associate the token with.
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id' could be set.
         :param namespace_id: UUID of the namespace to associate the token with.
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id' could be set.
         :param description: Description of the token.
         :param expires_at: Date on which the token expires.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
@@ -1617,15 +1529,14 @@
         self,
         *,
         token_id: str,
         region: Optional[Region] = None,
     ) -> Token:
         """
         Get a token.
-        Get a token.
         :param token_id: UUID of the token to get.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
@@ -1652,15 +1563,14 @@
         *,
         token_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Token, Union[bool, Awaitable[bool]]]] = None,
     ) -> Token:
         """
         Get a token.
-        Get a token.
         :param token_id: UUID of the token to get.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
@@ -1692,15 +1602,14 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListTokensRequestOrderBy] = None,
         function_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
     ) -> ListTokensResponse:
         """
         List all tokens.
-        List all tokens.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number.
         :param page_size: Number of tokens per page.
         :param order_by: Sort order for the tokens.
         :param function_id: UUID of the function the token is assoicated with.
         :param namespace_id: UUID of the namespace the token is associated with.
         :return: :class:`ListTokensResponse <ListTokensResponse>`
@@ -1738,15 +1647,14 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListTokensRequestOrderBy] = None,
         function_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
     ) -> List[Token]:
         """
         List all tokens.
-        List all tokens.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number.
         :param page_size: Number of tokens per page.
         :param order_by: Sort order for the tokens.
         :param function_id: UUID of the function the token is assoicated with.
         :param namespace_id: UUID of the namespace the token is associated with.
         :return: :class:`List[Token] <List[Token]>`
@@ -1775,15 +1683,14 @@
         self,
         *,
         token_id: str,
         region: Optional[Region] = None,
     ) -> Token:
         """
         Delete a token.
-        Delete a token.
         :param token_id: UUID of the token to delete.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
@@ -1820,16 +1727,19 @@
         Create a trigger.
         Create a new trigger for a specified function.
         :param name: Name of the trigger.
         :param function_id: ID of the function to trigger.
         :param region: Region to target. If none is passed will use default region from the config.
         :param description: Description of the trigger.
         :param scw_sqs_config: Configuration for a Scaleway Messaging and Queuing SQS queue.
+        One-Of ('config'): at most one of 'scw_sqs_config', 'scw_nats_config', 'sqs_config' could be set.
         :param scw_nats_config: Configuration for a Scaleway Messaging and Queuing NATS subject.
+        One-Of ('config'): at most one of 'scw_sqs_config', 'scw_nats_config', 'sqs_config' could be set.
         :param sqs_config: Configuration for an AWS SQS queue.
+        One-Of ('config'): at most one of 'scw_sqs_config', 'scw_nats_config', 'sqs_config' could be set.
         :return: :class:`Trigger <Trigger>`
 
         Usage:
         ::
 
             result = await api.create_trigger(
                 name="example",
@@ -1947,16 +1857,19 @@
         List all triggers.
         List all triggers belonging to a specified Organization or Project.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number to return.
         :param page_size: Maximum number of triggers to return per page.
         :param order_by: Order in which to return results.
         :param function_id: ID of the function the triggers belongs to.
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id', 'project_id' could be set.
         :param namespace_id: ID of the namespace the triggers belongs to.
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id', 'project_id' could be set.
         :param project_id: ID of the project the triggers belongs to.
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id', 'project_id' could be set.
         :return: :class:`ListTriggersResponse <ListTriggersResponse>`
 
         Usage:
         ::
 
             result = await api.list_triggers()
         """
@@ -2000,16 +1913,19 @@
         List all triggers.
         List all triggers belonging to a specified Organization or Project.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number to return.
         :param page_size: Maximum number of triggers to return per page.
         :param order_by: Order in which to return results.
         :param function_id: ID of the function the triggers belongs to.
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id', 'project_id' could be set.
         :param namespace_id: ID of the namespace the triggers belongs to.
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id', 'project_id' could be set.
         :param project_id: ID of the project the triggers belongs to.
+        One-Of ('scope'): at most one of 'function_id', 'namespace_id', 'project_id' could be set.
         :return: :class:`List[Trigger] <List[Trigger]>`
 
         Usage:
         ::
 
             result = await api.list_triggers_all()
         """
@@ -2042,14 +1958,15 @@
         Update a trigger.
         Update a trigger with a specified ID.
         :param trigger_id: ID of the trigger to update.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the trigger.
         :param description: Description of the trigger.
         :param sqs_config: Configuration for an AWS SQS queue.
+        One-Of ('config'): at most one of 'sqs_config' could be set.
         :return: :class:`Trigger <Trigger>`
 
         Usage:
         ::
 
             result = await api.update_trigger(
                 trigger_id="example",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/content.py` & `scaleway_async-2.1.0/scaleway_async/function/v1beta1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/container/v1beta1/marshalling.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,124 +6,48 @@
 
 from scaleway_core.profile import ProfileDefaults
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from .types import (
+    SecretHashedValue,
+    Container,
     Cron,
     Domain,
-    SecretHashedValue,
-    Function,
     Namespace,
     Token,
     TriggerMnqNatsClientConfig,
     TriggerMnqSqsClientConfig,
     TriggerSqsClientConfig,
     Trigger,
-    DownloadURL,
+    ListContainersResponse,
     ListCronsResponse,
     ListDomainsResponse,
-    Runtime,
-    ListFunctionRuntimesResponse,
-    ListFunctionsResponse,
-    Log,
-    ListLogsResponse,
     ListNamespacesResponse,
     ListTokensResponse,
     ListTriggersResponse,
-    UploadURL,
+    Secret,
+    CreateContainerRequest,
     CreateCronRequest,
     CreateDomainRequest,
-    Secret,
-    CreateFunctionRequest,
     CreateNamespaceRequest,
     CreateTokenRequest,
     CreateTriggerRequestMnqNatsClientConfig,
     CreateTriggerRequestMnqSqsClientConfig,
     CreateTriggerRequestSqsClientConfig,
     CreateTriggerRequest,
+    UpdateContainerRequest,
     UpdateCronRequest,
-    UpdateFunctionRequest,
     UpdateNamespaceRequest,
     UpdateTriggerRequestSqsClientConfig,
     UpdateTriggerRequest,
 )
 
 
-def unmarshal_Cron(data: Any) -> Cron:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Cron' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("id", None)
-    if field is not None:
-        args["id"] = field
-
-    field = data.get("function_id", None)
-    if field is not None:
-        args["function_id"] = field
-
-    field = data.get("schedule", None)
-    if field is not None:
-        args["schedule"] = field
-
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
-
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
-    field = data.get("args", None)
-    if field is not None:
-        args["args"] = field
-
-    return Cron(**args)
-
-
-def unmarshal_Domain(data: Any) -> Domain:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Domain' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("id", None)
-    if field is not None:
-        args["id"] = field
-
-    field = data.get("hostname", None)
-    if field is not None:
-        args["hostname"] = field
-
-    field = data.get("function_id", None)
-    if field is not None:
-        args["function_id"] = field
-
-    field = data.get("url", None)
-    if field is not None:
-        args["url"] = field
-
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
-
-    field = data.get("error_message", None)
-    if field is not None:
-        args["error_message"] = field
-
-    return Domain(**args)
-
-
 def unmarshal_SecretHashedValue(data: Any) -> SecretHashedValue:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'SecretHashedValue' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -135,18 +59,18 @@
     field = data.get("hashed_value", None)
     if field is not None:
         args["hashed_value"] = field
 
     return SecretHashedValue(**args)
 
 
-def unmarshal_Function(data: Any) -> Function:
+def unmarshal_Container(data: Any) -> Container:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Function' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Container' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
@@ -171,75 +95,155 @@
     if field is not None:
         args["min_scale"] = field
 
     field = data.get("max_scale", None)
     if field is not None:
         args["max_scale"] = field
 
-    field = data.get("runtime", None)
-    if field is not None:
-        args["runtime"] = field
-
     field = data.get("memory_limit", None)
     if field is not None:
         args["memory_limit"] = field
 
     field = data.get("cpu_limit", None)
     if field is not None:
         args["cpu_limit"] = field
 
-    field = data.get("handler", None)
-    if field is not None:
-        args["handler"] = field
-
     field = data.get("privacy", None)
     if field is not None:
         args["privacy"] = field
 
+    field = data.get("registry_image", None)
+    if field is not None:
+        args["registry_image"] = field
+
+    field = data.get("max_concurrency", None)
+    if field is not None:
+        args["max_concurrency"] = field
+
+    field = data.get("timeout", None)
+    if field is not None:
+        args["timeout"] = field
+    else:
+        args["timeout"] = None
+
+    field = data.get("error_message", None)
+    if field is not None:
+        args["error_message"] = field
+    else:
+        args["error_message"] = None
+
+    field = data.get("description", None)
+    if field is not None:
+        args["description"] = field
+    else:
+        args["description"] = None
+
     field = data.get("domain_name", None)
     if field is not None:
         args["domain_name"] = field
 
+    field = data.get("protocol", None)
+    if field is not None:
+        args["protocol"] = field
+
+    field = data.get("port", None)
+    if field is not None:
+        args["port"] = field
+
     field = data.get("secret_environment_variables", None)
     if field is not None:
         args["secret_environment_variables"] = (
             [unmarshal_SecretHashedValue(v) for v in field]
             if field is not None
             else None
         )
 
+    field = data.get("http_option", None)
+    if field is not None:
+        args["http_option"] = field
+
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
-    field = data.get("http_option", None)
+    return Container(**args)
+
+
+def unmarshal_Cron(data: Any) -> Cron:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'Cron' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("id", None)
     if field is not None:
-        args["http_option"] = field
+        args["id"] = field
 
-    field = data.get("runtime_message", None)
+    field = data.get("container_id", None)
     if field is not None:
-        args["runtime_message"] = field
+        args["container_id"] = field
 
-    field = data.get("timeout", None)
+    field = data.get("schedule", None)
     if field is not None:
-        args["timeout"] = field
+        args["schedule"] = field
 
-    field = data.get("error_message", None)
+    field = data.get("status", None)
     if field is not None:
-        args["error_message"] = field
+        args["status"] = field
 
-    field = data.get("build_message", None)
+    field = data.get("name", None)
     if field is not None:
-        args["build_message"] = field
+        args["name"] = field
 
-    field = data.get("description", None)
+    field = data.get("args", None)
     if field is not None:
-        args["description"] = field
+        args["args"] = field
+    else:
+        args["args"] = None
+
+    return Cron(**args)
+
+
+def unmarshal_Domain(data: Any) -> Domain:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'Domain' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("id", None)
+    if field is not None:
+        args["id"] = field
+
+    field = data.get("hostname", None)
+    if field is not None:
+        args["hostname"] = field
+
+    field = data.get("container_id", None)
+    if field is not None:
+        args["container_id"] = field
+
+    field = data.get("url", None)
+    if field is not None:
+        args["url"] = field
 
-    return Function(**args)
+    field = data.get("status", None)
+    if field is not None:
+        args["status"] = field
+
+    field = data.get("error_message", None)
+    if field is not None:
+        args["error_message"] = field
+    else:
+        args["error_message"] = None
+
+    return Domain(**args)
 
 
 def unmarshal_Namespace(data: Any) -> Namespace:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Namespace' failed as data isn't a dictionary."
         )
@@ -289,18 +293,22 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("error_message", None)
     if field is not None:
         args["error_message"] = field
+    else:
+        args["error_message"] = None
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
+    else:
+        args["description"] = None
 
     return Namespace(**args)
 
 
 def unmarshal_Token(data: Any) -> Token:
     if not isinstance(data, dict):
         raise TypeError(
@@ -317,33 +325,43 @@
     if field is not None:
         args["token"] = field
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
-    field = data.get("function_id", None)
+    field = data.get("container_id", None)
     if field is not None:
-        args["function_id"] = field
+        args["container_id"] = field
+    else:
+        args["container_id"] = None
 
     field = data.get("namespace_id", None)
     if field is not None:
         args["namespace_id"] = field
+    else:
+        args["namespace_id"] = None
 
     field = data.get("public_key", None)
     if field is not None:
         args["public_key"] = field
+    else:
+        args["public_key"] = None
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
+    else:
+        args["description"] = None
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     return Token(**args)
 
 
 def unmarshal_TriggerMnqNatsClientConfig(data: Any) -> TriggerMnqNatsClientConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -364,21 +382,19 @@
     if field is not None:
         args["mnq_project_id"] = field
 
     field = data.get("mnq_region", None)
     if field is not None:
         args["mnq_region"] = field
 
-    field = data.get("mnq_namespace_id", None)
-    if field is not None:
-        args["mnq_namespace_id"] = field
-
     field = data.get("mnq_credential_id", None)
     if field is not None:
         args["mnq_credential_id"] = field
+    else:
+        args["mnq_credential_id"] = None
 
     return TriggerMnqNatsClientConfig(**args)
 
 
 def unmarshal_TriggerMnqSqsClientConfig(data: Any) -> TriggerMnqSqsClientConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -395,21 +411,19 @@
     if field is not None:
         args["mnq_project_id"] = field
 
     field = data.get("mnq_region", None)
     if field is not None:
         args["mnq_region"] = field
 
-    field = data.get("mnq_namespace_id", None)
-    if field is not None:
-        args["mnq_namespace_id"] = field
-
     field = data.get("mnq_credential_id", None)
     if field is not None:
         args["mnq_credential_id"] = field
+    else:
+        args["mnq_credential_id"] = None
 
     return TriggerMnqSqsClientConfig(**args)
 
 
 def unmarshal_TriggerSqsClientConfig(data: Any) -> TriggerSqsClientConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -453,62 +467,72 @@
     if field is not None:
         args["name"] = field
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
-    field = data.get("function_id", None)
+    field = data.get("container_id", None)
     if field is not None:
-        args["function_id"] = field
+        args["container_id"] = field
 
     field = data.get("input_type", None)
     if field is not None:
         args["input_type"] = field
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("error_message", None)
     if field is not None:
         args["error_message"] = field
+    else:
+        args["error_message"] = None
 
     field = data.get("scw_sqs_config", None)
     if field is not None:
         args["scw_sqs_config"] = unmarshal_TriggerMnqSqsClientConfig(field)
+    else:
+        args["scw_sqs_config"] = None
 
     field = data.get("scw_nats_config", None)
     if field is not None:
         args["scw_nats_config"] = unmarshal_TriggerMnqNatsClientConfig(field)
+    else:
+        args["scw_nats_config"] = None
 
     field = data.get("sqs_config", None)
     if field is not None:
         args["sqs_config"] = unmarshal_TriggerSqsClientConfig(field)
+    else:
+        args["sqs_config"] = None
 
     return Trigger(**args)
 
 
-def unmarshal_DownloadURL(data: Any) -> DownloadURL:
+def unmarshal_ListContainersResponse(data: Any) -> ListContainersResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'DownloadURL' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListContainersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("url", None)
+    field = data.get("containers", None)
     if field is not None:
-        args["url"] = field
+        args["containers"] = (
+            [unmarshal_Container(v) for v in field] if field is not None else None
+        )
 
-    field = data.get("headers", None)
+    field = data.get("total_count", None)
     if field is not None:
-        args["headers"] = field
+        args["total_count"] = field
 
-    return DownloadURL(**args)
+    return ListContainersResponse(**args)
 
 
 def unmarshal_ListCronsResponse(data: Any) -> ListCronsResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ListCronsResponse' failed as data isn't a dictionary."
         )
@@ -545,161 +569,14 @@
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
     return ListDomainsResponse(**args)
 
 
-def unmarshal_Runtime(data: Any) -> Runtime:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Runtime' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
-    field = data.get("language", None)
-    if field is not None:
-        args["language"] = field
-
-    field = data.get("version", None)
-    if field is not None:
-        args["version"] = field
-
-    field = data.get("default_handler", None)
-    if field is not None:
-        args["default_handler"] = field
-
-    field = data.get("code_sample", None)
-    if field is not None:
-        args["code_sample"] = field
-
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
-
-    field = data.get("status_message", None)
-    if field is not None:
-        args["status_message"] = field
-
-    field = data.get("extension", None)
-    if field is not None:
-        args["extension"] = field
-
-    field = data.get("implementation", None)
-    if field is not None:
-        args["implementation"] = field
-
-    field = data.get("logo_url", None)
-    if field is not None:
-        args["logo_url"] = field
-
-    return Runtime(**args)
-
-
-def unmarshal_ListFunctionRuntimesResponse(data: Any) -> ListFunctionRuntimesResponse:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'ListFunctionRuntimesResponse' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("runtimes", None)
-    if field is not None:
-        args["runtimes"] = (
-            [unmarshal_Runtime(v) for v in field] if field is not None else None
-        )
-
-    field = data.get("total_count", None)
-    if field is not None:
-        args["total_count"] = field
-
-    return ListFunctionRuntimesResponse(**args)
-
-
-def unmarshal_ListFunctionsResponse(data: Any) -> ListFunctionsResponse:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'ListFunctionsResponse' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("functions", None)
-    if field is not None:
-        args["functions"] = (
-            [unmarshal_Function(v) for v in field] if field is not None else None
-        )
-
-    field = data.get("total_count", None)
-    if field is not None:
-        args["total_count"] = field
-
-    return ListFunctionsResponse(**args)
-
-
-def unmarshal_Log(data: Any) -> Log:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Log' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("message", None)
-    if field is not None:
-        args["message"] = field
-
-    field = data.get("id", None)
-    if field is not None:
-        args["id"] = field
-
-    field = data.get("level", None)
-    if field is not None:
-        args["level"] = field
-
-    field = data.get("source", None)
-    if field is not None:
-        args["source"] = field
-
-    field = data.get("stream", None)
-    if field is not None:
-        args["stream"] = field
-
-    field = data.get("timestamp", None)
-    if field is not None:
-        args["timestamp"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    return Log(**args)
-
-
-def unmarshal_ListLogsResponse(data: Any) -> ListLogsResponse:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'ListLogsResponse' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("logs", None)
-    if field is not None:
-        args["logs"] = [unmarshal_Log(v) for v in field] if field is not None else None
-
-    field = data.get("total_count", None)
-    if field is not None:
-        args["total_count"] = field
-
-    return ListLogsResponse(**args)
-
-
 def unmarshal_ListNamespacesResponse(data: Any) -> ListNamespacesResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -755,69 +632,14 @@
         args["triggers"] = (
             [unmarshal_Trigger(v) for v in field] if field is not None else None
         )
 
     return ListTriggersResponse(**args)
 
 
-def unmarshal_UploadURL(data: Any) -> UploadURL:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'UploadURL' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("url", None)
-    if field is not None:
-        args["url"] = field
-
-    field = data.get("headers", None)
-    if field is not None:
-        args["headers"] = field
-
-    return UploadURL(**args)
-
-
-def marshal_CreateCronRequest(
-    request: CreateCronRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
-
-    if request.function_id is not None:
-        output["function_id"] = request.function_id
-
-    if request.schedule is not None:
-        output["schedule"] = request.schedule
-
-    if request.args is not None:
-        output["args"] = request.args
-
-    if request.name is not None:
-        output["name"] = request.name
-
-    return output
-
-
-def marshal_CreateDomainRequest(
-    request: CreateDomainRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
-
-    if request.hostname is not None:
-        output["hostname"] = request.hostname
-
-    if request.function_id is not None:
-        output["function_id"] = request.function_id
-
-    return output
-
-
 def marshal_Secret(
     request: Secret,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.key is not None:
@@ -825,16 +647,16 @@
 
     if request.value is not None:
         output["value"] = request.value
 
     return output
 
 
-def marshal_CreateFunctionRequest(
-    request: CreateFunctionRequest,
+def marshal_CreateContainerRequest(
+    request: CreateContainerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.namespace_id is not None:
         output["namespace_id"] = request.namespace_id
 
@@ -846,44 +668,89 @@
 
     if request.min_scale is not None:
         output["min_scale"] = request.min_scale
 
     if request.max_scale is not None:
         output["max_scale"] = request.max_scale
 
-    if request.runtime is not None:
-        output["runtime"] = str(request.runtime)
-
     if request.memory_limit is not None:
         output["memory_limit"] = request.memory_limit
 
+    if request.cpu_limit is not None:
+        output["cpu_limit"] = request.cpu_limit
+
     if request.timeout is not None:
         output["timeout"] = request.timeout
 
-    if request.handler is not None:
-        output["handler"] = request.handler
-
     if request.privacy is not None:
         output["privacy"] = str(request.privacy)
 
     if request.description is not None:
         output["description"] = request.description
 
+    if request.registry_image is not None:
+        output["registry_image"] = request.registry_image
+
+    if request.max_concurrency is not None:
+        output["max_concurrency"] = request.max_concurrency
+
+    if request.protocol is not None:
+        output["protocol"] = str(request.protocol)
+
+    if request.port is not None:
+        output["port"] = request.port
+
     if request.secret_environment_variables is not None:
         output["secret_environment_variables"] = [
             marshal_Secret(item, defaults)
             for item in request.secret_environment_variables
         ]
 
     if request.http_option is not None:
         output["http_option"] = str(request.http_option)
 
     return output
 
 
+def marshal_CreateCronRequest(
+    request: CreateCronRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.container_id is not None:
+        output["container_id"] = request.container_id
+
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
+
+    if request.args is not None:
+        output["args"] = request.args
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
+
+
+def marshal_CreateDomainRequest(
+    request: CreateDomainRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.hostname is not None:
+        output["hostname"] = request.hostname
+
+    if request.container_id is not None:
+        output["container_id"] = request.container_id
+
+    return output
+
+
 def marshal_CreateNamespaceRequest(
     request: CreateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.name is not None:
@@ -911,15 +778,15 @@
     request: CreateTokenRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
     output.update(
         resolve_one_of(
             [
-                OneOfPossibility("function_id", request.function_id),
+                OneOfPossibility("container_id", request.container_id),
                 OneOfPossibility("namespace_id", request.namespace_id),
             ]
         ),
     )
 
     if request.description is not None:
         output["description"] = request.description
@@ -944,17 +811,14 @@
 
     if request.mnq_project_id is not None:
         output["mnq_project_id"] = request.mnq_project_id
 
     if request.mnq_region is not None:
         output["mnq_region"] = request.mnq_region
 
-    if request.mnq_namespace_id is not None:
-        output["mnq_namespace_id"] = request.mnq_namespace_id
-
     return output
 
 
 def marshal_CreateTriggerRequestMnqSqsClientConfig(
     request: CreateTriggerRequestMnqSqsClientConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
@@ -965,17 +829,14 @@
 
     if request.mnq_project_id is not None:
         output["mnq_project_id"] = request.mnq_project_id
 
     if request.mnq_region is not None:
         output["mnq_region"] = request.mnq_region
 
-    if request.mnq_namespace_id is not None:
-        output["mnq_namespace_id"] = request.mnq_namespace_id
-
     return output
 
 
 def marshal_CreateTriggerRequestSqsClientConfig(
     request: CreateTriggerRequestSqsClientConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
@@ -1010,92 +871,101 @@
             ]
         ),
     )
 
     if request.name is not None:
         output["name"] = request.name
 
-    if request.function_id is not None:
-        output["function_id"] = request.function_id
+    if request.container_id is not None:
+        output["container_id"] = request.container_id
 
     if request.description is not None:
         output["description"] = request.description
 
     return output
 
 
-def marshal_UpdateCronRequest(
-    request: UpdateCronRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
-
-    if request.function_id is not None:
-        output["function_id"] = request.function_id
-
-    if request.schedule is not None:
-        output["schedule"] = request.schedule
-
-    if request.args is not None:
-        output["args"] = request.args
-
-    if request.name is not None:
-        output["name"] = request.name
-
-    return output
-
-
-def marshal_UpdateFunctionRequest(
-    request: UpdateFunctionRequest,
+def marshal_UpdateContainerRequest(
+    request: UpdateContainerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.environment_variables is not None:
         output["environment_variables"] = request.environment_variables
 
     if request.min_scale is not None:
         output["min_scale"] = request.min_scale
 
     if request.max_scale is not None:
         output["max_scale"] = request.max_scale
 
-    if request.runtime is not None:
-        output["runtime"] = str(request.runtime)
-
     if request.memory_limit is not None:
         output["memory_limit"] = request.memory_limit
 
+    if request.cpu_limit is not None:
+        output["cpu_limit"] = request.cpu_limit
+
     if request.timeout is not None:
         output["timeout"] = request.timeout
 
     if request.redeploy is not None:
         output["redeploy"] = request.redeploy
 
-    if request.handler is not None:
-        output["handler"] = request.handler
-
     if request.privacy is not None:
         output["privacy"] = str(request.privacy)
 
     if request.description is not None:
         output["description"] = request.description
 
+    if request.registry_image is not None:
+        output["registry_image"] = request.registry_image
+
+    if request.max_concurrency is not None:
+        output["max_concurrency"] = request.max_concurrency
+
+    if request.protocol is not None:
+        output["protocol"] = str(request.protocol)
+
+    if request.port is not None:
+        output["port"] = request.port
+
     if request.secret_environment_variables is not None:
         output["secret_environment_variables"] = [
             marshal_Secret(item, defaults)
             for item in request.secret_environment_variables
         ]
 
     if request.http_option is not None:
         output["http_option"] = str(request.http_option)
 
     return output
 
 
+def marshal_UpdateCronRequest(
+    request: UpdateCronRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.container_id is not None:
+        output["container_id"] = request.container_id
+
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
+
+    if request.args is not None:
+        output["args"] = request.args
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
+
+
 def marshal_UpdateNamespaceRequest(
     request: UpdateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.environment_variables is not None:
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/function/v1beta1/types.py` & `scaleway_async-2.1.0/scaleway_async/function/v1beta1/types.py`

 * *Files 1% similar despite different names*

```diff
@@ -127,22 +127,14 @@
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListLogsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
-    TIMESTAMP_DESC = "timestamp_desc"
-    TIMESTAMP_ASC = "timestamp_asc"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
 class ListNamespacesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
@@ -161,23 +153,14 @@
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class LogStream(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN = "unknown"
-    STDOUT = "stdout"
-    STDERR = "stderr"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
 class NamespaceStatus(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN = "unknown"
     READY = "ready"
     DELETING = "deleting"
     ERROR = "error"
     LOCKED = "locked"
     CREATING = "creating"
@@ -255,19 +238,17 @@
     mnq_project_id: str
     """
     ID of the Messaging and Queuing project.
     """
 
     mnq_region: str
     """
-    Currently, only the `fr-par` region is available.
+    Currently, only the `fr-par` and `nl-ams` regions are available.
     """
 
-    mnq_namespace_id: Optional[str]
-
     mnq_credential_id: Optional[str]
     """
     ID of the Messaging and Queuing credentials used to subscribe to the NATS subject.
     """
 
 
 @dataclass
@@ -280,19 +261,17 @@
     mnq_project_id: str
     """
     ID of the Messaging and Queuing project.
     """
 
     mnq_region: str
     """
-    Currently, only the `fr-par` region is available.
+    Currently, only the `fr-par` and `nl-ams` regions are available.
     """
 
-    mnq_namespace_id: Optional[str]
-
     mnq_credential_id: Optional[str]
     """
     ID of the Messaging and Queuing credentials used to read from the SQS queue.
     """
 
 
 @dataclass
@@ -328,19 +307,17 @@
     mnq_project_id: str
     """
     ID of the Messaging and Queuing project.
     """
 
     mnq_region: str
     """
-    Currently, only the `fr-par` region is available.
+    Currently, only the `fr-par` and `nl-ams` regions are available.
     """
 
-    mnq_namespace_id: Optional[str]
-
 
 @dataclass
 class CreateTriggerRequestMnqSqsClientConfig:
     queue: str
     """
     Name of the SQS queue the trigger should listen to.
     """
@@ -348,19 +325,17 @@
     mnq_project_id: str
     """
     You must have activated SQS on this project.
     """
 
     mnq_region: str
     """
-    Currently, only the `fr-par` region is available.
+    Currently, only the `fr-par` and `nl-ams` regions are available.
     """
 
-    mnq_namespace_id: Optional[str]
-
 
 @dataclass
 class CreateTriggerRequestSqsClientConfig:
     endpoint: str
 
     queue_url: str
 
@@ -562,47 +537,14 @@
     description: Optional[str]
     """
     Description of the function.
     """
 
 
 @dataclass
-class Log:
-    message: str
-    """
-    Message of the log.
-    """
-
-    id: str
-    """
-    UUID of the log.
-    """
-
-    level: str
-    """
-    Severity of the log (info, debug, error etc.).
-    """
-
-    source: str
-    """
-    Source of the log (core runtime or user code).
-    """
-
-    stream: LogStream
-    """
-    Can be stdout or stderr.
-    """
-
-    timestamp: Optional[datetime]
-    """
-    Timestamp of the log.
-    """
-
-
-@dataclass
 class Namespace:
     id: str
     """
     UUID of the namespace.
     """
 
     name: str
@@ -1325,55 +1267,14 @@
     total_count: int
     """
     Total number of functions.
     """
 
 
 @dataclass
-class ListLogsRequest:
-    function_id: str
-    """
-    UUID of the function to get the logs for.
-    """
-
-    region: Optional[Region]
-    """
-    Region to target. If none is passed will use default region from the config.
-    """
-
-    page: Optional[int]
-    """
-    Page number.
-    """
-
-    page_size: Optional[int]
-    """
-    Number of logs per page.
-    """
-
-    order_by: Optional[ListLogsRequestOrderBy]
-    """
-    Order of the logs.
-    """
-
-
-@dataclass
-class ListLogsResponse:
-    logs: List[Log]
-    """
-    Array of logs.
-    """
-
-    total_count: int
-    """
-    Total number of logs.
-    """
-
-
-@dataclass
 class ListNamespacesRequest:
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/iam/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/iam/v1alpha1/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -30,24 +30,26 @@
 from .types import User
 from .types import AddGroupMemberRequest
 from .types import AddGroupMembersRequest
 from .types import ClonePolicyRequest
 from .types import CreateAPIKeyRequest
 from .types import CreateApplicationRequest
 from .types import CreateGroupRequest
+from .types import CreateJWTRequest
 from .types import CreatePolicyRequest
 from .types import CreateSSHKeyRequest
 from .types import CreateUserRequest
 from .types import DeleteAPIKeyRequest
 from .types import DeleteApplicationRequest
 from .types import DeleteGroupRequest
 from .types import DeleteJWTRequest
 from .types import DeletePolicyRequest
 from .types import DeleteSSHKeyRequest
 from .types import DeleteUserRequest
+from .types import EncodedJWT
 from .types import GetAPIKeyRequest
 from .types import GetApplicationRequest
 from .types import GetGroupRequest
 from .types import GetJWTRequest
 from .types import GetLogRequest
 from .types import GetPolicyRequest
 from .types import GetQuotumRequest
@@ -80,14 +82,15 @@
 from .types import SetRulesRequest
 from .types import SetRulesResponse
 from .types import UpdateAPIKeyRequest
 from .types import UpdateApplicationRequest
 from .types import UpdateGroupRequest
 from .types import UpdatePolicyRequest
 from .types import UpdateSSHKeyRequest
+from .types import UpdateUserRequest
 from .api import IamV1Alpha1API
 
 __all__ = [
     "BearerType",
     "ListAPIKeysRequestOrderBy",
     "ListApplicationsRequestOrderBy",
     "ListGroupsRequestOrderBy",
@@ -117,24 +120,26 @@
     "User",
     "AddGroupMemberRequest",
     "AddGroupMembersRequest",
     "ClonePolicyRequest",
     "CreateAPIKeyRequest",
     "CreateApplicationRequest",
     "CreateGroupRequest",
+    "CreateJWTRequest",
     "CreatePolicyRequest",
     "CreateSSHKeyRequest",
     "CreateUserRequest",
     "DeleteAPIKeyRequest",
     "DeleteApplicationRequest",
     "DeleteGroupRequest",
     "DeleteJWTRequest",
     "DeletePolicyRequest",
     "DeleteSSHKeyRequest",
     "DeleteUserRequest",
+    "EncodedJWT",
     "GetAPIKeyRequest",
     "GetApplicationRequest",
     "GetGroupRequest",
     "GetJWTRequest",
     "GetLogRequest",
     "GetPolicyRequest",
     "GetQuotumRequest",
@@ -167,9 +172,10 @@
     "SetRulesRequest",
     "SetRulesResponse",
     "UpdateAPIKeyRequest",
     "UpdateApplicationRequest",
     "UpdateGroupRequest",
     "UpdatePolicyRequest",
     "UpdateSSHKeyRequest",
+    "UpdateUserRequest",
     "IamV1Alpha1API",
 ]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/iam/v1alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/iam/v1alpha1/api.py`

 * *Files 8% similar despite different names*

```diff
@@ -29,17 +29,19 @@
     APIKey,
     AddGroupMemberRequest,
     AddGroupMembersRequest,
     Application,
     CreateAPIKeyRequest,
     CreateApplicationRequest,
     CreateGroupRequest,
+    CreateJWTRequest,
     CreatePolicyRequest,
     CreateSSHKeyRequest,
     CreateUserRequest,
+    EncodedJWT,
     Group,
     JWT,
     ListAPIKeysResponse,
     ListApplicationsResponse,
     ListGroupsResponse,
     ListJWTsResponse,
     ListLogsResponse,
@@ -61,26 +63,28 @@
     SetRulesRequest,
     SetRulesResponse,
     UpdateAPIKeyRequest,
     UpdateApplicationRequest,
     UpdateGroupRequest,
     UpdatePolicyRequest,
     UpdateSSHKeyRequest,
+    UpdateUserRequest,
     User,
 )
 from .marshalling import (
     unmarshal_JWT,
     unmarshal_APIKey,
     unmarshal_Application,
     unmarshal_Group,
     unmarshal_Log,
     unmarshal_Policy,
     unmarshal_Quotum,
     unmarshal_SSHKey,
     unmarshal_User,
+    unmarshal_EncodedJWT,
     unmarshal_ListAPIKeysResponse,
     unmarshal_ListApplicationsResponse,
     unmarshal_ListGroupsResponse,
     unmarshal_ListJWTsResponse,
     unmarshal_ListLogsResponse,
     unmarshal_ListPermissionSetsResponse,
     unmarshal_ListPoliciesResponse,
@@ -90,25 +94,27 @@
     unmarshal_ListUsersResponse,
     unmarshal_SetRulesResponse,
     marshal_AddGroupMemberRequest,
     marshal_AddGroupMembersRequest,
     marshal_CreateAPIKeyRequest,
     marshal_CreateApplicationRequest,
     marshal_CreateGroupRequest,
+    marshal_CreateJWTRequest,
     marshal_CreatePolicyRequest,
     marshal_CreateSSHKeyRequest,
     marshal_CreateUserRequest,
     marshal_RemoveGroupMemberRequest,
     marshal_SetGroupMembersRequest,
     marshal_SetRulesRequest,
     marshal_UpdateAPIKeyRequest,
     marshal_UpdateApplicationRequest,
     marshal_UpdateGroupRequest,
     marshal_UpdatePolicyRequest,
     marshal_UpdateSSHKeyRequest,
+    marshal_UpdateUserRequest,
 )
 
 
 class IamV1Alpha1API(API):
     """
     IAM API.
     """
@@ -456,14 +462,52 @@
             "GET",
             f"/iam/v1alpha1/users/{param_user_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_User(res.json())
 
+    async def update_user(
+        self,
+        *,
+        user_id: str,
+        tags: Optional[List[str]] = None,
+    ) -> User:
+        """
+        Update a user.
+        Update the parameters of a user, including `tags`.
+        :param user_id: ID of the user to update.
+        :param tags: New tags for the user (maximum of 10 tags).
+        :return: :class:`User <User>`
+
+        Usage:
+        ::
+
+            result = await api.update_user(
+                user_id="example",
+            )
+        """
+
+        param_user_id = validate_path_param("user_id", user_id)
+
+        res = self._request(
+            "PATCH",
+            f"/iam/v1alpha1/users/{param_user_id}",
+            body=marshal_UpdateUserRequest(
+                UpdateUserRequest(
+                    user_id=user_id,
+                    tags=tags,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_User(res.json())
+
     async def delete_user(
         self,
         *,
         user_id: str,
     ) -> None:
         """
         Delete a guest user from an Organization.
@@ -1034,15 +1078,17 @@
         application_id: Optional[str] = None,
     ) -> Group:
         """
         Add a user or an application to a group.
         Add a user or an application to a group. You can specify a `user_id` and and `application_id` in the body of your request. Note that you can only add one of each per request.
         :param group_id: ID of the group.
         :param user_id: ID of the user to add.
+        One-Of ('member'): at most one of 'user_id', 'application_id' could be set.
         :param application_id: ID of the application to add.
+        One-Of ('member'): at most one of 'user_id', 'application_id' could be set.
         :return: :class:`Group <Group>`
 
         Usage:
         ::
 
             result = await api.add_group_member(
                 group_id="example",
@@ -1116,15 +1162,17 @@
         application_id: Optional[str] = None,
     ) -> Group:
         """
         Remove a user or an application from a group.
         Remove a user or an application from a group. You can specify a `user_id` and and `application_id` in the body of your request. Note that you can only remove one of each per request. Removing a user from a group means that any permissions given to them via the group (i.e. from an attached policy) will no longer apply. Be sure you want to remove these permissions from the user before proceeding.
         :param group_id: ID of the group.
         :param user_id: ID of the user to remove.
+        One-Of ('member'): at most one of 'user_id', 'application_id' could be set.
         :param application_id: ID of the application to remove.
+        One-Of ('member'): at most one of 'user_id', 'application_id' could be set.
         :return: :class:`Group <Group>`
 
         Usage:
         ::
 
             result = await api.remove_group_member(
                 group_id="example",
@@ -1186,14 +1234,15 @@
         editable: Optional[bool] = None,
         user_ids: Optional[List[str]] = None,
         group_ids: Optional[List[str]] = None,
         application_ids: Optional[List[str]] = None,
         no_principal: Optional[bool] = None,
         policy_name: Optional[str] = None,
         tag: Optional[str] = None,
+        policy_ids: Optional[List[str]] = None,
     ) -> ListPoliciesResponse:
         """
         List policies of an Organization.
         List the policies of an Organization. By default, the policies listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request. You can also define additional parameters to filter your query, such as `user_ids`, `groups_ids`, `application_ids`, and `policy_name`.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param page: Page number. Value must be greater than 1.
@@ -1201,14 +1250,15 @@
         :param editable: Defines whether or not filter out editable policies.
         :param user_ids: Defines whether or not to filter by list of user IDs.
         :param group_ids: Defines whether or not to filter by list of group IDs.
         :param application_ids: Filter by a list of application IDs.
         :param no_principal: Defines whether or not the policy is attributed to a principal.
         :param policy_name: Name of the policy to fetch.
         :param tag: Filter by tags containing a given string.
+        :param policy_ids: Filter by a list of IDs.
         :return: :class:`ListPoliciesResponse <ListPoliciesResponse>`
 
         Usage:
         ::
 
             result = await api.list_policies()
         """
@@ -1222,14 +1272,15 @@
                 "group_ids": group_ids,
                 "no_principal": no_principal,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
+                "policy_ids": policy_ids,
                 "policy_name": policy_name,
                 "tag": tag,
                 "user_ids": user_ids,
             },
         )
 
         self._throw_on_error(res)
@@ -1245,14 +1296,15 @@
         editable: Optional[bool] = None,
         user_ids: Optional[List[str]] = None,
         group_ids: Optional[List[str]] = None,
         application_ids: Optional[List[str]] = None,
         no_principal: Optional[bool] = None,
         policy_name: Optional[str] = None,
         tag: Optional[str] = None,
+        policy_ids: Optional[List[str]] = None,
     ) -> List[Policy]:
         """
         List policies of an Organization.
         List the policies of an Organization. By default, the policies listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request. You can also define additional parameters to filter your query, such as `user_ids`, `groups_ids`, `application_ids`, and `policy_name`.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param page: Page number. Value must be greater than 1.
@@ -1260,14 +1312,15 @@
         :param editable: Defines whether or not filter out editable policies.
         :param user_ids: Defines whether or not to filter by list of user IDs.
         :param group_ids: Defines whether or not to filter by list of group IDs.
         :param application_ids: Filter by a list of application IDs.
         :param no_principal: Defines whether or not the policy is attributed to a principal.
         :param policy_name: Name of the policy to fetch.
         :param tag: Filter by tags containing a given string.
+        :param policy_ids: Filter by a list of IDs.
         :return: :class:`List[Policy] <List[Policy]>`
 
         Usage:
         ::
 
             result = await api.list_policies_all()
         """
@@ -1284,14 +1337,15 @@
                 "editable": editable,
                 "user_ids": user_ids,
                 "group_ids": group_ids,
                 "application_ids": application_ids,
                 "no_principal": no_principal,
                 "policy_name": policy_name,
                 "tag": tag,
+                "policy_ids": policy_ids,
             },
         )
 
     async def create_policy(
         self,
         *,
         description: str,
@@ -1309,17 +1363,21 @@
         Create a new application. You must define the `name` parameter in the request. You can specify parameters such as `user_id`, `groups_id`, `application_id`, `no_principal`, `rules` and its child attributes.
         :param description: Description of the policy to create (max length is 200 characters).
         :param name: Name of the policy to create (max length is 64 characters).
         :param organization_id: ID of the Organization.
         :param rules: Rules of the policy to create.
         :param tags: Tags associated with the policy (maximum of 10 tags).
         :param user_id: ID of user attributed to the policy.
+        One-Of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :param group_id: ID of group attributed to the policy.
+        One-Of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :param application_id: ID of application attributed to the policy.
+        One-Of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :param no_principal: Defines whether or not a policy is attributed to a principal.
+        One-Of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :return: :class:`Policy <Policy>`
 
         Usage:
         ::
 
             result = await api.create_policy(
                 description="example",
@@ -1393,17 +1451,21 @@
         Update an existing policy.
         Update the parameters of a policy, including `name`, `description`, `user_id`, `group_id`, `application_id` and `no_principal`.
         :param policy_id: Id of policy to update.
         :param name: New name for the policy (max length is 64 characters).
         :param description: New description of policy (max length is 200 characters).
         :param tags: New tags for the policy (maximum of 10 tags).
         :param user_id: New ID of user attributed to the policy.
+        One-Of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :param group_id: New ID of group attributed to the policy.
+        One-Of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :param application_id: New ID of application attributed to the policy.
+        One-Of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :param no_principal: Defines whether or not the policy is attributed to a principal.
+        One-Of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :return: :class:`Policy <Policy>`
 
         Usage:
         ::
 
             result = await api.update_policy(
                 policy_id="example",
@@ -1681,43 +1743,48 @@
         user_id: Optional[str] = None,
         editable: Optional[bool] = None,
         expired: Optional[bool] = None,
         access_key: Optional[str] = None,
         description: Optional[str] = None,
         bearer_id: Optional[str] = None,
         bearer_type: Optional[BearerType] = None,
+        access_keys: Optional[List[str]] = None,
     ) -> ListAPIKeysResponse:
         """
         List API keys.
         List API keys. By default, the API keys listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You can define additional parameters for your query such as `editable`, `expired`, `access_key` and `bearer_id`.
         :param order_by: Criteria for sorting results.
         :param page: Page number. Value must be greater or equal to 1.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param organization_id: ID of Organization.
         :param application_id: ID of application that bears the API key.
+        One-Of ('bearer'): at most one of 'application_id', 'user_id' could be set.
         :param user_id: ID of user that bears the API key.
+        One-Of ('bearer'): at most one of 'application_id', 'user_id' could be set.
         :param editable: Defines whether to filter out editable API keys or not.
         :param expired: Defines whether to filter out expired API keys or not.
-        :param access_key: Filter by access key.
+        :param access_key: Filter by access key (deprecated in favor of `access_keys`).
         :param description: Filter by description.
         :param bearer_id: Filter by bearer ID.
         :param bearer_type: Filter by type of bearer.
+        :param access_keys: Filter by a list of access keys.
         :return: :class:`ListAPIKeysResponse <ListAPIKeysResponse>`
 
         Usage:
         ::
 
             result = await api.list_api_keys()
         """
 
         res = self._request(
             "GET",
             "/iam/v1alpha1/api-keys",
             params={
                 "access_key": access_key,
+                "access_keys": access_keys,
                 "bearer_id": bearer_id,
                 "bearer_type": bearer_type,
                 "description": description,
                 "editable": editable,
                 "expired": expired,
                 "order_by": order_by,
                 "organization_id": organization_id
@@ -1747,30 +1814,34 @@
         user_id: Optional[str] = None,
         editable: Optional[bool] = None,
         expired: Optional[bool] = None,
         access_key: Optional[str] = None,
         description: Optional[str] = None,
         bearer_id: Optional[str] = None,
         bearer_type: Optional[BearerType] = None,
+        access_keys: Optional[List[str]] = None,
     ) -> List[APIKey]:
         """
         List API keys.
         List API keys. By default, the API keys listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You can define additional parameters for your query such as `editable`, `expired`, `access_key` and `bearer_id`.
         :param order_by: Criteria for sorting results.
         :param page: Page number. Value must be greater or equal to 1.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param organization_id: ID of Organization.
         :param application_id: ID of application that bears the API key.
+        One-Of ('bearer'): at most one of 'application_id', 'user_id' could be set.
         :param user_id: ID of user that bears the API key.
+        One-Of ('bearer'): at most one of 'application_id', 'user_id' could be set.
         :param editable: Defines whether to filter out editable API keys or not.
         :param expired: Defines whether to filter out expired API keys or not.
-        :param access_key: Filter by access key.
+        :param access_key: Filter by access key (deprecated in favor of `access_keys`).
         :param description: Filter by description.
         :param bearer_id: Filter by bearer ID.
         :param bearer_type: Filter by type of bearer.
+        :param access_keys: Filter by a list of access keys.
         :return: :class:`List[APIKey] <List[APIKey]>`
 
         Usage:
         ::
 
             result = await api.list_api_keys_all()
         """
@@ -1786,14 +1857,15 @@
                 "organization_id": organization_id,
                 "editable": editable,
                 "expired": expired,
                 "access_key": access_key,
                 "description": description,
                 "bearer_id": bearer_id,
                 "bearer_type": bearer_type,
+                "access_keys": access_keys,
                 "application_id": application_id,
                 "user_id": user_id,
             },
         )
 
     async def create_api_key(
         self,
@@ -1805,15 +1877,17 @@
         default_project_id: Optional[str] = None,
     ) -> APIKey:
         """
         Create an API key.
         Create an API key. You must specify the `application_id` or the `user_id` and the description. You can also specify the `default_project_id` which is the Project ID of your preferred Project, to use with Object Storage. The `access_key` and `secret_key` values are returned in the response. Note that he secret key is only showed once. Make sure that you copy and store both keys somewhere safe.
         :param description: Description of the API key (max length is 200 characters).
         :param application_id: ID of the application.
+        One-Of ('bearer'): at most one of 'application_id', 'user_id' could be set.
         :param user_id: ID of the user.
+        One-Of ('bearer'): at most one of 'application_id', 'user_id' could be set.
         :param expires_at: Expiration date of the API key.
         :param default_project_id: Default Project ID to use with Object Storage.
         :return: :class:`APIKey <APIKey>`
 
         Usage:
         ::
 
@@ -1940,22 +2014,24 @@
     async def list_quota(
         self,
         *,
         order_by: Optional[ListQuotaRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
+        quotum_names: Optional[List[str]] = None,
     ) -> ListQuotaResponse:
         """
         List all quotas in the Organization.
         List all product and features quota for an Organization, with their associated limits. By default, the quota listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param page: Page number. Value must be greater than 1.
         :param organization_id: Filter by Organization ID.
+        :param quotum_names: List of quotum names to filter from.
         :return: :class:`ListQuotaResponse <ListQuotaResponse>`
 
         Usage:
         ::
 
             result = await api.list_quota()
         """
@@ -1965,35 +2041,38 @@
             "/iam/v1alpha1/quota",
             params={
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
+                "quotum_names": quotum_names,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListQuotaResponse(res.json())
 
     async def list_quota_all(
         self,
         *,
         order_by: Optional[ListQuotaRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
+        quotum_names: Optional[List[str]] = None,
     ) -> List[Quotum]:
         """
         List all quotas in the Organization.
         List all product and features quota for an Organization, with their associated limits. By default, the quota listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param page: Page number. Value must be greater than 1.
         :param organization_id: Filter by Organization ID.
+        :param quotum_names: List of quotum names to filter from.
         :return: :class:`List[Quotum] <List[Quotum]>`
 
         Usage:
         ::
 
             result = await api.list_quota_all()
         """
@@ -2003,26 +2082,27 @@
             key="quota",
             fetcher=self.list_quota,
             args={
                 "order_by": order_by,
                 "page_size": page_size,
                 "page": page,
                 "organization_id": organization_id,
+                "quotum_names": quotum_names,
             },
         )
 
     async def get_quotum(
         self,
         *,
         quotum_name: str,
         organization_id: Optional[str] = None,
     ) -> Quotum:
         """
         Get a quota in the Organization.
-        Retrieve information about a resource quota, speficified by the `quotum_name` parameter. The quota's `limit`, or whether it is unlimited, is returned in the response.
+        Retrieve information about a resource quota, specified by the `quotum_name` parameter. The quota's `limit`, or whether it is unlimited, is returned in the response.
         :param quotum_name: Name of the quota to get.
         :param organization_id: ID of the Organization.
         :return: :class:`Quotum <Quotum>`
 
         Usage:
         ::
 
@@ -2052,15 +2132,14 @@
         audience_id: Optional[str] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         expired: Optional[bool] = None,
     ) -> ListJWTsResponse:
         """
         List JWTs.
-        List JWTs.
         :param order_by: Criteria for sorting results.
         :param audience_id: ID of the user to search.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param page: Page number. Value must be greater to 1.
         :param expired: Filter out expired JWTs or not.
         :return: :class:`ListJWTsResponse <ListJWTsResponse>`
 
@@ -2092,15 +2171,14 @@
         audience_id: Optional[str] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         expired: Optional[bool] = None,
     ) -> List[JWT]:
         """
         List JWTs.
-        List JWTs.
         :param order_by: Criteria for sorting results.
         :param audience_id: ID of the user to search.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param page: Page number. Value must be greater to 1.
         :param expired: Filter out expired JWTs or not.
         :return: :class:`List[JWT] <List[JWT]>`
 
@@ -2119,22 +2197,57 @@
                 "audience_id": audience_id,
                 "page_size": page_size,
                 "page": page,
                 "expired": expired,
             },
         )
 
+    async def create_jwt(
+        self,
+        *,
+        user_id: str,
+        referrer: str,
+    ) -> EncodedJWT:
+        """
+        Create a JWT.
+        :param user_id: ID of the user the JWT will be created for.
+        :param referrer: Referrer of the JWT.
+        :return: :class:`EncodedJWT <EncodedJWT>`
+
+        Usage:
+        ::
+
+            result = await api.create_jwt(
+                user_id="example",
+                referrer="example",
+            )
+        """
+
+        res = self._request(
+            "POST",
+            "/iam/v1alpha1/jwts",
+            body=marshal_CreateJWTRequest(
+                CreateJWTRequest(
+                    user_id=user_id,
+                    referrer=referrer,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_EncodedJWT(res.json())
+
     async def get_jwt(
         self,
         *,
         jti: str,
     ) -> JWT:
         """
         Get a JWT.
-        Get a JWT.
         :param jti: JWT ID of the JWT to get.
         :return: :class:`JWT <JWT>`
 
         Usage:
         ::
 
             result = await api.get_jwt(
@@ -2155,15 +2268,14 @@
     async def delete_jwt(
         self,
         *,
         jti: str,
     ) -> None:
         """
         Delete a JWT.
-        Delete a JWT.
         :param jti: JWT ID of the JWT to delete.
 
         Usage:
         ::
 
             result = await api.delete_jwt(
                 jti="example",
@@ -2189,14 +2301,16 @@
         created_after: Optional[datetime] = None,
         created_before: Optional[datetime] = None,
         action: Optional[LogAction] = None,
         resource_type: Optional[LogResourceType] = None,
         search: Optional[str] = None,
     ) -> ListLogsResponse:
         """
+        List logs.
+        List logs available for given Organization. You must define the `organization_id` in the query path of your request.
         :param order_by: Criteria for sorting results.
         :param organization_id: Filter by Organization ID.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param page: Page number. Value must be greater to 1.
         :param created_after: Defined whether or not to filter out logs created after this timestamp.
         :param created_before: Defined whether or not to filter out logs created before this timestamp.
         :param action: Defined whether or not to filter out by a specific action.
@@ -2240,14 +2354,16 @@
         created_after: Optional[datetime] = None,
         created_before: Optional[datetime] = None,
         action: Optional[LogAction] = None,
         resource_type: Optional[LogResourceType] = None,
         search: Optional[str] = None,
     ) -> List[Log]:
         """
+        List logs.
+        List logs available for given Organization. You must define the `organization_id` in the query path of your request.
         :param order_by: Criteria for sorting results.
         :param organization_id: Filter by Organization ID.
         :param page_size: Number of results per page. Value must be between 1 and 100.
         :param page: Page number. Value must be greater to 1.
         :param created_after: Defined whether or not to filter out logs created after this timestamp.
         :param created_before: Defined whether or not to filter out logs created before this timestamp.
         :param action: Defined whether or not to filter out by a specific action.
@@ -2280,14 +2396,16 @@
 
     async def get_log(
         self,
         *,
         log_id: str,
     ) -> Log:
         """
+        Get a log.
+        Retrieve information about a log, specified by the `log_id` parameter. The log's full details, including `id`, `ip`, `user_agent`, `action`, `bearer_id`, `resource_type` and `resource_id` are returned in the response.
         :param log_id: ID of the log.
         :return: :class:`Log <Log>`
 
         Usage:
         ::
 
             result = await api.get_log(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/iam/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/iam/v1alpha1/marshalling.py`

 * *Files 12% similar despite different names*

```diff
@@ -15,14 +15,15 @@
     Application,
     Group,
     Log,
     Policy,
     Quotum,
     SSHKey,
     User,
+    EncodedJWT,
     ListAPIKeysResponse,
     ListApplicationsResponse,
     ListGroupsResponse,
     ListJWTsResponse,
     ListLogsResponse,
     PermissionSet,
     ListPermissionSetsResponse,
@@ -34,26 +35,28 @@
     ListUsersResponse,
     SetRulesResponse,
     AddGroupMemberRequest,
     AddGroupMembersRequest,
     CreateAPIKeyRequest,
     CreateApplicationRequest,
     CreateGroupRequest,
+    CreateJWTRequest,
     RuleSpecs,
     CreatePolicyRequest,
     CreateSSHKeyRequest,
     CreateUserRequest,
     RemoveGroupMemberRequest,
     SetGroupMembersRequest,
     SetRulesRequest,
     UpdateAPIKeyRequest,
     UpdateApplicationRequest,
     UpdateGroupRequest,
     UpdatePolicyRequest,
     UpdateSSHKeyRequest,
+    UpdateUserRequest,
 )
 
 
 def unmarshal_JWT(data: Any) -> JWT:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'JWT' failed as data isn't a dictionary."
@@ -80,22 +83,28 @@
     field = data.get("user_agent", None)
     if field is not None:
         args["user_agent"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     return JWT(**args)
 
 
 def unmarshal_APIKey(data: Any) -> APIKey:
     if not isinstance(data, dict):
         raise TypeError(
@@ -123,34 +132,46 @@
     field = data.get("creation_ip", None)
     if field is not None:
         args["creation_ip"] = field
 
     field = data.get("secret_key", None)
     if field is not None:
         args["secret_key"] = field
+    else:
+        args["secret_key"] = None
 
     field = data.get("application_id", None)
     if field is not None:
         args["application_id"] = field
+    else:
+        args["application_id"] = None
 
     field = data.get("user_id", None)
     if field is not None:
         args["user_id"] = field
+    else:
+        args["user_id"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     return APIKey(**args)
 
 
 def unmarshal_Application(data: Any) -> Application:
     if not isinstance(data, dict):
         raise TypeError(
@@ -186,18 +207,22 @@
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Application(**args)
 
 
 def unmarshal_Group(data: Any) -> Group:
     if not isinstance(data, dict):
         raise TypeError(
@@ -233,18 +258,22 @@
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Group(**args)
 
 
 def unmarshal_Log(data: Any) -> Log:
     if not isinstance(data, dict):
         raise TypeError(
@@ -284,14 +313,16 @@
     field = data.get("resource_id", None)
     if field is not None:
         args["resource_id"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return Log(**args)
 
 
 def unmarshal_Policy(data: Any) -> Policy:
     if not isinstance(data, dict):
         raise TypeError(
@@ -315,18 +346,22 @@
     field = data.get("organization_id", None)
     if field is not None:
         args["organization_id"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("editable", None)
     if field is not None:
         args["editable"] = field
 
     field = data.get("nb_rules", None)
     if field is not None:
@@ -343,26 +378,34 @@
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("user_id", None)
     if field is not None:
         args["user_id"] = field
+    else:
+        args["user_id"] = None
 
     field = data.get("group_id", None)
     if field is not None:
         args["group_id"] = field
+    else:
+        args["group_id"] = None
 
     field = data.get("application_id", None)
     if field is not None:
         args["application_id"] = field
+    else:
+        args["application_id"] = None
 
     field = data.get("no_principal", None)
     if field is not None:
         args["no_principal"] = field
+    else:
+        args["no_principal"] = None
 
     return Policy(**args)
 
 
 def unmarshal_Quotum(data: Any) -> Quotum:
     if not isinstance(data, dict):
         raise TypeError(
@@ -371,21 +414,37 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
+    field = data.get("pretty_name", None)
+    if field is not None:
+        args["pretty_name"] = field
+
+    field = data.get("unit", None)
+    if field is not None:
+        args["unit"] = field
+
+    field = data.get("description", None)
+    if field is not None:
+        args["description"] = field
+
     field = data.get("limit", None)
     if field is not None:
         args["limit"] = field
+    else:
+        args["limit"] = None
 
     field = data.get("unlimited", None)
     if field is not None:
         args["unlimited"] = field
+    else:
+        args["unlimited"] = None
 
     return Quotum(**args)
 
 
 def unmarshal_SSHKey(data: Any) -> SSHKey:
     if not isinstance(data, dict):
         raise TypeError(
@@ -421,18 +480,22 @@
     field = data.get("disabled", None)
     if field is not None:
         args["disabled"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return SSHKey(**args)
 
 
 def unmarshal_User(data: Any) -> User:
     if not isinstance(data, dict):
         raise TypeError(
@@ -453,25 +516,27 @@
     if field is not None:
         args["organization_id"] = field
 
     field = data.get("deletable", None)
     if field is not None:
         args["deletable"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("mfa", None)
     if field is not None:
         args["mfa"] = field
 
     field = data.get("account_root_user_id", None)
     if field is not None:
@@ -480,28 +545,59 @@
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("last_login_at", None)
     if field is not None:
         args["last_login_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["last_login_at"] = None
 
     field = data.get("two_factor_enabled", None)
     if field is not None:
         args["two_factor_enabled"] = field
+    else:
+        args["two_factor_enabled"] = None
 
     return User(**args)
 
 
+def unmarshal_EncodedJWT(data: Any) -> EncodedJWT:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'EncodedJWT' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("token", None)
+    if field is not None:
+        args["token"] = field
+
+    field = data.get("renew_token", None)
+    if field is not None:
+        args["renew_token"] = field
+
+    field = data.get("jwt", None)
+    if field is not None:
+        args["jwt"] = unmarshal_JWT(field)
+    else:
+        args["jwt"] = None
+
+    return EncodedJWT(**args)
+
+
 def unmarshal_ListAPIKeysResponse(data: Any) -> ListAPIKeysResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ListAPIKeysResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -622,14 +718,16 @@
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
     field = data.get("categories", None)
     if field is not None:
         args["categories"] = field
+    else:
+        args["categories"] = None
 
     return PermissionSet(**args)
 
 
 def unmarshal_ListPermissionSetsResponse(data: Any) -> ListPermissionSetsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -708,26 +806,34 @@
     field = data.get("permission_sets_scope_type", None)
     if field is not None:
         args["permission_sets_scope_type"] = field
 
     field = data.get("permission_set_names", None)
     if field is not None:
         args["permission_set_names"] = field
+    else:
+        args["permission_set_names"] = None
 
     field = data.get("project_ids", None)
     if field is not None:
         args["project_ids"] = field
+    else:
+        args["project_ids"] = None
 
     field = data.get("organization_id", None)
     if field is not None:
         args["organization_id"] = field
+    else:
+        args["organization_id"] = None
 
     field = data.get("account_root_user_id", None)
     if field is not None:
         args["account_root_user_id"] = field
+    else:
+        args["account_root_user_id"] = None
 
     return Rule(**args)
 
 
 def unmarshal_ListRulesResponse(data: Any) -> ListRulesResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -908,14 +1014,29 @@
 
     if request.tags is not None:
         output["tags"] = request.tags
 
     return output
 
 
+def marshal_CreateJWTRequest(
+    request: CreateJWTRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.user_id is not None:
+        output["user_id"] = request.user_id
+
+    if request.referrer is not None:
+        output["referrer"] = request.referrer
+
+    return output
+
+
 def marshal_RuleSpecs(
     request: RuleSpecs,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
     output.update(
         resolve_one_of(
@@ -1145,7 +1266,19 @@
     if request.name is not None:
         output["name"] = request.name
 
     if request.disabled is not None:
         output["disabled"] = request.disabled
 
     return output
+
+
+def marshal_UpdateUserRequest(
+    request: UpdateUserRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/iam/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/iam/v1alpha1/types.py`

 * *Files 1% similar despite different names*

```diff
@@ -529,14 +529,29 @@
 @dataclass
 class Quotum:
     name: str
     """
     Name of the quota.
     """
 
+    pretty_name: str
+    """
+    A human-readable name for the quota.
+    """
+
+    unit: str
+    """
+    The unit in which the quota is expressed.
+    """
+
+    description: str
+    """
+    Details about the quota.
+    """
+
     limit: Optional[int]
 
     unlimited: Optional[bool]
 
 
 @dataclass
 class Rule:
@@ -778,14 +793,27 @@
     tags: Optional[List[str]]
     """
     Tags associated with the group (maximum of 10 tags).
     """
 
 
 @dataclass
+class CreateJWTRequest:
+    user_id: str
+    """
+    ID of the user the JWT will be created for.
+    """
+
+    referrer: str
+    """
+    Referrer of the JWT.
+    """
+
+
+@dataclass
 class CreatePolicyRequest:
     description: str
     """
     Description of the policy to create (max length is 200 characters).
     """
 
     name: Optional[str]
@@ -903,14 +931,32 @@
     user_id: str
     """
     ID of the user to delete.
     """
 
 
 @dataclass
+class EncodedJWT:
+    token: str
+    """
+    The encoded token of the renewed JWT.
+    """
+
+    renew_token: str
+    """
+    The encoded renew token. This token is necessary to renew the JWT.
+    """
+
+    jwt: Optional[JWT]
+    """
+    The renewed JWT.
+    """
+
+
+@dataclass
 class GetAPIKeyRequest:
     access_key: str
     """
     Access key to search for.
     """
 
 
@@ -1013,15 +1059,15 @@
     expired: Optional[bool]
     """
     Defines whether to filter out expired API keys or not.
     """
 
     access_key: Optional[str]
     """
-    Filter by access key.
+    Filter by access key (deprecated in favor of `access_keys`).
     """
 
     description: Optional[str]
     """
     Filter by description.
     """
 
@@ -1031,14 +1077,19 @@
     """
 
     bearer_type: Optional[BearerType]
     """
     Filter by type of bearer.
     """
 
+    access_keys: Optional[List[str]]
+    """
+    Filter by a list of access keys.
+    """
+
     application_id: Optional[str]
 
     user_id: Optional[str]
 
 
 @dataclass
 class ListAPIKeysResponse:
@@ -1355,14 +1406,19 @@
     """
 
     tag: Optional[str]
     """
     Filter by tags containing a given string.
     """
 
+    policy_ids: Optional[List[str]]
+    """
+    Filter by a list of IDs.
+    """
+
 
 @dataclass
 class ListPoliciesResponse:
     policies: List[Policy]
     """
     List of policies.
     """
@@ -1391,14 +1447,19 @@
     """
 
     organization_id: Optional[str]
     """
     Filter by Organization ID.
     """
 
+    quotum_names: Optional[List[str]]
+    """
+    List of quotum names to filter from.
+    """
+
 
 @dataclass
 class ListQuotaResponse:
     quota: List[Quotum]
     """
     List of quota.
     """
@@ -1688,7 +1749,20 @@
     Name of the SSH key. Max length is 1000.
     """
 
     disabled: Optional[bool]
     """
     Enable or disable the SSH key.
     """
+
+
+@dataclass
+class UpdateUserRequest:
+    user_id: str
+    """
+    ID of the user to update.
+    """
+
+    tags: Optional[List[str]]
+    """
+    New tags for the user (maximum of 10 tags).
+    """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/instance/v1/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,36 +8,36 @@
 from .types import IpState
 from .content import IP_TRANSIENT_STATUSES
 from .types import IpType
 from .types import ListServersRequestOrder
 from .types import PlacementGroupPolicyMode
 from .types import PlacementGroupPolicyType
 from .types import PrivateNICState
-from .content import PRIVATENIC_TRANSIENT_STATUSES
+from .content import PRIVATE_NIC_TRANSIENT_STATUSES
 from .types import SecurityGroupPolicy
 from .types import SecurityGroupRuleAction
 from .types import SecurityGroupRuleDirection
 from .types import SecurityGroupRuleProtocol
 from .types import SecurityGroupState
-from .content import SECURITYGROUP_TRANSIENT_STATUSES
+from .content import SECURITY_GROUP_TRANSIENT_STATUSES
 from .types import ServerAction
 from .types import ServerIpIpFamily
 from .types import ServerIpProvisioningMode
 from .types import ServerIpState
-from .content import SERVERIP_TRANSIENT_STATUSES
+from .content import SERVER_IP_TRANSIENT_STATUSES
 from .types import ServerState
 from .content import SERVER_TRANSIENT_STATUSES
 from .types import ServerTypesAvailability
 from .types import SnapshotState
 from .content import SNAPSHOT_TRANSIENT_STATUSES
 from .types import SnapshotVolumeType
 from .types import TaskStatus
 from .content import TASK_TRANSIENT_STATUSES
 from .types import VolumeServerState
-from .content import VOLUMESERVER_TRANSIENT_STATUSES
+from .content import VOLUME_SERVER_TRANSIENT_STATUSES
 from .types import VolumeServerVolumeType
 from .types import VolumeState
 from .content import VOLUME_TRANSIENT_STATUSES
 from .types import VolumeVolumeType
 from .types import ServerSummary
 from .types import Bootscript
 from .types import Volume
@@ -70,14 +70,15 @@
 from .types import Dashboard
 from .types import PlacementGroupServer
 from .types import GetServerTypesAvailabilityResponseAvailability
 from .types import ServerType
 from .types import VolumeType
 from .types import ServerActionRequestVolumeBackupTemplate
 from .types import SetSecurityGroupRulesRequestRule
+from .types import VolumeImageUpdateTemplate
 from .types import SecurityGroupTemplate
 from .types import ApplyBlockMigrationRequest
 from .types import AttachServerVolumeRequest
 from .types import AttachServerVolumeResponse
 from .types import CreateImageRequest
 from .types import CreateImageResponse
 from .types import CreateIpRequest
@@ -172,23 +173,31 @@
 from .types import SetImageRequest
 from .types import SetPlacementGroupRequest
 from .types import SetPlacementGroupResponse
 from .types import SetPlacementGroupServersRequest
 from .types import SetPlacementGroupServersResponse
 from .types import SetSecurityGroupRulesRequest
 from .types import SetSecurityGroupRulesResponse
+from .types import UpdateImageRequest
+from .types import UpdateImageResponse
 from .types import UpdateIpRequest
 from .types import UpdateIpResponse
 from .types import UpdatePlacementGroupRequest
 from .types import UpdatePlacementGroupResponse
 from .types import UpdatePlacementGroupServersRequest
 from .types import UpdatePlacementGroupServersResponse
 from .types import UpdatePrivateNICRequest
+from .types import UpdateSecurityGroupRequest
+from .types import UpdateSecurityGroupResponse
+from .types import UpdateSecurityGroupRuleRequest
+from .types import UpdateSecurityGroupRuleResponse
 from .types import UpdateServerRequest
 from .types import UpdateServerResponse
+from .types import UpdateSnapshotRequest
+from .types import UpdateSnapshotResponse
 from .types import UpdateVolumeRequest
 from .types import UpdateVolumeResponse
 from .api import InstanceV1API
 
 __all__ = [
     "Arch",
     "AttachServerVolumeRequestVolumeType",
@@ -198,36 +207,36 @@
     "IpState",
     "IP_TRANSIENT_STATUSES",
     "IpType",
     "ListServersRequestOrder",
     "PlacementGroupPolicyMode",
     "PlacementGroupPolicyType",
     "PrivateNICState",
-    "PRIVATENIC_TRANSIENT_STATUSES",
+    "PRIVATE_NIC_TRANSIENT_STATUSES",
     "SecurityGroupPolicy",
     "SecurityGroupRuleAction",
     "SecurityGroupRuleDirection",
     "SecurityGroupRuleProtocol",
     "SecurityGroupState",
-    "SECURITYGROUP_TRANSIENT_STATUSES",
+    "SECURITY_GROUP_TRANSIENT_STATUSES",
     "ServerAction",
     "ServerIpIpFamily",
     "ServerIpProvisioningMode",
     "ServerIpState",
-    "SERVERIP_TRANSIENT_STATUSES",
+    "SERVER_IP_TRANSIENT_STATUSES",
     "ServerState",
     "SERVER_TRANSIENT_STATUSES",
     "ServerTypesAvailability",
     "SnapshotState",
     "SNAPSHOT_TRANSIENT_STATUSES",
     "SnapshotVolumeType",
     "TaskStatus",
     "TASK_TRANSIENT_STATUSES",
     "VolumeServerState",
-    "VOLUMESERVER_TRANSIENT_STATUSES",
+    "VOLUME_SERVER_TRANSIENT_STATUSES",
     "VolumeServerVolumeType",
     "VolumeState",
     "VOLUME_TRANSIENT_STATUSES",
     "VolumeVolumeType",
     "ServerSummary",
     "Bootscript",
     "Volume",
@@ -260,14 +269,15 @@
     "Dashboard",
     "PlacementGroupServer",
     "GetServerTypesAvailabilityResponseAvailability",
     "ServerType",
     "VolumeType",
     "ServerActionRequestVolumeBackupTemplate",
     "SetSecurityGroupRulesRequestRule",
+    "VolumeImageUpdateTemplate",
     "SecurityGroupTemplate",
     "ApplyBlockMigrationRequest",
     "AttachServerVolumeRequest",
     "AttachServerVolumeResponse",
     "CreateImageRequest",
     "CreateImageResponse",
     "CreateIpRequest",
@@ -362,20 +372,28 @@
     "SetImageRequest",
     "SetPlacementGroupRequest",
     "SetPlacementGroupResponse",
     "SetPlacementGroupServersRequest",
     "SetPlacementGroupServersResponse",
     "SetSecurityGroupRulesRequest",
     "SetSecurityGroupRulesResponse",
+    "UpdateImageRequest",
+    "UpdateImageResponse",
     "UpdateIpRequest",
     "UpdateIpResponse",
     "UpdatePlacementGroupRequest",
     "UpdatePlacementGroupResponse",
     "UpdatePlacementGroupServersRequest",
     "UpdatePlacementGroupServersResponse",
     "UpdatePrivateNICRequest",
+    "UpdateSecurityGroupRequest",
+    "UpdateSecurityGroupResponse",
+    "UpdateSecurityGroupRuleRequest",
+    "UpdateSecurityGroupRuleResponse",
     "UpdateServerRequest",
     "UpdateServerResponse",
+    "UpdateSnapshotRequest",
+    "UpdateSnapshotResponse",
     "UpdateVolumeRequest",
     "UpdateVolumeResponse",
     "InstanceV1API",
 ]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/instance/v1/api.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,14 +9,25 @@
     Zone,
 )
 from scaleway_core.utils import (
     random_name,
     validate_path_param,
     fetch_all_pages_async,
 )
+from .types_private import (
+    _SetImageResponse,
+    _SetSecurityGroupRequest,
+    _SetSecurityGroupResponse,
+    _SetSecurityGroupRuleRequest,
+    _SetSecurityGroupRuleResponse,
+    _SetServerRequest,
+    _SetServerResponse,
+    _SetSnapshotRequest,
+    _SetSnapshotResponse,
+)
 from .types import (
     Arch,
     AttachServerVolumeRequestVolumeType,
     BootType,
     ImageState,
     IpType,
     ListServersRequestOrder,
@@ -109,38 +120,38 @@
     SetPlacementGroupServersRequest,
     SetPlacementGroupServersResponse,
     SetSecurityGroupRulesRequest,
     SetSecurityGroupRulesRequestRule,
     SetSecurityGroupRulesResponse,
     Snapshot,
     SnapshotBaseVolume,
+    UpdateImageRequest,
+    UpdateImageResponse,
     UpdateIpRequest,
     UpdateIpResponse,
     UpdatePlacementGroupRequest,
     UpdatePlacementGroupResponse,
     UpdatePlacementGroupServersRequest,
     UpdatePlacementGroupServersResponse,
     UpdatePrivateNICRequest,
+    UpdateSecurityGroupRequest,
+    UpdateSecurityGroupResponse,
+    UpdateSecurityGroupRuleRequest,
+    UpdateSecurityGroupRuleResponse,
     UpdateServerRequest,
     UpdateServerResponse,
+    UpdateSnapshotRequest,
+    UpdateSnapshotResponse,
     UpdateVolumeRequest,
     UpdateVolumeResponse,
     Volume,
+    VolumeImageUpdateTemplate,
     VolumeServerTemplate,
     VolumeSummary,
     VolumeTemplate,
-    _SetImageResponse,
-    _SetSecurityGroupRequest,
-    _SetSecurityGroupResponse,
-    _SetSecurityGroupRuleRequest,
-    _SetSecurityGroupRuleResponse,
-    _SetServerRequest,
-    _SetServerResponse,
-    _SetSnapshotRequest,
-    _SetSnapshotResponse,
 )
 from .marshalling import (
     unmarshal_PrivateNIC,
     unmarshal_AttachServerVolumeResponse,
     unmarshal_CreateImageResponse,
     unmarshal_CreateIpResponse,
     unmarshal_CreatePlacementGroupResponse,
@@ -180,18 +191,22 @@
     unmarshal_ListVolumesResponse,
     unmarshal_ListVolumesTypesResponse,
     unmarshal_MigrationPlan,
     unmarshal_ServerActionResponse,
     unmarshal_SetPlacementGroupResponse,
     unmarshal_SetPlacementGroupServersResponse,
     unmarshal_SetSecurityGroupRulesResponse,
+    unmarshal_UpdateImageResponse,
     unmarshal_UpdateIpResponse,
     unmarshal_UpdatePlacementGroupResponse,
     unmarshal_UpdatePlacementGroupServersResponse,
+    unmarshal_UpdateSecurityGroupResponse,
+    unmarshal_UpdateSecurityGroupRuleResponse,
     unmarshal_UpdateServerResponse,
+    unmarshal_UpdateSnapshotResponse,
     unmarshal_UpdateVolumeResponse,
     unmarshal__SetImageResponse,
     unmarshal__SetSecurityGroupResponse,
     unmarshal__SetSecurityGroupRuleResponse,
     unmarshal__SetServerResponse,
     unmarshal__SetSnapshotResponse,
     marshal_ApplyBlockMigrationRequest,
@@ -209,19 +224,23 @@
     marshal_ExportSnapshotRequest,
     marshal_PlanBlockMigrationRequest,
     marshal_ServerActionRequest,
     marshal_SetImageRequest,
     marshal_SetPlacementGroupRequest,
     marshal_SetPlacementGroupServersRequest,
     marshal_SetSecurityGroupRulesRequest,
+    marshal_UpdateImageRequest,
     marshal_UpdateIpRequest,
     marshal_UpdatePlacementGroupRequest,
     marshal_UpdatePlacementGroupServersRequest,
     marshal_UpdatePrivateNICRequest,
+    marshal_UpdateSecurityGroupRequest,
+    marshal_UpdateSecurityGroupRuleRequest,
     marshal_UpdateServerRequest,
+    marshal_UpdateSnapshotRequest,
     marshal_UpdateVolumeRequest,
     marshal__SetSecurityGroupRequest,
     marshal__SetSecurityGroupRuleRequest,
     marshal__SetServerRequest,
     marshal__SetSnapshotRequest,
 )
 
@@ -343,14 +362,15 @@
         per_page: Optional[int] = None,
         page: Optional[int] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         name: Optional[str] = None,
         private_ip: Optional[str] = None,
         without_ip: Optional[bool] = None,
+        with_ip: Optional[str] = None,
         commercial_type: Optional[str] = None,
         state: Optional[ServerState] = None,
         tags: Optional[List[str]] = None,
         private_network: Optional[str] = None,
         order: Optional[ListServersRequestOrder] = None,
         private_networks: Optional[List[str]] = None,
         private_nic_mac_address: Optional[str] = None,
@@ -363,14 +383,15 @@
         :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
         :param page: A positive integer to choose the page to return.
         :param organization: List only Instances of this Organization ID.
         :param project: List only Instances of this Project ID.
         :param name: Filter Instances by name (eg. "server1" will return "server100" and "server1" but not "foo").
         :param private_ip: List Instances by private_ip.
         :param without_ip: List Instances that are not attached to a public IP.
+        :param with_ip: List Instances by IP (both private_ip and public_ip are supported).
         :param commercial_type: List Instances of this commercial type.
         :param state: List Instances in this state.
         :param tags: List Instances with these exact tags (to filter with several tags, use commas to separate them).
         :param private_network: List Instances in this Private Network.
         :param order: Define the order of the returned servers.
         :param private_networks: List Instances from the given Private Networks (use commas to separate them).
         :param private_nic_mac_address: List Instances associated with the given private NIC MAC address.
@@ -401,14 +422,15 @@
                 if private_networks and len(private_networks) > 0
                 else None,
                 "private_nic_mac_address": private_nic_mac_address,
                 "project": project or self.client.default_project_id,
                 "servers": ",".join(servers) if servers and len(servers) > 0 else None,
                 "state": state,
                 "tags": ",".join(tags) if tags and len(tags) > 0 else None,
+                "with_ip": with_ip,
                 "without_ip": without_ip,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListServersResponse(res.json())
 
@@ -419,14 +441,15 @@
         per_page: Optional[int] = None,
         page: Optional[int] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         name: Optional[str] = None,
         private_ip: Optional[str] = None,
         without_ip: Optional[bool] = None,
+        with_ip: Optional[str] = None,
         commercial_type: Optional[str] = None,
         state: Optional[ServerState] = None,
         tags: Optional[List[str]] = None,
         private_network: Optional[str] = None,
         order: Optional[ListServersRequestOrder] = None,
         private_networks: Optional[List[str]] = None,
         private_nic_mac_address: Optional[str] = None,
@@ -439,14 +462,15 @@
         :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
         :param page: A positive integer to choose the page to return.
         :param organization: List only Instances of this Organization ID.
         :param project: List only Instances of this Project ID.
         :param name: Filter Instances by name (eg. "server1" will return "server100" and "server1" but not "foo").
         :param private_ip: List Instances by private_ip.
         :param without_ip: List Instances that are not attached to a public IP.
+        :param with_ip: List Instances by IP (both private_ip and public_ip are supported).
         :param commercial_type: List Instances of this commercial type.
         :param state: List Instances in this state.
         :param tags: List Instances with these exact tags (to filter with several tags, use commas to separate them).
         :param private_network: List Instances in this Private Network.
         :param order: Define the order of the returned servers.
         :param private_networks: List Instances from the given Private Networks (use commas to separate them).
         :param private_nic_mac_address: List Instances associated with the given private NIC MAC address.
@@ -468,14 +492,15 @@
                 "per_page": per_page,
                 "page": page,
                 "organization": organization,
                 "project": project,
                 "name": name,
                 "private_ip": private_ip,
                 "without_ip": without_ip,
+                "with_ip": with_ip,
                 "commercial_type": commercial_type,
                 "state": state,
                 "tags": tags,
                 "private_network": private_network,
                 "order": order,
                 "private_networks": private_networks,
                 "private_nic_mac_address": private_nic_mac_address,
@@ -484,20 +509,20 @@
         )
 
     async def _create_server(
         self,
         *,
         commercial_type: str,
         image: str,
-        enable_ipv6: bool,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         dynamic_ip_required: Optional[bool] = None,
         routed_ip_enabled: Optional[bool] = None,
         volumes: Optional[Dict[str, VolumeServerTemplate]] = None,
+        enable_ipv6: Optional[bool] = None,
         public_ip: Optional[str] = None,
         public_ips: Optional[List[str]] = None,
         boot_type: Optional[BootType] = None,
         bootscript: Optional[str] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
@@ -506,56 +531,57 @@
     ) -> CreateServerResponse:
         """
         Create an Instance.
         Create a new Instance of the specified commercial type in the specified zone. Pay attention to the volumes parameter, which takes an object which can be used in different ways to achieve different behaviors.
         Get more information in the [Technical Information](#technical-information) section of the introduction.
         :param commercial_type: Define the Instance commercial type (i.e. GP1-S).
         :param image: Instance image ID or label.
-        :param enable_ipv6: True if IPv6 is enabled on the server.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param name: Instance name.
         :param dynamic_ip_required: Define if a dynamic IPv4 is required for the Instance.
         :param routed_ip_enabled: If true, configure the Instance so it uses the new routed IP mode.
         :param volumes: Volumes attached to the server.
+        :param enable_ipv6: True if IPv6 is enabled on the server (deprecated and always `False` when `routed_ip_enabled` is `True`).
         :param public_ip: ID of the reserved IP to attach to the Instance.
         :param public_ips: A list of reserved IP IDs to attach to the Instance.
         :param boot_type: Boot type to use.
         :param bootscript: Bootscript ID to use when `boot_type` is set to `bootscript`.
         :param organization: Instance Organization ID.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param project: Instance Project ID.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param tags: Instance tags.
         :param security_group: Security group ID.
         :param placement_group: Placement group ID if Instance must be part of a placement group.
         :return: :class:`CreateServerResponse <CreateServerResponse>`
 
         Usage:
         ::
 
             result = await api._create_server(
                 commercial_type="example",
                 image="example",
-                enable_ipv6=False,
             )
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
 
         res = self._request(
             "POST",
             f"/instance/v1/zones/{param_zone}/servers",
             body=marshal_CreateServerRequest(
                 CreateServerRequest(
-                    zone=zone,
                     commercial_type=commercial_type,
                     image=image,
+                    zone=zone,
                     name=name or random_name(prefix="srv"),
                     dynamic_ip_required=dynamic_ip_required,
                     routed_ip_enabled=routed_ip_enabled,
-                    enable_ipv6=enable_ipv6,
                     volumes=volumes,
+                    enable_ipv6=enable_ipv6,
                     public_ip=public_ip,
                     public_ips=public_ips,
                     boot_type=boot_type,
                     bootscript=bootscript,
                     tags=tags,
                     security_group=security_group,
                     placement_group=placement_group,
@@ -635,22 +661,22 @@
         self,
         *,
         zone: Optional[Zone] = None,
         id: str,
         name: str,
         commercial_type: str,
         dynamic_ip_required: bool,
-        enable_ipv6: bool,
         hostname: str,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         allowed_actions: Optional[List[ServerAction]] = None,
         tags: Optional[List[str]] = None,
         creation_date: Optional[datetime] = None,
         routed_ip_enabled: Optional[bool] = None,
+        enable_ipv6: Optional[bool] = None,
         image: Optional[Image] = None,
         protected: bool,
         private_ip: Optional[str] = None,
         public_ip: Optional[ServerIp] = None,
         public_ips: Optional[List[ServerIp]] = None,
         modification_date: Optional[datetime] = None,
         state_detail: str,
@@ -668,32 +694,32 @@
     ) -> _SetServerResponse:
         """
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param id: Instance unique ID.
         :param name: Instance name.
         :param commercial_type: Instance commercial type (eg. GP1-M).
         :param dynamic_ip_required: True if a dynamic IPv4 is required.
-        :param enable_ipv6: True if IPv6 is enabled.
         :param hostname: Instance host name.
         :param organization: Instance Organization ID.
         :param project: Instance Project ID.
         :param allowed_actions: Provide a list of allowed actions on the server.
         :param tags: Tags associated with the Instance.
         :param creation_date: Instance creation date.
         :param routed_ip_enabled: True to configure the instance so it uses the new routed IP mode (once this is set to True you cannot set it back to False).
+        :param enable_ipv6: True if IPv6 is enabled (deprecated and always `False` when `routed_ip_enabled` is `True`).
         :param image: Provide information on the Instance image.
         :param protected: Instance protection option is activated.
-        :param private_ip: Instance private IP address.
-        :param public_ip: Information about the public IP.
+        :param private_ip: Instance private IP address (deprecated and always `null` when `routed_ip_enabled` is `True`).
+        :param public_ip: Information about the public IP (deprecated in favor of `public_ips`).
         :param public_ips: Information about all the public IPs attached to the server.
         :param modification_date: Instance modification date.
         :param state_detail: Instance state_detail.
         :param state: Instance state.
         :param location: Instance location.
-        :param ipv6: Instance IPv6 address.
+        :param ipv6: Instance IPv6 address (deprecated when `routed_ip_enabled` is `True`).
         :param bootscript: Instance bootscript.
         :param boot_type: Instance boot type.
         :param volumes: Instance volumes.
         :param security_group: Instance security group.
         :param maintenances: Instance planned maintenances.
         :param arch: Instance architecture (refers to the CPU architecture used for the Instance, e.g. x86_64, arm64).
         :param placement_group: Instance placement group.
@@ -704,15 +730,14 @@
         ::
 
             result = await api._set_server(
                 id="example",
                 name="example",
                 commercial_type="example",
                 dynamic_ip_required=False,
-                enable_ipv6=False,
                 hostname="example",
                 protected=False,
                 state_detail="example",
             )
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
@@ -724,22 +749,22 @@
             body=marshal__SetServerRequest(
                 _SetServerRequest(
                     zone=zone,
                     id=id,
                     name=name,
                     commercial_type=commercial_type,
                     dynamic_ip_required=dynamic_ip_required,
-                    enable_ipv6=enable_ipv6,
                     hostname=hostname,
                     organization=organization,
                     project=project,
                     allowed_actions=allowed_actions,
                     tags=tags,
                     creation_date=creation_date,
                     routed_ip_enabled=routed_ip_enabled,
+                    enable_ipv6=enable_ipv6,
                     image=image,
                     protected=protected,
                     private_ip=private_ip,
                     public_ip=public_ip,
                     public_ips=public_ips,
                     modification_date=modification_date,
                     state_detail=state_detail,
@@ -1012,21 +1037,19 @@
         server_id: str,
         volume_id: str,
         zone: Optional[Zone] = None,
         volume_type: Optional[AttachServerVolumeRequestVolumeType] = None,
         boot: Optional[bool] = None,
     ) -> AttachServerVolumeResponse:
         """
-        Attach a volume to a server.
-        Attach a volume to a server.
-        :param server_id: UUID of the Instance.
-        :param volume_id: UUID of the Volume to attach.
+        :param server_id:
+        :param volume_id:
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param volume_type: Type of the volume to attach.
-        :param boot: Force the Instance to boot on this volume.
+        :param volume_type:
+        :param boot:
         :return: :class:`AttachServerVolumeResponse <AttachServerVolumeResponse>`
 
         Usage:
         ::
 
             result = await api.attach_server_volume(
                 server_id="example",
@@ -1059,18 +1082,16 @@
         self,
         *,
         server_id: str,
         volume_id: str,
         zone: Optional[Zone] = None,
     ) -> DetachServerVolumeResponse:
         """
-        Detach a volume from a server.
-        Detach a volume from a server.
-        :param server_id: UUID of the Instance.
-        :param volume_id: UUID of the Volume to detach.
+        :param server_id:
+        :param volume_id:
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :return: :class:`DetachServerVolumeResponse <DetachServerVolumeResponse>`
 
         Usage:
         ::
 
             result = await api.detach_server_volume(
@@ -1253,25 +1274,27 @@
         :param root_volume: UUID of the snapshot.
         :param arch: Architecture of the image.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param name: Name of the image.
         :param default_bootscript: Default bootscript of the image.
         :param extra_volumes: Additional volumes of the image.
         :param organization: Organization ID of the image.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param project: Project ID of the image.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param tags: Tags of the image.
         :param public: True to create a public image.
         :return: :class:`CreateImageResponse <CreateImageResponse>`
 
         Usage:
         ::
 
             result = await api.create_image(
                 root_volume="example",
-                arch=Arch.x86_64,
+                arch=Arch.unknown_arch,
             )
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
 
         res = self._request(
             "POST",
@@ -1373,14 +1396,68 @@
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal__SetImageResponse(res.json())
 
+    async def update_image(
+        self,
+        *,
+        image_id: str,
+        zone: Optional[Zone] = None,
+        name: Optional[str] = None,
+        arch: Optional[Arch] = None,
+        extra_volumes: Optional[Dict[str, VolumeImageUpdateTemplate]] = None,
+        tags: Optional[List[str]] = None,
+        public: Optional[bool] = None,
+    ) -> UpdateImageResponse:
+        """
+        Update image.
+        Update the properties of an image.
+        :param image_id: UUID of the image.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Name of the image.
+        :param arch: Architecture of the image.
+        :param extra_volumes: Additional snapshots of the image, with extra_volumeKey being the position of the snapshot in the image.
+        :param tags: Tags of the image.
+        :param public: True to set the image as public.
+        :return: :class:`UpdateImageResponse <UpdateImageResponse>`
+
+        Usage:
+        ::
+
+            result = await api.update_image(
+                image_id="example",
+            )
+        """
+
+        param_zone = validate_path_param("zone", zone or self.client.default_zone)
+        param_image_id = validate_path_param("image_id", image_id)
+
+        res = self._request(
+            "PATCH",
+            f"/instance/v1/zones/{param_zone}/images/{param_image_id}",
+            body=marshal_UpdateImageRequest(
+                UpdateImageRequest(
+                    image_id=image_id,
+                    zone=zone,
+                    name=name,
+                    arch=arch,
+                    extra_volumes=extra_volumes,
+                    tags=tags,
+                    public=public,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_UpdateImageResponse(res.json())
+
     async def delete_image(
         self,
         *,
         image_id: str,
         zone: Optional[Zone] = None,
     ) -> None:
         """
@@ -1522,15 +1599,17 @@
         Create a snapshot from a specified volume or from a QCOW2 file.
         Create a snapshot from a specified volume or from a QCOW2 file in a specified Availability Zone.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param name: Name of the snapshot.
         :param volume_id: UUID of the volume.
         :param tags: Tags of the snapshot.
         :param organization: Organization ID of the snapshot.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param project: Project ID of the snapshot.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param volume_type: Overrides the volume_type of the snapshot.
         If omitted, the volume type of the original volume will be used.
         :param bucket: Bucket name for snapshot imports.
         :param key: Object key for snapshot imports.
         :param size: Imported snapshot size, must be a multiple of 512.
         :return: :class:`CreateSnapshotResponse <CreateSnapshotResponse>`
 
@@ -1611,16 +1690,16 @@
         creation_date: Optional[datetime] = None,
         modification_date: Optional[datetime] = None,
         project: Optional[str] = None,
         snapshot_id: str,
         tags: Optional[List[str]] = None,
     ) -> _SetSnapshotResponse:
         """
-        Update snapshot.
-        Replace all snapshot properties with a snapshot message.
+        Set snapshot.
+        Replace all the properties of a snapshot.
         :param id:
         :param name:
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param organization:
         :param volume_type:
         :param size:
         :param state:
@@ -1668,14 +1747,59 @@
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal__SetSnapshotResponse(res.json())
 
+    async def update_snapshot(
+        self,
+        *,
+        snapshot_id: str,
+        zone: Optional[Zone] = None,
+        name: Optional[str] = None,
+        tags: Optional[List[str]] = None,
+    ) -> UpdateSnapshotResponse:
+        """
+        Update a snapshot.
+        Update the properties of a snapshot.
+        :param snapshot_id: UUID of the snapshot.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Name of the snapshot.
+        :param tags: Tags of the snapshot.
+        :return: :class:`UpdateSnapshotResponse <UpdateSnapshotResponse>`
+
+        Usage:
+        ::
+
+            result = await api.update_snapshot(
+                snapshot_id="example",
+            )
+        """
+
+        param_zone = validate_path_param("zone", zone or self.client.default_zone)
+        param_snapshot_id = validate_path_param("snapshot_id", snapshot_id)
+
+        res = self._request(
+            "PATCH",
+            f"/instance/v1/zones/{param_zone}/snapshots/{param_snapshot_id}",
+            body=marshal_UpdateSnapshotRequest(
+                UpdateSnapshotRequest(
+                    snapshot_id=snapshot_id,
+                    zone=zone,
+                    name=name,
+                    tags=tags,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_UpdateSnapshotResponse(res.json())
+
     async def delete_snapshot(
         self,
         *,
         snapshot_id: str,
         zone: Optional[Zone] = None,
     ) -> None:
         """
@@ -1860,19 +1984,23 @@
     ) -> CreateVolumeResponse:
         """
         Create a volume.
         Create a volume of a specified type in an Availability Zone.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param name: Volume name.
         :param organization: Volume Organization ID.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param project: Volume Project ID.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param tags: Volume tags.
         :param volume_type: Volume type.
         :param size: Volume disk size, must be a multiple of 512.
+        One-Of ('from'): at most one of 'size', 'base_snapshot' could be set.
         :param base_snapshot: ID of the snapshot on which this volume will be based.
+        One-Of ('from'): at most one of 'size', 'base_snapshot' could be set.
         :return: :class:`CreateVolumeResponse <CreateVolumeResponse>`
 
         Usage:
         ::
 
             result = await api.create_volume()
         """
@@ -2127,18 +2255,22 @@
         Create a security group.
         Create a security group with a specified name and description.
         :param description: Description of the security group.
         :param stateful: Whether the security group is stateful or not.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param name: Name of the security group.
         :param organization: Organization ID the security group belongs to.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param project: Project ID the security group belong to.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param tags: Tags of the security group.
         :param organization_default: Defines whether this security group becomes the default security group for new Instances.
+        One-Of ('default_identifier'): at most one of 'organization_default', 'project_default' could be set.
         :param project_default: Whether this security group becomes the default security group for new Instances.
+        One-Of ('default_identifier'): at most one of 'organization_default', 'project_default' could be set.
         :param inbound_default_policy: Default policy for inbound rules.
         :param outbound_default_policy: Default policy for outbound rules.
         :param enable_default_security: True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
         :return: :class:`CreateSecurityGroupResponse <CreateSecurityGroupResponse>`
 
         Usage:
         ::
@@ -2262,15 +2394,15 @@
         organization_default: Optional[bool] = None,
         servers: Optional[List[ServerSummary]] = None,
     ) -> _SetSecurityGroupResponse:
         """
         Update a security group.
         Replace all security group properties with a security group message.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param id: ID of the security group (will be ignored).
+        :param id: UUID of the security group.
         :param name: Name of the security group.
         :param description: Description of the security group.
         :param enable_default_security: True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
         :param tags: Tags of the security group.
         :param creation_date: Creation date of the security group (will be ignored).
         :param modification_date: Modification date of the security group (will be ignored).
         :param project_default: True use this security group for future Instances created in this project.
@@ -2324,14 +2456,82 @@
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal__SetSecurityGroupResponse(res.json())
 
+    async def update_security_group(
+        self,
+        *,
+        security_group_id: str,
+        zone: Optional[Zone] = None,
+        name: Optional[str] = None,
+        description: Optional[str] = None,
+        enable_default_security: Optional[bool] = None,
+        inbound_default_policy: Optional[SecurityGroupPolicy] = None,
+        tags: Optional[List[str]] = None,
+        organization_default: Optional[bool] = None,
+        project_default: Optional[bool] = None,
+        outbound_default_policy: Optional[SecurityGroupPolicy] = None,
+        stateful: Optional[bool] = None,
+    ) -> UpdateSecurityGroupResponse:
+        """
+        Update a security group.
+        Update the properties of security group.
+        :param security_group_id: UUID of the security group.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Name of the security group.
+        :param description: Description of the security group.
+        :param enable_default_security: True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
+        :param inbound_default_policy: Default inbound policy.
+        :param tags: Tags of the security group.
+        :param organization_default: Please use project_default instead.
+        :param project_default: True use this security group for future Instances created in this project.
+        :param outbound_default_policy: Default outbound policy.
+        :param stateful: True to set the security group as stateful.
+        :return: :class:`UpdateSecurityGroupResponse <UpdateSecurityGroupResponse>`
+
+        Usage:
+        ::
+
+            result = await api.update_security_group(
+                security_group_id="example",
+            )
+        """
+
+        param_zone = validate_path_param("zone", zone or self.client.default_zone)
+        param_security_group_id = validate_path_param(
+            "security_group_id", security_group_id
+        )
+
+        res = self._request(
+            "PATCH",
+            f"/instance/v1/zones/{param_zone}/security_groups/{param_security_group_id}",
+            body=marshal_UpdateSecurityGroupRequest(
+                UpdateSecurityGroupRequest(
+                    security_group_id=security_group_id,
+                    zone=zone,
+                    name=name,
+                    description=description,
+                    enable_default_security=enable_default_security,
+                    inbound_default_policy=inbound_default_policy,
+                    tags=tags,
+                    organization_default=organization_default,
+                    project_default=project_default,
+                    outbound_default_policy=outbound_default_policy,
+                    stateful=stateful,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_UpdateSecurityGroupResponse(res.json())
+
     async def list_default_security_group_rules(
         self,
         *,
         zone: Optional[Zone] = None,
     ) -> ListSecurityGroupRulesResponse:
         """
         Get default rules.
@@ -2464,17 +2664,17 @@
         :return: :class:`CreateSecurityGroupRuleResponse <CreateSecurityGroupRuleResponse>`
 
         Usage:
         ::
 
             result = await api.create_security_group_rule(
                 security_group_id="example",
-                protocol=SecurityGroupRuleProtocol.tcp,
-                direction=SecurityGroupRuleDirection.inbound,
-                action=SecurityGroupRuleAction.accept,
+                protocol=SecurityGroupRuleProtocol.unknown_protocol,
+                direction=SecurityGroupRuleDirection.unknown_direction,
+                action=SecurityGroupRuleAction.unknown_action,
                 ip_range="example",
                 position=1,
                 editable=False,
             )
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
@@ -2640,16 +2840,16 @@
         protocol: Optional[SecurityGroupRuleProtocol] = None,
         direction: Optional[SecurityGroupRuleDirection] = None,
         action: Optional[SecurityGroupRuleAction] = None,
         dest_port_from: Optional[int] = None,
         dest_port_to: Optional[int] = None,
     ) -> _SetSecurityGroupRuleResponse:
         """
-        Update security group rule.
-        Update the rule of a specified security group ID.
+        Set security group rule.
+        Replace all the properties of a rule from a specified security group.
         :param security_group_id:
         :param security_group_rule_id:
         :param id:
         :param ip_range:
         :param position:
         :param editable:
         :param zone: Zone to target. If none is passed will use default zone from the config.
@@ -2702,14 +2902,83 @@
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal__SetSecurityGroupRuleResponse(res.json())
 
+    async def update_security_group_rule(
+        self,
+        *,
+        security_group_id: str,
+        security_group_rule_id: str,
+        zone: Optional[Zone] = None,
+        protocol: Optional[SecurityGroupRuleProtocol] = None,
+        direction: Optional[SecurityGroupRuleDirection] = None,
+        action: Optional[SecurityGroupRuleAction] = None,
+        ip_range: Optional[str] = None,
+        dest_port_from: Optional[int] = None,
+        dest_port_to: Optional[int] = None,
+        position: Optional[int] = None,
+    ) -> UpdateSecurityGroupRuleResponse:
+        """
+        Update security group rule.
+        Update the properties of a rule from a specified security group.
+        :param security_group_id: UUID of the security group.
+        :param security_group_rule_id: UUID of the rule.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param protocol: Protocol family this rule applies to.
+        :param direction: Direction the rule applies to.
+        :param action: Action to apply when the rule matches a packet.
+        :param ip_range: Range of IP addresses these rules apply to.
+        :param dest_port_from: Beginning of the range of ports this rule applies to (inclusive). If 0 is provided, unset the parameter.
+        :param dest_port_to: End of the range of ports this rule applies to (inclusive). If 0 is provided, unset the parameter.
+        :param position: Position of this rule in the security group rules list.
+        :return: :class:`UpdateSecurityGroupRuleResponse <UpdateSecurityGroupRuleResponse>`
+
+        Usage:
+        ::
+
+            result = await api.update_security_group_rule(
+                security_group_id="example",
+                security_group_rule_id="example",
+            )
+        """
+
+        param_zone = validate_path_param("zone", zone or self.client.default_zone)
+        param_security_group_id = validate_path_param(
+            "security_group_id", security_group_id
+        )
+        param_security_group_rule_id = validate_path_param(
+            "security_group_rule_id", security_group_rule_id
+        )
+
+        res = self._request(
+            "PATCH",
+            f"/instance/v1/zones/{param_zone}/security_groups/{param_security_group_id}/rules/{param_security_group_rule_id}",
+            body=marshal_UpdateSecurityGroupRuleRequest(
+                UpdateSecurityGroupRuleRequest(
+                    security_group_id=security_group_id,
+                    security_group_rule_id=security_group_rule_id,
+                    zone=zone,
+                    protocol=protocol,
+                    direction=direction,
+                    action=action,
+                    ip_range=ip_range,
+                    dest_port_from=dest_port_from,
+                    dest_port_to=dest_port_to,
+                    position=position,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_UpdateSecurityGroupRuleResponse(res.json())
+
     async def list_placement_groups(
         self,
         *,
         zone: Optional[Zone] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
         organization: Optional[str] = None,
@@ -2810,15 +3079,17 @@
     ) -> CreatePlacementGroupResponse:
         """
         Create a placement group.
         Create a new placement group in a specified Availability Zone.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param name: Name of the placement group.
         :param organization: Organization ID of the placement group.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param project: Project ID of the placement group.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param tags: Tags of the placement group.
         :param policy_mode: Operating mode of the placement group.
         :param policy_type: Policy type of the placement group.
         :return: :class:`CreatePlacementGroupResponse <CreatePlacementGroupResponse>`
 
         Usage:
         ::
@@ -2999,15 +3270,14 @@
         self,
         *,
         placement_group_id: str,
         zone: Optional[Zone] = None,
     ) -> None:
         """
         Delete the specified placement group.
-        Delete the specified placement group.
         :param placement_group_id: UUID of the placement group you want to delete.
         :param zone: Zone to target. If none is passed will use default zone from the config.
 
         Usage:
         ::
 
             result = await api.delete_placement_group(
@@ -3259,15 +3529,17 @@
         type_: Optional[IpType] = None,
     ) -> CreateIpResponse:
         """
         Reserve a flexible IP.
         Reserve a flexible IP and attach it to the specified Instance.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param organization: Organization ID in which the IP is reserved.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param project: Project ID in which the IP is reserved.
+        One-Of ('project_identifier'): at most one of 'project', 'organization' could be set.
         :param tags: Tags of the IP.
         :param server: UUID of the Instance you want to attach the IP to.
         :param type_: IP type to reserve (either 'nat', 'routed_ipv4' or 'routed_ipv6').
         :return: :class:`CreateIpResponse <CreateIpResponse>`
 
         Usage:
         ::
@@ -3499,15 +3771,14 @@
         private_network_id: str,
         zone: Optional[Zone] = None,
         tags: Optional[List[str]] = None,
         ip_ids: Optional[List[str]] = None,
     ) -> CreatePrivateNICResponse:
         """
         Create a private NIC connecting an Instance to a Private Network.
-        Create a private NIC connecting an Instance to a Private Network.
         :param server_id: UUID of the Instance the private NIC will be attached to.
         :param private_network_id: UUID of the private network where the private NIC will be attached.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param tags: Private NIC tags.
         :param ip_ids: Ip_ids defined from IPAM.
         :return: :class:`CreatePrivateNICResponse <CreatePrivateNICResponse>`
 
@@ -3629,15 +3900,14 @@
         *,
         server_id: str,
         private_nic_id: str,
         zone: Optional[Zone] = None,
     ) -> None:
         """
         Delete a private NIC.
-        Delete a private NIC.
         :param server_id: Instance to which the private NIC is attached.
         :param private_nic_id: Private NIC unique ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
 
         Usage:
         ::
 
@@ -3667,15 +3937,14 @@
         default: Optional[bool] = None,
         public: Optional[bool] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListBootscriptsResponse:
         """
         List bootscripts.
-        List bootscripts.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param arch:
         :param title:
         :param default:
         :param public:
         :param per_page:
         :param page:
@@ -3715,15 +3984,14 @@
         default: Optional[bool] = None,
         public: Optional[bool] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[Bootscript]:
         """
         List bootscripts.
-        List bootscripts.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param arch:
         :param title:
         :param default:
         :param public:
         :param per_page:
         :param page:
@@ -3825,15 +4093,17 @@
         snapshot_id: Optional[str] = None,
     ) -> MigrationPlan:
         """
         Get a volume or snapshot's migration plan.
         Given a volume or snapshot, returns the migration plan for a call to the RPC ApplyBlockMigration. This plan will include zero or one volume, and zero or more snapshots, which will need to be migrated together. This RPC does not perform the actual migration itself, ApplyBlockMigration must be used. The validation_key value returned by this call must be provided to the ApplyBlockMigration call to confirm that all resources listed in the plan should be migrated.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param volume_id: The volume for which the migration plan will be generated.
+        One-Of ('resource'): at most one of 'volume_id', 'snapshot_id' could be set.
         :param snapshot_id: The snapshot for which the migration plan will be generated.
+        One-Of ('resource'): at most one of 'volume_id', 'snapshot_id' could be set.
         :return: :class:`MigrationPlan <MigrationPlan>`
 
         Usage:
         ::
 
             result = await api.plan_block_migration()
         """
@@ -3866,15 +4136,17 @@
     ) -> None:
         """
         Migrate a volume and/or snapshots to SBS (Scaleway Block Storage).
         To be used, this RPC must be preceded by a call to PlanBlockMigration. To migrate all resources mentioned in the MigrationPlan, the validation_key returned in the MigrationPlan must be provided.
         :param validation_key: A value to be retrieved from a call to PlanBlockMigration, to confirm that the volume and/or snapshots specified in said plan should be migrated.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param volume_id: The volume to migrate, along with potentially other resources, according to the migration plan generated with a call to PlanBlockMigration.
+        One-Of ('resource'): at most one of 'volume_id', 'snapshot_id' could be set.
         :param snapshot_id: The snapshot to migrate, along with potentially other resources, according to the migration plan generated with a call to PlanBlockMigration.
+        One-Of ('resource'): at most one of 'volume_id', 'snapshot_id' could be set.
 
         Usage:
         ::
 
             result = await api.apply_block_migration(
                 validation_key="example",
             )
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/content.py` & `scaleway_async-2.1.0/scaleway_async/instance/v1/content.py`

 * *Files 2% similar despite different names*

```diff
@@ -23,27 +23,27 @@
 """
 IP_TRANSIENT_STATUSES: List[IpState] = [
     IpState.PENDING,
 ]
 """
 Lists transient statutes of the enum :class:`IpState <IpState>`.
 """
-PRIVATENIC_TRANSIENT_STATUSES: List[PrivateNICState] = [
+PRIVATE_NIC_TRANSIENT_STATUSES: List[PrivateNICState] = [
     PrivateNICState.SYNCING,
 ]
 """
 Lists transient statutes of the enum :class:`PrivateNICState <PrivateNICState>`.
 """
-SECURITYGROUP_TRANSIENT_STATUSES: List[SecurityGroupState] = [
+SECURITY_GROUP_TRANSIENT_STATUSES: List[SecurityGroupState] = [
     SecurityGroupState.SYNCING,
 ]
 """
 Lists transient statutes of the enum :class:`SecurityGroupState <SecurityGroupState>`.
 """
-SERVERIP_TRANSIENT_STATUSES: List[ServerIpState] = [
+SERVER_IP_TRANSIENT_STATUSES: List[ServerIpState] = [
     ServerIpState.PENDING,
 ]
 """
 Lists transient statutes of the enum :class:`ServerIpState <ServerIpState>`.
 """
 SERVER_TRANSIENT_STATUSES: List[ServerState] = [
     ServerState.STARTING,
@@ -64,15 +64,15 @@
     TaskStatus.PENDING,
     TaskStatus.STARTED,
     TaskStatus.RETRY,
 ]
 """
 Lists transient statutes of the enum :class:`TaskStatus <TaskStatus>`.
 """
-VOLUMESERVER_TRANSIENT_STATUSES: List[VolumeServerState] = [
+VOLUME_SERVER_TRANSIENT_STATUSES: List[VolumeServerState] = [
     VolumeServerState.SNAPSHOTTING,
     VolumeServerState.FETCHING,
     VolumeServerState.RESIZING,
     VolumeServerState.SAVING,
     VolumeServerState.HOTSYNCING,
 ]
 """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/instance/v1/marshalling.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,14 +5,25 @@
 from dateutil import parser
 
 from scaleway_core.profile import ProfileDefaults
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
+from .types_private import (
+    _SetImageResponse,
+    _SetSecurityGroupResponse,
+    _SetSecurityGroupRuleResponse,
+    _SetServerResponse,
+    _SetSnapshotResponse,
+    _SetSecurityGroupRequest,
+    _SetSecurityGroupRuleRequest,
+    _SetServerRequest,
+    _SetSnapshotRequest,
+)
 from .types import (
     BootType,
     ServerAction,
     PrivateNIC,
     ServerSummary,
     Bootscript,
     Volume,
@@ -84,24 +95,23 @@
     VolumeType,
     ListVolumesTypesResponse,
     MigrationPlan,
     ServerActionResponse,
     SetPlacementGroupResponse,
     SetPlacementGroupServersResponse,
     SetSecurityGroupRulesResponse,
+    UpdateImageResponse,
     UpdateIpResponse,
     UpdatePlacementGroupResponse,
     UpdatePlacementGroupServersResponse,
+    UpdateSecurityGroupResponse,
+    UpdateSecurityGroupRuleResponse,
     UpdateServerResponse,
+    UpdateSnapshotResponse,
     UpdateVolumeResponse,
-    _SetImageResponse,
-    _SetSecurityGroupResponse,
-    _SetSecurityGroupRuleResponse,
-    _SetServerResponse,
-    _SetSnapshotResponse,
     ApplyBlockMigrationRequest,
     AttachServerVolumeRequest,
     VolumeTemplate,
     CreateImageRequest,
     CreateIpRequest,
     CreatePlacementGroupRequest,
     CreatePrivateNICRequest,
@@ -117,25 +127,26 @@
     ServerActionRequestVolumeBackupTemplate,
     ServerActionRequest,
     SetImageRequest,
     SetPlacementGroupRequest,
     SetPlacementGroupServersRequest,
     SetSecurityGroupRulesRequestRule,
     SetSecurityGroupRulesRequest,
+    VolumeImageUpdateTemplate,
+    UpdateImageRequest,
     UpdateIpRequest,
     UpdatePlacementGroupRequest,
     UpdatePlacementGroupServersRequest,
     UpdatePrivateNICRequest,
+    UpdateSecurityGroupRequest,
+    UpdateSecurityGroupRuleRequest,
     SecurityGroupTemplate,
     UpdateServerRequest,
+    UpdateSnapshotRequest,
     UpdateVolumeRequest,
-    _SetSecurityGroupRequest,
-    _SetSecurityGroupRuleRequest,
-    _SetServerRequest,
-    _SetSnapshotRequest,
 )
 
 
 def unmarshal_PrivateNIC(data: Any) -> PrivateNIC:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'PrivateNIC' failed as data isn't a dictionary."
@@ -279,26 +290,32 @@
     field = data.get("project", None)
     if field is not None:
         args["project"] = field
 
     field = data.get("export_uri", None)
     if field is not None:
         args["export_uri"] = field
+    else:
+        args["export_uri"] = None
 
     field = data.get("creation_date", None)
     if field is not None:
         args["creation_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["creation_date"] = None
 
     field = data.get("modification_date", None)
     if field is not None:
         args["modification_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["modification_date"] = None
 
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("state", None)
     if field is not None:
@@ -307,14 +324,16 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("server", None)
     if field is not None:
         args["server"] = unmarshal_ServerSummary(field)
+    else:
+        args["server"] = None
 
     return Volume(**args)
 
 
 def unmarshal_VolumeSummary(data: Any) -> VolumeSummary:
     if not isinstance(data, dict):
         raise TypeError(
@@ -379,24 +398,30 @@
         args["organization"] = field
 
     field = data.get("creation_date", None)
     if field is not None:
         args["creation_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["creation_date"] = None
 
     field = data.get("modification_date", None)
     if field is not None:
         args["modification_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["modification_date"] = None
 
     field = data.get("default_bootscript", None)
     if field is not None:
         args["default_bootscript"] = unmarshal_Bootscript(field)
+    else:
+        args["default_bootscript"] = None
 
     field = data.get("public", None)
     if field is not None:
         args["public"] = field
 
     field = data.get("state", None)
     if field is not None:
@@ -413,14 +438,16 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("root_volume", None)
     if field is not None:
         args["root_volume"] = unmarshal_VolumeSummary(field)
+    else:
+        args["root_volume"] = None
 
     return Image(**args)
 
 
 def unmarshal_PlacementGroup(data: Any) -> PlacementGroup:
     if not isinstance(data, dict):
         raise TypeError(
@@ -523,14 +550,18 @@
     if field is not None:
         args["provisioning_mode"] = field
 
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
+    field = data.get("ipam_id", None)
+    if field is not None:
+        args["ipam_id"] = field
+
     field = data.get("state", None)
     if field is not None:
         args["state"] = field
 
     return ServerIp(**args)
 
 
@@ -596,14 +627,20 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("reason", None)
     if field is not None:
         args["reason"] = field
 
+    field = data.get("start_date", None)
+    if field is not None:
+        args["start_date"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["start_date"] = None
+
     return ServerMaintenance(**args)
 
 
 def unmarshal_VolumeServer(data: Any) -> VolumeServer:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'VolumeServer' failed as data isn't a dictionary."
@@ -630,14 +667,16 @@
     field = data.get("size", None)
     if field is not None:
         args["size"] = field
 
     field = data.get("server", None)
     if field is not None:
         args["server"] = unmarshal_ServerSummary(field)
+    else:
+        args["server"] = None
 
     field = data.get("volume_type", None)
     if field is not None:
         args["volume_type"] = field
 
     field = data.get("state", None)
     if field is not None:
@@ -656,20 +695,24 @@
         args["zone"] = field
 
     field = data.get("creation_date", None)
     if field is not None:
         args["creation_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["creation_date"] = None
 
     field = data.get("modification_date", None)
     if field is not None:
         args["modification_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["modification_date"] = None
 
     return VolumeServer(**args)
 
 
 def unmarshal_Server(data: Any) -> Server:
     if not isinstance(data, dict):
         raise TypeError(
@@ -709,46 +752,56 @@
         args["commercial_type"] = field
 
     field = data.get("creation_date", None)
     if field is not None:
         args["creation_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["creation_date"] = None
 
     field = data.get("dynamic_ip_required", None)
     if field is not None:
         args["dynamic_ip_required"] = field
 
     field = data.get("routed_ip_enabled", None)
     if field is not None:
         args["routed_ip_enabled"] = field
 
-    field = data.get("enable_ipv6", None)
-    if field is not None:
-        args["enable_ipv6"] = field
-
     field = data.get("hostname", None)
     if field is not None:
         args["hostname"] = field
 
     field = data.get("protected", None)
     if field is not None:
         args["protected"] = field
 
+    field = data.get("enable_ipv6", None)
+    if field is not None:
+        args["enable_ipv6"] = field
+    else:
+        args["enable_ipv6"] = None
+
     field = data.get("image", None)
     if field is not None:
         args["image"] = unmarshal_Image(field)
+    else:
+        args["image"] = None
 
     field = data.get("private_ip", None)
     if field is not None:
         args["private_ip"] = field
+    else:
+        args["private_ip"] = None
 
     field = data.get("public_ip", None)
     if field is not None:
         args["public_ip"] = unmarshal_ServerIp(field)
+    else:
+        args["public_ip"] = None
 
     field = data.get("public_ips", None)
     if field is not None:
         args["public_ips"] = (
             [unmarshal_ServerIp(v) for v in field] if field is not None else None
         )
 
@@ -773,30 +826,40 @@
         )
 
     field = data.get("modification_date", None)
     if field is not None:
         args["modification_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["modification_date"] = None
 
     field = data.get("location", None)
     if field is not None:
         args["location"] = unmarshal_ServerLocation(field)
+    else:
+        args["location"] = None
 
     field = data.get("ipv6", None)
     if field is not None:
         args["ipv6"] = unmarshal_ServerIpv6(field)
+    else:
+        args["ipv6"] = None
 
     field = data.get("bootscript", None)
     if field is not None:
         args["bootscript"] = unmarshal_Bootscript(field)
+    else:
+        args["bootscript"] = None
 
     field = data.get("security_group", None)
     if field is not None:
         args["security_group"] = unmarshal_SecurityGroupSummary(field)
+    else:
+        args["security_group"] = None
 
     field = data.get("maintenances", None)
     if field is not None:
         args["maintenances"] = (
             [unmarshal_ServerMaintenance(v) for v in field]
             if field is not None
             else None
@@ -819,14 +882,16 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("placement_group", None)
     if field is not None:
         args["placement_group"] = unmarshal_PlacementGroup(field)
+    else:
+        args["placement_group"] = None
 
     return Server(**args)
 
 
 def unmarshal_AttachServerVolumeResponse(data: Any) -> AttachServerVolumeResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -834,14 +899,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("server", None)
     if field is not None:
         args["server"] = unmarshal_Server(field)
+    else:
+        args["server"] = None
 
     return AttachServerVolumeResponse(**args)
 
 
 def unmarshal_CreateImageResponse(data: Any) -> CreateImageResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -849,14 +916,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("image", None)
     if field is not None:
         args["image"] = unmarshal_Image(field)
+    else:
+        args["image"] = None
 
     return CreateImageResponse(**args)
 
 
 def unmarshal_Ip(data: Any) -> Ip:
     if not isinstance(data, dict):
         raise TypeError(
@@ -881,37 +950,45 @@
     if field is not None:
         args["tags"] = field
 
     field = data.get("project", None)
     if field is not None:
         args["project"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("state", None)
     if field is not None:
         args["state"] = field
 
     field = data.get("prefix", None)
     if field is not None:
         args["prefix"] = field
 
+    field = data.get("ipam_id", None)
+    if field is not None:
+        args["ipam_id"] = field
+
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("reverse", None)
     if field is not None:
         args["reverse"] = field
+    else:
+        args["reverse"] = None
 
     field = data.get("server", None)
     if field is not None:
         args["server"] = unmarshal_ServerSummary(field)
+    else:
+        args["server"] = None
 
     return Ip(**args)
 
 
 def unmarshal_CreateIpResponse(data: Any) -> CreateIpResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -919,14 +996,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("ip", None)
     if field is not None:
         args["ip"] = unmarshal_Ip(field)
+    else:
+        args["ip"] = None
 
     return CreateIpResponse(**args)
 
 
 def unmarshal_CreatePlacementGroupResponse(data: Any) -> CreatePlacementGroupResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -934,14 +1013,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("placement_group", None)
     if field is not None:
         args["placement_group"] = unmarshal_PlacementGroup(field)
+    else:
+        args["placement_group"] = None
 
     return CreatePlacementGroupResponse(**args)
 
 
 def unmarshal_CreatePrivateNICResponse(data: Any) -> CreatePrivateNICResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -949,14 +1030,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("private_nic", None)
     if field is not None:
         args["private_nic"] = unmarshal_PrivateNIC(field)
+    else:
+        args["private_nic"] = None
 
     return CreatePrivateNICResponse(**args)
 
 
 def unmarshal_SecurityGroup(data: Any) -> SecurityGroup:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1022,26 +1105,32 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("organization_default", None)
     if field is not None:
         args["organization_default"] = field
+    else:
+        args["organization_default"] = None
 
     field = data.get("creation_date", None)
     if field is not None:
         args["creation_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["creation_date"] = None
 
     field = data.get("modification_date", None)
     if field is not None:
         args["modification_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["modification_date"] = None
 
     return SecurityGroup(**args)
 
 
 def unmarshal_CreateSecurityGroupResponse(data: Any) -> CreateSecurityGroupResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1049,14 +1138,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("security_group", None)
     if field is not None:
         args["security_group"] = unmarshal_SecurityGroup(field)
+    else:
+        args["security_group"] = None
 
     return CreateSecurityGroupResponse(**args)
 
 
 def unmarshal_SecurityGroupRule(data: Any) -> SecurityGroupRule:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1096,18 +1187,22 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("dest_port_from", None)
     if field is not None:
         args["dest_port_from"] = field
+    else:
+        args["dest_port_from"] = None
 
     field = data.get("dest_port_to", None)
     if field is not None:
         args["dest_port_to"] = field
+    else:
+        args["dest_port_to"] = None
 
     return SecurityGroupRule(**args)
 
 
 def unmarshal_CreateSecurityGroupRuleResponse(
     data: Any,
 ) -> CreateSecurityGroupRuleResponse:
@@ -1117,14 +1212,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("rule", None)
     if field is not None:
         args["rule"] = unmarshal_SecurityGroupRule(field)
+    else:
+        args["rule"] = None
 
     return CreateSecurityGroupRuleResponse(**args)
 
 
 def unmarshal_CreateServerResponse(data: Any) -> CreateServerResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1132,14 +1229,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("server", None)
     if field is not None:
         args["server"] = unmarshal_Server(field)
+    else:
+        args["server"] = None
 
     return CreateServerResponse(**args)
 
 
 def unmarshal_SnapshotBaseVolume(data: Any) -> SnapshotBaseVolume:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1202,30 +1301,38 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("base_volume", None)
     if field is not None:
         args["base_volume"] = unmarshal_SnapshotBaseVolume(field)
+    else:
+        args["base_volume"] = None
 
     field = data.get("creation_date", None)
     if field is not None:
         args["creation_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["creation_date"] = None
 
     field = data.get("modification_date", None)
     if field is not None:
         args["modification_date"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["modification_date"] = None
 
     field = data.get("error_reason", None)
     if field is not None:
         args["error_reason"] = field
+    else:
+        args["error_reason"] = None
 
     return Snapshot(**args)
 
 
 def unmarshal_Task(data: Any) -> Task:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1261,20 +1368,24 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("started_at", None)
     if field is not None:
         args["started_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["started_at"] = None
 
     field = data.get("terminated_at", None)
     if field is not None:
         args["terminated_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["terminated_at"] = None
 
     return Task(**args)
 
 
 def unmarshal_CreateSnapshotResponse(data: Any) -> CreateSnapshotResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1282,18 +1393,22 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("snapshot", None)
     if field is not None:
         args["snapshot"] = unmarshal_Snapshot(field)
+    else:
+        args["snapshot"] = None
 
     field = data.get("task", None)
     if field is not None:
         args["task"] = unmarshal_Task(field)
+    else:
+        args["task"] = None
 
     return CreateSnapshotResponse(**args)
 
 
 def unmarshal_CreateVolumeResponse(data: Any) -> CreateVolumeResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1301,14 +1416,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("volume", None)
     if field is not None:
         args["volume"] = unmarshal_Volume(field)
+    else:
+        args["volume"] = None
 
     return CreateVolumeResponse(**args)
 
 
 def unmarshal_DetachServerVolumeResponse(data: Any) -> DetachServerVolumeResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1316,14 +1433,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("server", None)
     if field is not None:
         args["server"] = unmarshal_Server(field)
+    else:
+        args["server"] = None
 
     return DetachServerVolumeResponse(**args)
 
 
 def unmarshal_ExportSnapshotResponse(data: Any) -> ExportSnapshotResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1331,14 +1450,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("task", None)
     if field is not None:
         args["task"] = unmarshal_Task(field)
+    else:
+        args["task"] = None
 
     return ExportSnapshotResponse(**args)
 
 
 def unmarshal_GetBootscriptResponse(data: Any) -> GetBootscriptResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1346,14 +1467,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("bootscript", None)
     if field is not None:
         args["bootscript"] = unmarshal_Bootscript(field)
+    else:
+        args["bootscript"] = None
 
     return GetBootscriptResponse(**args)
 
 
 def unmarshal_Dashboard(data: Any) -> Dashboard:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1432,14 +1555,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("dashboard", None)
     if field is not None:
         args["dashboard"] = unmarshal_Dashboard(field)
+    else:
+        args["dashboard"] = None
 
     return GetDashboardResponse(**args)
 
 
 def unmarshal_GetImageResponse(data: Any) -> GetImageResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1447,14 +1572,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("image", None)
     if field is not None:
         args["image"] = unmarshal_Image(field)
+    else:
+        args["image"] = None
 
     return GetImageResponse(**args)
 
 
 def unmarshal_GetIpResponse(data: Any) -> GetIpResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1462,14 +1589,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("ip", None)
     if field is not None:
         args["ip"] = unmarshal_Ip(field)
+    else:
+        args["ip"] = None
 
     return GetIpResponse(**args)
 
 
 def unmarshal_GetPlacementGroupResponse(data: Any) -> GetPlacementGroupResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1477,14 +1606,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("placement_group", None)
     if field is not None:
         args["placement_group"] = unmarshal_PlacementGroup(field)
+    else:
+        args["placement_group"] = None
 
     return GetPlacementGroupResponse(**args)
 
 
 def unmarshal_PlacementGroupServer(data: Any) -> PlacementGroupServer:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1536,14 +1667,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("private_nic", None)
     if field is not None:
         args["private_nic"] = unmarshal_PrivateNIC(field)
+    else:
+        args["private_nic"] = None
 
     return GetPrivateNICResponse(**args)
 
 
 def unmarshal_GetSecurityGroupResponse(data: Any) -> GetSecurityGroupResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1551,14 +1684,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("security_group", None)
     if field is not None:
         args["security_group"] = unmarshal_SecurityGroup(field)
+    else:
+        args["security_group"] = None
 
     return GetSecurityGroupResponse(**args)
 
 
 def unmarshal_GetSecurityGroupRuleResponse(data: Any) -> GetSecurityGroupRuleResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1566,14 +1701,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("rule", None)
     if field is not None:
         args["rule"] = unmarshal_SecurityGroupRule(field)
+    else:
+        args["rule"] = None
 
     return GetSecurityGroupRuleResponse(**args)
 
 
 def unmarshal_GetServerResponse(data: Any) -> GetServerResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1581,14 +1718,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("server", None)
     if field is not None:
         args["server"] = unmarshal_Server(field)
+    else:
+        args["server"] = None
 
     return GetServerResponse(**args)
 
 
 def unmarshal_GetServerTypesAvailabilityResponseAvailability(
     data: Any,
 ) -> GetServerTypesAvailabilityResponseAvailability:
@@ -1641,14 +1780,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("snapshot", None)
     if field is not None:
         args["snapshot"] = unmarshal_Snapshot(field)
+    else:
+        args["snapshot"] = None
 
     return GetSnapshotResponse(**args)
 
 
 def unmarshal_GetVolumeResponse(data: Any) -> GetVolumeResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1656,14 +1797,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("volume", None)
     if field is not None:
         args["volume"] = unmarshal_Volume(field)
+    else:
+        args["volume"] = None
 
     return GetVolumeResponse(**args)
 
 
 def unmarshal_ListBootscriptsResponse(data: Any) -> ListBootscriptsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1873,18 +2016,22 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("internal_bandwidth", None)
     if field is not None:
         args["internal_bandwidth"] = field
+    else:
+        args["internal_bandwidth"] = None
 
     field = data.get("internet_bandwidth", None)
     if field is not None:
         args["internet_bandwidth"] = field
+    else:
+        args["internet_bandwidth"] = None
 
     return ServerTypeNetworkInterface(**args)
 
 
 def unmarshal_ServerTypeVolumeConstraintSizes(
     data: Any,
 ) -> ServerTypeVolumeConstraintSizes:
@@ -1917,14 +2064,16 @@
     field = data.get("boot_types", None)
     if field is not None:
         args["boot_types"] = [BootType(v) for v in field] if field is not None else None
 
     field = data.get("block_storage", None)
     if field is not None:
         args["block_storage"] = field
+    else:
+        args["block_storage"] = None
 
     return ServerTypeCapabilities(**args)
 
 
 def unmarshal_ServerTypeNetwork(data: Any) -> ServerTypeNetwork:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1944,18 +2093,22 @@
     field = data.get("ipv6_support", None)
     if field is not None:
         args["ipv6_support"] = field
 
     field = data.get("sum_internal_bandwidth", None)
     if field is not None:
         args["sum_internal_bandwidth"] = field
+    else:
+        args["sum_internal_bandwidth"] = None
 
     field = data.get("sum_internet_bandwidth", None)
     if field is not None:
         args["sum_internet_bandwidth"] = field
+    else:
+        args["sum_internet_bandwidth"] = None
 
     return ServerTypeNetwork(**args)
 
 
 def unmarshal_ServerTypeVolumeConstraintsByType(
     data: Any,
 ) -> ServerTypeVolumeConstraintsByType:
@@ -1965,14 +2118,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("l_ssd", None)
     if field is not None:
         args["l_ssd"] = unmarshal_ServerTypeVolumeConstraintSizes(field)
+    else:
+        args["l_ssd"] = None
 
     return ServerTypeVolumeConstraintsByType(**args)
 
 
 def unmarshal_ServerType(data: Any) -> ServerType:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1980,14 +2135,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("monthly_price", None)
     if field is not None:
         args["monthly_price"] = field
+    else:
+        args["monthly_price"] = None
 
     field = data.get("hourly_price", None)
     if field is not None:
         args["hourly_price"] = field
 
     field = data.get("alt_names", None)
     if field is not None:
@@ -2010,34 +2167,46 @@
         args["baremetal"] = field
 
     field = data.get("per_volume_constraint", None)
     if field is not None:
         args["per_volume_constraint"] = unmarshal_ServerTypeVolumeConstraintsByType(
             field
         )
+    else:
+        args["per_volume_constraint"] = None
 
     field = data.get("volumes_constraint", None)
     if field is not None:
         args["volumes_constraint"] = unmarshal_ServerTypeVolumeConstraintSizes(field)
+    else:
+        args["volumes_constraint"] = None
 
     field = data.get("gpu", None)
     if field is not None:
         args["gpu"] = field
+    else:
+        args["gpu"] = None
 
     field = data.get("network", None)
     if field is not None:
         args["network"] = unmarshal_ServerTypeNetwork(field)
+    else:
+        args["network"] = None
 
     field = data.get("capabilities", None)
     if field is not None:
         args["capabilities"] = unmarshal_ServerTypeCapabilities(field)
+    else:
+        args["capabilities"] = None
 
     field = data.get("scratch_storage_max_size", None)
     if field is not None:
         args["scratch_storage_max_size"] = field
+    else:
+        args["scratch_storage_max_size"] = None
 
     return ServerType(**args)
 
 
 def unmarshal_ListServersTypesResponse(data: Any) -> ListServersTypesResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2148,18 +2317,22 @@
     field = data.get("display_name", None)
     if field is not None:
         args["display_name"] = field
 
     field = data.get("capabilities", None)
     if field is not None:
         args["capabilities"] = unmarshal_VolumeTypeCapabilities(field)
+    else:
+        args["capabilities"] = None
 
     field = data.get("constraints", None)
     if field is not None:
         args["constraints"] = unmarshal_VolumeTypeConstraints(field)
+    else:
+        args["constraints"] = None
 
     return VolumeType(**args)
 
 
 def unmarshal_ListVolumesTypesResponse(data: Any) -> ListVolumesTypesResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2200,14 +2373,16 @@
     field = data.get("validation_key", None)
     if field is not None:
         args["validation_key"] = field
 
     field = data.get("volume", None)
     if field is not None:
         args["volume"] = unmarshal_Volume(field)
+    else:
+        args["volume"] = None
 
     return MigrationPlan(**args)
 
 
 def unmarshal_ServerActionResponse(data: Any) -> ServerActionResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2215,14 +2390,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("task", None)
     if field is not None:
         args["task"] = unmarshal_Task(field)
+    else:
+        args["task"] = None
 
     return ServerActionResponse(**args)
 
 
 def unmarshal_SetPlacementGroupResponse(data: Any) -> SetPlacementGroupResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2230,14 +2407,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("placement_group", None)
     if field is not None:
         args["placement_group"] = unmarshal_PlacementGroup(field)
+    else:
+        args["placement_group"] = None
 
     return SetPlacementGroupResponse(**args)
 
 
 def unmarshal_SetPlacementGroupServersResponse(
     data: Any,
 ) -> SetPlacementGroupServersResponse:
@@ -2274,25 +2453,44 @@
             if field is not None
             else None
         )
 
     return SetSecurityGroupRulesResponse(**args)
 
 
+def unmarshal_UpdateImageResponse(data: Any) -> UpdateImageResponse:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'UpdateImageResponse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("image", None)
+    if field is not None:
+        args["image"] = unmarshal_Image(field)
+    else:
+        args["image"] = None
+
+    return UpdateImageResponse(**args)
+
+
 def unmarshal_UpdateIpResponse(data: Any) -> UpdateIpResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'UpdateIpResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("ip", None)
     if field is not None:
         args["ip"] = unmarshal_Ip(field)
+    else:
+        args["ip"] = None
 
     return UpdateIpResponse(**args)
 
 
 def unmarshal_UpdatePlacementGroupResponse(data: Any) -> UpdatePlacementGroupResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2300,14 +2498,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("placement_group", None)
     if field is not None:
         args["placement_group"] = unmarshal_PlacementGroup(field)
+    else:
+        args["placement_group"] = None
 
     return UpdatePlacementGroupResponse(**args)
 
 
 def unmarshal_UpdatePlacementGroupServersResponse(
     data: Any,
 ) -> UpdatePlacementGroupServersResponse:
@@ -2325,40 +2525,97 @@
             if field is not None
             else None
         )
 
     return UpdatePlacementGroupServersResponse(**args)
 
 
+def unmarshal_UpdateSecurityGroupResponse(data: Any) -> UpdateSecurityGroupResponse:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'UpdateSecurityGroupResponse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("security_group", None)
+    if field is not None:
+        args["security_group"] = unmarshal_SecurityGroup(field)
+    else:
+        args["security_group"] = None
+
+    return UpdateSecurityGroupResponse(**args)
+
+
+def unmarshal_UpdateSecurityGroupRuleResponse(
+    data: Any,
+) -> UpdateSecurityGroupRuleResponse:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'UpdateSecurityGroupRuleResponse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("rule", None)
+    if field is not None:
+        args["rule"] = unmarshal_SecurityGroupRule(field)
+    else:
+        args["rule"] = None
+
+    return UpdateSecurityGroupRuleResponse(**args)
+
+
 def unmarshal_UpdateServerResponse(data: Any) -> UpdateServerResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'UpdateServerResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("server", None)
     if field is not None:
         args["server"] = unmarshal_Server(field)
+    else:
+        args["server"] = None
 
     return UpdateServerResponse(**args)
 
 
+def unmarshal_UpdateSnapshotResponse(data: Any) -> UpdateSnapshotResponse:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'UpdateSnapshotResponse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("snapshot", None)
+    if field is not None:
+        args["snapshot"] = unmarshal_Snapshot(field)
+    else:
+        args["snapshot"] = None
+
+    return UpdateSnapshotResponse(**args)
+
+
 def unmarshal_UpdateVolumeResponse(data: Any) -> UpdateVolumeResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'UpdateVolumeResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("volume", None)
     if field is not None:
         args["volume"] = unmarshal_Volume(field)
+    else:
+        args["volume"] = None
 
     return UpdateVolumeResponse(**args)
 
 
 def unmarshal__SetImageResponse(data: Any) -> _SetImageResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2366,14 +2623,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("image", None)
     if field is not None:
         args["image"] = unmarshal_Image(field)
+    else:
+        args["image"] = None
 
     return _SetImageResponse(**args)
 
 
 def unmarshal__SetSecurityGroupResponse(data: Any) -> _SetSecurityGroupResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2381,14 +2640,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("security_group", None)
     if field is not None:
         args["security_group"] = unmarshal_SecurityGroup(field)
+    else:
+        args["security_group"] = None
 
     return _SetSecurityGroupResponse(**args)
 
 
 def unmarshal__SetSecurityGroupRuleResponse(data: Any) -> _SetSecurityGroupRuleResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2396,14 +2657,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("rule", None)
     if field is not None:
         args["rule"] = unmarshal_SecurityGroupRule(field)
+    else:
+        args["rule"] = None
 
     return _SetSecurityGroupRuleResponse(**args)
 
 
 def unmarshal__SetServerResponse(data: Any) -> _SetServerResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2411,14 +2674,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("server", None)
     if field is not None:
         args["server"] = unmarshal_Server(field)
+    else:
+        args["server"] = None
 
     return _SetServerResponse(**args)
 
 
 def unmarshal__SetSnapshotResponse(data: Any) -> _SetSnapshotResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -2426,14 +2691,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("snapshot", None)
     if field is not None:
         args["snapshot"] = unmarshal_Snapshot(field)
+    else:
+        args["snapshot"] = None
 
     return _SetSnapshotResponse(**args)
 
 
 def marshal_ApplyBlockMigrationRequest(
     request: ApplyBlockMigrationRequest,
     defaults: ProfileDefaults,
@@ -2788,23 +3055,23 @@
 
     if request.dynamic_ip_required is not None:
         output["dynamic_ip_required"] = request.dynamic_ip_required
 
     if request.routed_ip_enabled is not None:
         output["routed_ip_enabled"] = request.routed_ip_enabled
 
-    if request.enable_ipv6 is not None:
-        output["enable_ipv6"] = request.enable_ipv6
-
     if request.volumes is not None:
         output["volumes"] = {
             key: marshal_VolumeServerTemplate(value, defaults)
             for key, value in request.volumes.items()
         }
 
+    if request.enable_ipv6 is not None:
+        output["enable_ipv6"] = request.enable_ipv6
+
     if request.public_ip is not None:
         output["public_ip"] = request.public_ip
 
     if request.public_ips is not None:
         output["public_ips"] = request.public_ips
 
     if request.boot_type is not None:
@@ -3265,14 +3532,53 @@
             marshal_SetSecurityGroupRulesRequestRule(item, defaults)
             for item in request.rules
         ]
 
     return output
 
 
+def marshal_VolumeImageUpdateTemplate(
+    request: VolumeImageUpdateTemplate,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.id is not None:
+        output["id"] = request.id
+
+    return output
+
+
+def marshal_UpdateImageRequest(
+    request: UpdateImageRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.arch is not None:
+        output["arch"] = str(request.arch)
+
+    if request.extra_volumes is not None:
+        output["extra_volumes"] = {
+            key: marshal_VolumeImageUpdateTemplate(value, defaults)
+            for key, value in request.extra_volumes.items()
+        }
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    if request.public is not None:
+        output["public"] = request.public
+
+    return output
+
+
 def marshal_UpdateIpRequest(
     request: UpdateIpRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.reverse is not None:
@@ -3331,14 +3637,80 @@
 
     if request.tags is not None:
         output["tags"] = request.tags
 
     return output
 
 
+def marshal_UpdateSecurityGroupRequest(
+    request: UpdateSecurityGroupRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.enable_default_security is not None:
+        output["enable_default_security"] = request.enable_default_security
+
+    if request.inbound_default_policy is not None:
+        output["inbound_default_policy"] = str(request.inbound_default_policy)
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    if request.organization_default is not None:
+        output["organization_default"] = request.organization_default
+
+    if request.project_default is not None:
+        output["project_default"] = request.project_default
+
+    if request.outbound_default_policy is not None:
+        output["outbound_default_policy"] = str(request.outbound_default_policy)
+
+    if request.stateful is not None:
+        output["stateful"] = request.stateful
+
+    return output
+
+
+def marshal_UpdateSecurityGroupRuleRequest(
+    request: UpdateSecurityGroupRuleRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.protocol is not None:
+        output["protocol"] = str(request.protocol)
+
+    if request.direction is not None:
+        output["direction"] = str(request.direction)
+
+    if request.action is not None:
+        output["action"] = str(request.action)
+
+    if request.ip_range is not None:
+        output["ip_range"] = request.ip_range
+
+    if request.dest_port_from is not None:
+        output["dest_port_from"] = request.dest_port_from
+
+    if request.dest_port_to is not None:
+        output["dest_port_to"] = request.dest_port_to
+
+    if request.position is not None:
+        output["position"] = request.position
+
+    return output
+
+
 def marshal_SecurityGroupTemplate(
     request: SecurityGroupTemplate,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.id is not None:
@@ -3402,14 +3774,29 @@
 
     if request.commercial_type is not None:
         output["commercial_type"] = request.commercial_type
 
     return output
 
 
+def marshal_UpdateSnapshotRequest(
+    request: UpdateSnapshotRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
+
+
 def marshal_UpdateVolumeRequest(
     request: UpdateVolumeRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.name is not None:
@@ -3682,14 +4069,17 @@
 
     if request.provisioning_mode is not None:
         output["provisioning_mode"] = str(request.provisioning_mode)
 
     if request.tags is not None:
         output["tags"] = request.tags
 
+    if request.ipam_id is not None:
+        output["ipam_id"] = request.ipam_id
+
     if request.state is not None:
         output["state"] = str(request.state)
 
     return output
 
 
 def marshal_ServerIpv6(
@@ -3739,14 +4129,17 @@
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.reason is not None:
         output["reason"] = request.reason
 
+    if request.start_date is not None:
+        output["start_date"] = request.start_date
+
     return output
 
 
 def marshal__SetServerRequest(
     request: _SetServerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
@@ -3757,17 +4150,14 @@
 
     if request.commercial_type is not None:
         output["commercial_type"] = request.commercial_type
 
     if request.dynamic_ip_required is not None:
         output["dynamic_ip_required"] = request.dynamic_ip_required
 
-    if request.enable_ipv6 is not None:
-        output["enable_ipv6"] = request.enable_ipv6
-
     if request.hostname is not None:
         output["hostname"] = request.hostname
 
     if request.organization is not None:
         output["organization"] = (
             request.organization or defaults.default_organization_id
         )
@@ -3783,14 +4173,17 @@
 
     if request.creation_date is not None:
         output["creation_date"] = request.creation_date
 
     if request.routed_ip_enabled is not None:
         output["routed_ip_enabled"] = request.routed_ip_enabled
 
+    if request.enable_ipv6 is not None:
+        output["enable_ipv6"] = request.enable_ipv6
+
     if request.image is not None:
         output["image"] = (marshal_Image(request.image, defaults),)
 
     if request.protected is not None:
         output["protected"] = request.protected
 
     if request.private_ip is not None:
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/instance/v1/types.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,14 +12,15 @@
 )
 from scaleway_core.utils import (
     StrEnumMeta,
 )
 
 
 class Arch(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_ARCH = "unknown_arch"
     X86_64 = "x86_64"
     ARM = "arm"
     ARM64 = "arm64"
 
     def __str__(self) -> str:
         return str(self.value)
 
@@ -105,38 +106,42 @@
     SYNCING_ERROR = "syncing_error"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class SecurityGroupPolicy(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_POLICY = "unknown_policy"
     ACCEPT = "accept"
     DROP = "drop"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class SecurityGroupRuleAction(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_ACTION = "unknown_action"
     ACCEPT = "accept"
     DROP = "drop"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class SecurityGroupRuleDirection(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_DIRECTION = "unknown_direction"
     INBOUND = "inbound"
     OUTBOUND = "outbound"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class SecurityGroupRuleProtocol(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_PROTOCOL = "unknown_protocol"
     TCP = "tcp"
     UDP = "udp"
     ICMP = "icmp"
     ANY = "any"
 
     def __str__(self) -> str:
         return str(self.value)
@@ -631,15 +636,23 @@
     """
 
     tags: List[str]
     """
     Tags associated with the IP.
     """
 
+    ipam_id: str
+    """
+    The ip_id of an IPAM ip if the ip is created from IPAM, null if not.
+    """
+
     state: ServerIpState
+    """
+    IP address state.
+    """
 
 
 @dataclass
 class ServerIpv6:
     address: str
     """
     Instance IPv6 IP-Address.
@@ -669,14 +682,16 @@
     zone_id: str
 
 
 @dataclass
 class ServerMaintenance:
     reason: str
 
+    start_date: Optional[datetime]
+
 
 @dataclass
 class VolumeServer:
     id: str
 
     name: str
 
@@ -823,42 +838,42 @@
     """
 
     routed_ip_enabled: bool
     """
     True to configure the instance so it uses the new routed IP mode.
     """
 
-    enable_ipv6: bool
-    """
-    True if IPv6 is enabled.
-    """
-
     hostname: str
     """
     Instance host name.
     """
 
     protected: bool
     """
     Defines whether the Instance protection option is activated.
     """
 
+    enable_ipv6: Optional[bool]
+    """
+    True if IPv6 is enabled (deprecated and always `False` when `routed_ip_enabled` is `True`).
+    """
+
     image: Optional[Image]
     """
     Information about the Instance image.
     """
 
     private_ip: Optional[str]
     """
-    Private IP address of the Instance.
+    Private IP address of the Instance (deprecated and always `null` when `routed_ip_enabled` is `True`).
     """
 
     public_ip: Optional[ServerIp]
     """
-    Information about the public IP.
+    Information about the public IP (deprecated in favor of `public_ips`).
     """
 
     public_ips: List[ServerIp]
     """
     Information about all the public IPs attached to the server.
     """
 
@@ -890,15 +905,15 @@
     location: Optional[ServerLocation]
     """
     Instance location.
     """
 
     ipv6: Optional[ServerIpv6]
     """
-    Instance IPv6 address.
+    Instance IPv6 address (deprecated when `routed_ip_enabled` is `True`).
     """
 
     bootscript: Optional[Bootscript]
     """
     Instance bootscript.
     """
 
@@ -979,14 +994,16 @@
 
     type_: IpType
 
     state: IpState
 
     prefix: str
 
+    ipam_id: str
+
     zone: Zone
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     reverse: Optional[str]
 
@@ -1452,14 +1469,22 @@
     zone: Optional[Zone]
     """
     Zone of the rule. This field is ignored.
     """
 
 
 @dataclass
+class VolumeImageUpdateTemplate:
+    id: str
+    """
+    UUID of the snapshot.
+    """
+
+
+@dataclass
 class SecurityGroupTemplate:
     id: str
 
     name: str
 
 
 @dataclass
@@ -1478,37 +1503,25 @@
 
     snapshot_id: Optional[str]
 
 
 @dataclass
 class AttachServerVolumeRequest:
     server_id: str
-    """
-    UUID of the Instance.
-    """
 
     volume_id: str
-    """
-    UUID of the Volume to attach.
-    """
 
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     volume_type: Optional[AttachServerVolumeRequestVolumeType]
-    """
-    Type of the volume to attach.
-    """
 
     boot: Optional[bool]
-    """
-    Force the Instance to boot on this volume.
-    """
 
 
 @dataclass
 class AttachServerVolumeResponse:
     server: Optional[Server]
 
 
@@ -1766,29 +1779,29 @@
 @dataclass
 class CreateSecurityGroupRuleResponse:
     rule: Optional[SecurityGroupRule]
 
 
 @dataclass
 class CreateServerRequest:
-    zone: Optional[Zone]
-    """
-    Zone to target. If none is passed will use default zone from the config.
-    """
-
     commercial_type: str
     """
     Define the Instance commercial type (i.e. GP1-S).
     """
 
     image: str
     """
     Instance image ID or label.
     """
 
+    zone: Optional[Zone]
+    """
+    Zone to target. If none is passed will use default zone from the config.
+    """
+
     name: Optional[str]
     """
     Instance name.
     """
 
     dynamic_ip_required: Optional[bool]
     """
@@ -1796,22 +1809,22 @@
     """
 
     routed_ip_enabled: Optional[bool]
     """
     If true, configure the Instance so it uses the new routed IP mode.
     """
 
-    enable_ipv6: bool
+    volumes: Optional[Dict[str, VolumeServerTemplate]]
     """
-    True if IPv6 is enabled on the server.
+    Volumes attached to the server.
     """
 
-    volumes: Optional[Dict[str, VolumeServerTemplate]]
+    enable_ipv6: Optional[bool]
     """
-    Volumes attached to the server.
+    True if IPv6 is enabled on the server (deprecated and always `False` when `routed_ip_enabled` is `True`).
     """
 
     public_ip: Optional[str]
     """
     ID of the reserved IP to attach to the Instance.
     """
 
@@ -2081,22 +2094,16 @@
     Zone to target. If none is passed will use default zone from the config.
     """
 
 
 @dataclass
 class DetachServerVolumeRequest:
     server_id: str
-    """
-    UUID of the Instance.
-    """
 
     volume_id: str
-    """
-    UUID of the Volume to detach.
-    """
 
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
 
@@ -2763,14 +2770,19 @@
     """
 
     without_ip: Optional[bool]
     """
     List Instances that are not attached to a public IP.
     """
 
+    with_ip: Optional[str]
+    """
+    List Instances by IP (both private_ip and public_ip are supported).
+    """
+
     commercial_type: Optional[str]
     """
     List Instances of this commercial type.
     """
 
     state: Optional[ServerState]
     """
@@ -3157,14 +3169,57 @@
 
 @dataclass
 class SetSecurityGroupRulesResponse:
     rules: List[SecurityGroupRule]
 
 
 @dataclass
+class UpdateImageRequest:
+    image_id: str
+    """
+    UUID of the image.
+    """
+
+    zone: Optional[Zone]
+    """
+    Zone to target. If none is passed will use default zone from the config.
+    """
+
+    name: Optional[str]
+    """
+    Name of the image.
+    """
+
+    arch: Optional[Arch]
+    """
+    Architecture of the image.
+    """
+
+    extra_volumes: Optional[Dict[str, VolumeImageUpdateTemplate]]
+    """
+    Additional snapshots of the image, with extra_volumeKey being the position of the snapshot in the image.
+    """
+
+    tags: Optional[List[str]]
+    """
+    Tags of the image.
+    """
+
+    public: Optional[bool]
+    """
+    True to set the image as public.
+    """
+
+
+@dataclass
+class UpdateImageResponse:
+    image: Optional[Image]
+
+
+@dataclass
 class UpdateIpRequest:
     ip: str
     """
     IP ID or IP address.
     """
 
     zone: Optional[Zone]
@@ -3279,435 +3334,256 @@
     tags: Optional[List[str]]
     """
     Tags used to select private NIC/s.
     """
 
 
 @dataclass
-class UpdateServerRequest:
-    server_id: str
+class UpdateSecurityGroupRequest:
+    security_group_id: str
     """
-    UUID of the Instance.
+    UUID of the security group.
     """
 
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     name: Optional[str]
     """
-    Name of the Instance.
-    """
-
-    boot_type: Optional[BootType]
-
-    tags: Optional[List[str]]
-    """
-    Tags of the Instance.
-    """
-
-    volumes: Optional[Dict[str, VolumeServerTemplate]]
-
-    bootscript: Optional[str]
-
-    dynamic_ip_required: Optional[bool]
-
-    routed_ip_enabled: Optional[bool]
-    """
-    True to configure the instance so it uses the new routed IP mode (once this is set to True you cannot set it back to False).
+    Name of the security group.
     """
 
-    public_ips: Optional[List[str]]
+    description: Optional[str]
     """
-    A list of reserved IP IDs to attach to the Instance.
-    """
-
-    enable_ipv6: Optional[bool]
-
-    protected: Optional[bool]
-
-    security_group: Optional[SecurityGroupTemplate]
-
-    placement_group: Optional[str]
-    """
-    Placement group ID if Instance must be part of a placement group.
+    Description of the security group.
     """
 
-    private_nics: Optional[List[str]]
+    enable_default_security: Optional[bool]
     """
-    Instance private NICs.
+    True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
     """
 
-    commercial_type: Optional[str]
+    inbound_default_policy: Optional[SecurityGroupPolicy]
     """
-    Warning: This field has some restrictions:
-- Cannot be changed if the Instance is not in `stopped` state.
-- Cannot be changed if the Instance is in a placement group.
-- Local storage requirements of the target commercial_types must be fulfilled (i.e. if an Instance has 80GB of local storage, it can be changed into a GP1-XS, which has a maximum of 150GB, but it cannot be changed into a DEV1-S, which has only 20GB).
+    Default inbound policy.
     """
 
-
-@dataclass
-class UpdateServerResponse:
-    server: Optional[Server]
-
-
-@dataclass
-class UpdateVolumeRequest:
-    volume_id: str
+    tags: Optional[List[str]]
     """
-    UUID of the volume.
+    Tags of the security group.
     """
 
-    zone: Optional[Zone]
+    organization_default: Optional[bool]
     """
-    Zone to target. If none is passed will use default zone from the config.
+    Please use project_default instead.
     """
 
-    name: Optional[str]
+    project_default: Optional[bool]
     """
-    Volume name.
+    True use this security group for future Instances created in this project.
     """
 
-    tags: Optional[List[str]]
+    outbound_default_policy: Optional[SecurityGroupPolicy]
     """
-    Tags of the volume.
+    Default outbound policy.
     """
 
-    size: Optional[int]
+    stateful: Optional[bool]
     """
-    Volume disk size, must be a multiple of 512.
+    True to set the security group as stateful.
     """
 
 
 @dataclass
-class UpdateVolumeResponse:
-    volume: Optional[Volume]
-
-
-@dataclass
-class _SetImageResponse:
-    image: Optional[Image]
+class UpdateSecurityGroupResponse:
+    security_group: Optional[SecurityGroup]
 
 
 @dataclass
-class _SetSecurityGroupRequest:
-    zone: Optional[Zone]
-    """
-    Zone to target. If none is passed will use default zone from the config.
-    """
-
-    id: str
-    """
-    ID of the security group (will be ignored).
-    """
-
-    name: str
-    """
-    Name of the security group.
-    """
-
-    description: str
-    """
-    Description of the security group.
-    """
-
-    enable_default_security: bool
-    """
-    True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
-    """
-
-    tags: Optional[List[str]]
-    """
-    Tags of the security group.
-    """
-
-    creation_date: Optional[datetime]
+class UpdateSecurityGroupRuleRequest:
+    security_group_id: str
     """
-    Creation date of the security group (will be ignored).
+    UUID of the security group.
     """
 
-    modification_date: Optional[datetime]
+    security_group_rule_id: str
     """
-    Modification date of the security group (will be ignored).
+    UUID of the rule.
     """
 
-    project_default: bool
+    zone: Optional[Zone]
     """
-    True use this security group for future Instances created in this project.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    stateful: bool
+    protocol: Optional[SecurityGroupRuleProtocol]
     """
-    True to set the security group as stateful.
+    Protocol family this rule applies to.
     """
 
-    inbound_default_policy: Optional[SecurityGroupPolicy]
+    direction: Optional[SecurityGroupRuleDirection]
     """
-    Default inbound policy.
+    Direction the rule applies to.
     """
 
-    outbound_default_policy: Optional[SecurityGroupPolicy]
+    action: Optional[SecurityGroupRuleAction]
     """
-    Default outbound policy.
+    Action to apply when the rule matches a packet.
     """
 
-    organization: Optional[str]
+    ip_range: Optional[str]
     """
-    Security groups Organization ID.
+    Range of IP addresses these rules apply to.
     """
 
-    project: Optional[str]
+    dest_port_from: Optional[int]
     """
-    Security group Project ID.
+    Beginning of the range of ports this rule applies to (inclusive). If 0 is provided, unset the parameter.
     """
 
-    organization_default: Optional[bool]
+    dest_port_to: Optional[int]
     """
-    Please use project_default instead.
+    End of the range of ports this rule applies to (inclusive). If 0 is provided, unset the parameter.
     """
 
-    servers: Optional[List[ServerSummary]]
+    position: Optional[int]
     """
-    Instances attached to this security group.
+    Position of this rule in the security group rules list.
     """
 
 
 @dataclass
-class _SetSecurityGroupResponse:
-    security_group: Optional[SecurityGroup]
+class UpdateSecurityGroupRuleResponse:
+    rule: Optional[SecurityGroupRule]
 
 
 @dataclass
-class _SetSecurityGroupRuleRequest:
-    security_group_id: str
-
-    security_group_rule_id: str
-
-    id: str
-
-    ip_range: str
-
-    position: int
-
-    editable: bool
-
-    zone: Optional[Zone]
+class UpdateServerRequest:
+    server_id: str
     """
-    Zone to target. If none is passed will use default zone from the config.
+    UUID of the Instance.
     """
 
-    protocol: Optional[SecurityGroupRuleProtocol]
-
-    direction: Optional[SecurityGroupRuleDirection]
-
-    action: Optional[SecurityGroupRuleAction]
-
-    dest_port_from: Optional[int]
-
-    dest_port_to: Optional[int]
-
-
-@dataclass
-class _SetSecurityGroupRuleResponse:
-    rule: Optional[SecurityGroupRule]
-
-
-@dataclass
-class _SetServerRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
-    id: str
-    """
-    Instance unique ID.
-    """
-
-    name: str
-    """
-    Instance name.
-    """
-
-    commercial_type: str
+    name: Optional[str]
     """
-    Instance commercial type (eg. GP1-M).
+    Name of the Instance.
     """
 
-    dynamic_ip_required: bool
-    """
-    True if a dynamic IPv4 is required.
-    """
+    boot_type: Optional[BootType]
 
-    enable_ipv6: bool
+    tags: Optional[List[str]]
     """
-    True if IPv6 is enabled.
+    Tags of the Instance.
     """
 
-    hostname: str
-    """
-    Instance host name.
-    """
+    volumes: Optional[Dict[str, VolumeServerTemplate]]
 
-    organization: Optional[str]
-    """
-    Instance Organization ID.
-    """
+    bootscript: Optional[str]
 
-    project: Optional[str]
-    """
-    Instance Project ID.
-    """
+    dynamic_ip_required: Optional[bool]
 
-    allowed_actions: Optional[List[ServerAction]]
+    routed_ip_enabled: Optional[bool]
     """
-    Provide a list of allowed actions on the server.
+    True to configure the instance so it uses the new routed IP mode (once this is set to True you cannot set it back to False).
     """
 
-    tags: Optional[List[str]]
+    public_ips: Optional[List[str]]
     """
-    Tags associated with the Instance.
+    A list of reserved IP IDs to attach to the Instance.
     """
 
-    creation_date: Optional[datetime]
-    """
-    Instance creation date.
-    """
+    enable_ipv6: Optional[bool]
 
-    routed_ip_enabled: Optional[bool]
-    """
-    True to configure the instance so it uses the new routed IP mode (once this is set to True you cannot set it back to False).
-    """
+    protected: Optional[bool]
 
-    image: Optional[Image]
-    """
-    Provide information on the Instance image.
-    """
+    security_group: Optional[SecurityGroupTemplate]
 
-    protected: bool
+    placement_group: Optional[str]
     """
-    Instance protection option is activated.
+    Placement group ID if Instance must be part of a placement group.
     """
 
-    private_ip: Optional[str]
+    private_nics: Optional[List[str]]
     """
-    Instance private IP address.
+    Instance private NICs.
     """
 
-    public_ip: Optional[ServerIp]
+    commercial_type: Optional[str]
     """
-    Information about the public IP.
+    Warning: This field has some restrictions:
+- Cannot be changed if the Instance is not in `stopped` state.
+- Cannot be changed if the Instance is in a placement group.
+- Local storage requirements of the target commercial_types must be fulfilled (i.e. if an Instance has 80GB of local storage, it can be changed into a GP1-XS, which has a maximum of 150GB, but it cannot be changed into a DEV1-S, which has only 20GB).
     """
 
-    public_ips: Optional[List[ServerIp]]
-    """
-    Information about all the public IPs attached to the server.
-    """
 
-    modification_date: Optional[datetime]
-    """
-    Instance modification date.
-    """
+@dataclass
+class UpdateServerResponse:
+    server: Optional[Server]
 
-    state_detail: str
-    """
-    Instance state_detail.
-    """
 
-    state: Optional[ServerState]
+@dataclass
+class UpdateSnapshotRequest:
+    snapshot_id: str
     """
-    Instance state.
+    UUID of the snapshot.
     """
 
-    location: Optional[ServerLocation]
+    zone: Optional[Zone]
     """
-    Instance location.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    ipv6: Optional[ServerIpv6]
+    name: Optional[str]
     """
-    Instance IPv6 address.
+    Name of the snapshot.
     """
 
-    bootscript: Optional[Bootscript]
+    tags: Optional[List[str]]
     """
-    Instance bootscript.
+    Tags of the snapshot.
     """
 
-    boot_type: Optional[BootType]
-    """
-    Instance boot type.
-    """
 
-    volumes: Optional[Dict[str, Volume]]
-    """
-    Instance volumes.
-    """
+@dataclass
+class UpdateSnapshotResponse:
+    snapshot: Optional[Snapshot]
 
-    security_group: Optional[SecurityGroupSummary]
-    """
-    Instance security group.
-    """
 
-    maintenances: Optional[List[ServerMaintenance]]
+@dataclass
+class UpdateVolumeRequest:
+    volume_id: str
     """
-    Instance planned maintenances.
+    UUID of the volume.
     """
 
-    arch: Optional[Arch]
+    zone: Optional[Zone]
     """
-    Instance architecture (refers to the CPU architecture used for the Instance, e.g. x86_64, arm64).
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    placement_group: Optional[PlacementGroup]
+    name: Optional[str]
     """
-    Instance placement group.
+    Volume name.
     """
 
-    private_nics: Optional[List[PrivateNIC]]
+    tags: Optional[List[str]]
     """
-    Instance private NICs.
+    Tags of the volume.
     """
 
-
-@dataclass
-class _SetServerResponse:
-    server: Optional[Server]
-
-
-@dataclass
-class _SetSnapshotRequest:
-    id: str
-
-    name: str
-
-    zone: Optional[Zone]
+    size: Optional[int]
     """
-    Zone to target. If none is passed will use default zone from the config.
+    Volume disk size, must be a multiple of 512.
     """
 
-    organization: Optional[str]
-
-    volume_type: Optional[VolumeVolumeType]
-
-    size: int
-
-    state: Optional[SnapshotState]
-
-    base_volume: Optional[SnapshotBaseVolume]
-
-    creation_date: Optional[datetime]
-
-    modification_date: Optional[datetime]
-
-    project: Optional[str]
-
-    snapshot_id: str
-
-    tags: Optional[List[str]]
-
 
 @dataclass
-class _SetSnapshotResponse:
-    snapshot: Optional[Snapshot]
+class UpdateVolumeResponse:
+    volume: Optional[Volume]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/instance/v1/types_private.py` & `scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/types.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,595 +1,632 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from __future__ import annotations
 
 from dataclasses import dataclass
 from datetime import datetime
-from typing import Dict, List, Optional
+from enum import Enum
+from typing import List, Optional
 
 from scaleway_core.bridge import (
-    Zone,
+    Region,
 )
-from .types import (
-    Arch,
-    BootType,
-    Bootscript,
-    Image,
-    ImageState,
-    PlacementGroup,
-    PrivateNIC,
-    SecurityGroup,
-    SecurityGroupPolicy,
-    SecurityGroupRule,
-    SecurityGroupRuleAction,
-    SecurityGroupRuleDirection,
-    SecurityGroupRuleProtocol,
-    SecurityGroupSummary,
-    SecurityGroupTemplate,
-    Server,
-    ServerAction,
-    ServerIp,
-    ServerIpv6,
-    ServerLocation,
-    ServerMaintenance,
-    ServerState,
-    ServerSummary,
-    Snapshot,
-    SnapshotBaseVolume,
-    SnapshotState,
-    Volume,
-    VolumeServerTemplate,
-    VolumeSummary,
-    VolumeVolumeType,
+from scaleway_core.utils import (
+    StrEnumMeta,
 )
 
 
+class ListNamesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class ListPinsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class ListVolumesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class NameStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_STATUS = "unknown_status"
+    QUEUED = "queued"
+    PUBLISHING = "publishing"
+    FAILED = "failed"
+    PUBLISHED = "published"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class PinDetails(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_DETAILS = "unknown_details"
+    PINNING_LOOKING_FOR_PROVIDER = "pinning_looking_for_provider"
+    PINNING_IN_PROGRESS = "pinning_in_progress"
+    PINNING_BLOCKS_FETCHED = "pinning_blocks_fetched"
+    PINNING_FETCHING_URL_DATA = "pinning_fetching_url_data"
+    PINNED_OK = "pinned_ok"
+    UNPINNED_OK = "unpinned_ok"
+    UNPINNING_IN_PROGRESS = "unpinning_in_progress"
+    FAILED_CONTAINS_BANNED_CID = "failed_contains_banned_cid"
+    FAILED_PINNING = "failed_pinning"
+    FAILED_PINNING_NO_PROVIDER = "failed_pinning_no_provider"
+    FAILED_PINNING_BAD_CID_FORMAT = "failed_pinning_bad_cid_format"
+    FAILED_PINNING_TIMEOUT = "failed_pinning_timeout"
+    FAILED_PINNING_TOO_BIG_CONTENT = "failed_pinning_too_big_content"
+    FAILED_PINNING_UNREACHABLE_URL = "failed_pinning_unreachable_url"
+    FAILED_PINNING_BAD_URL_FORMAT = "failed_pinning_bad_url_format"
+    FAILED_PINNING_NO_URL_CONTENT_LENGTH = "failed_pinning_no_url_content_length"
+    FAILED_PINNING_BAD_URL_STATUS_CODE = "failed_pinning_bad_url_status_code"
+    FAILED_UNPINNING = "failed_unpinning"
+    CHECKING_COHERENCE = "checking_coherence"
+    RESCHEDULED = "rescheduled"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class PinStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_STATUS = "unknown_status"
+    QUEUED = "queued"
+    PINNING = "pinning"
+    FAILED = "failed"
+    PINNED = "pinned"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 @dataclass
-class _SetImageResponse:
-    """
-    Set image response.
-    """
+class PinCIDMeta:
+    id: Optional[str]
+
+
+@dataclass
+class PinCID:
+    origins: List[str]
+
+    cid: Optional[str]
+
+    name: Optional[str]
 
-    image: Optional[Image]
+    meta: Optional[PinCIDMeta]
 
 
 @dataclass
-class _SetSecurityGroupResponse:
-    """
-    Set security group response.
-    """
+class PinInfo:
+    status_details: PinDetails
 
-    security_group: Optional[SecurityGroup]
+    id: Optional[str]
+
+    url: Optional[str]
+
+    size: Optional[int]
+
+    progress: Optional[int]
 
 
 @dataclass
-class _SetSecurityGroupRuleResponse:
+class Name:
+    name_id: str
+
+    project_id: str
+
+    tags: List[str]
+
+    name: str
+
+    key: str
+
+    status: NameStatus
+
+    value: str
+
+    region: Region
     """
-    Set security group rule response.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    rule: Optional[SecurityGroupRule]
+    created_at: Optional[datetime]
+
+    updated_at: Optional[datetime]
 
 
 @dataclass
-class _SetServerResponse:
-    """
-    Set server response.
-    """
+class Pin:
+    pin_id: str
+
+    status: PinStatus
+
+    delegates: List[str]
 
-    server: Optional[Server]
+    created_at: Optional[datetime]
+
+    cid: Optional[PinCID]
+
+    info: Optional[PinInfo]
 
 
 @dataclass
-class _SetSnapshotResponse:
+class Volume:
+    id: str
+
+    project_id: str
+
+    region: Region
     """
-    Set snapshot response.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    snapshot: Optional[Snapshot]
+    count_pin: int
+
+    tags: List[str]
+
+    name: str
+
+    created_at: Optional[datetime]
+
+    updated_at: Optional[datetime]
+
+    size: Optional[int]
 
 
 @dataclass
-class _CreateServerRequest:
-    zone: Optional[Zone]
+class CreatePinByCIDRequest:
+    volume_id: str
     """
-    Zone to target. If none is passed will use default zone from the config.
+    Volume ID on which you want to pin your content.
     """
 
-    name: Optional[str]
+    cid: str
     """
-    Instance name.
+    CID containing the content you want to pin.
     """
 
-    dynamic_ip_required: Optional[bool]
+    region: Optional[Region]
     """
-    Define if a dynamic IPv4 is required for the Instance.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    routed_ip_enabled: Optional[bool]
+    origins: Optional[List[str]]
     """
-    If true, configure the Instance so it uses the new routed IP mode.
+    Node containing the content you want to pin.
     """
 
-    commercial_type: str
+    name: Optional[str]
     """
-    Define the Instance commercial type (i.e. GP1-S).
+    Pin name.
     """
 
-    image: str
-    """
-    Instance image ID or label.
-    """
 
-    volumes: Optional[Dict[str, VolumeServerTemplate]]
+@dataclass
+class CreatePinByURLRequest:
+    volume_id: str
     """
-    Volumes attached to the server.
+    Volume ID on which you want to pin your content.
     """
 
-    enable_ipv6: bool
+    url: str
     """
-    True if IPv6 is enabled on the server.
+    URL containing the content you want to pin.
     """
 
-    public_ip: Optional[str]
+    region: Optional[Region]
     """
-    ID of the reserved IP to attach to the Instance.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    public_ips: Optional[List[str]]
+    name: Optional[str]
     """
-    A list of reserved IP IDs to attach to the Instance.
+    Pin name.
     """
 
-    boot_type: Optional[BootType]
-    """
-    Boot type to use.
-    """
 
-    bootscript: Optional[str]
+@dataclass
+class CreateVolumeRequest:
+    name: str
     """
-    Bootscript ID to use when `boot_type` is set to `bootscript`.
-    :deprecated
+    Volume name.
     """
 
-    organization: Optional[str]
+    region: Optional[Region]
     """
-    Instance Organization ID.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-    :deprecated
+    Region to target. If none is passed will use default region from the config.
     """
 
-    project: Optional[str]
+    project_id: Optional[str]
     """
-    Instance Project ID.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    Project ID.
     """
 
-    tags: Optional[List[str]]
+
+@dataclass
+class DeletePinRequest:
+    volume_id: str
     """
-    Instance tags.
+    Volume ID.
     """
 
-    security_group: Optional[str]
+    pin_id: str
     """
-    Security group ID.
+    Pin ID you want to remove from the volume.
     """
 
-    placement_group: Optional[str]
+    region: Optional[Region]
     """
-    Placement group ID if Instance must be part of a placement group.
+    Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
-class _SetServerRequest:
-    zone: Optional[Zone]
+class DeleteVolumeRequest:
+    volume_id: str
     """
-    Zone to target. If none is passed will use default zone from the config.
+    Volume ID.
     """
 
-    id: str
+    region: Optional[Region]
     """
-    Instance unique ID.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: str
-    """
-    Instance name.
-    """
 
-    organization: Optional[str]
-    """
-    Instance Organization ID.
-    """
+@dataclass
+class ExportKeyNameResponse:
+    name_id: str
 
-    project: Optional[str]
-    """
-    Instance Project ID.
-    """
+    project_id: str
 
-    allowed_actions: Optional[List[ServerAction]]
+    public_key: str
+
+    private_key: str
+
+    created_at: Optional[datetime]
+
+    updated_at: Optional[datetime]
+
+
+@dataclass
+class GetPinRequest:
+    volume_id: str
     """
-    Provide a list of allowed actions on the server.
+    Volume ID.
     """
 
-    tags: Optional[List[str]]
+    pin_id: str
     """
-    Tags associated with the Instance.
+    Pin ID of which you want to obtain information.
     """
 
-    commercial_type: str
+    region: Optional[Region]
     """
-    Instance commercial type (eg. GP1-M).
+    Region to target. If none is passed will use default region from the config.
     """
 
-    creation_date: Optional[datetime]
+
+@dataclass
+class GetVolumeRequest:
+    volume_id: str
     """
-    Instance creation date.
+    Volume ID.
     """
 
-    dynamic_ip_required: bool
+    region: Optional[Region]
     """
-    True if a dynamic IPv4 is required.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    routed_ip_enabled: Optional[bool]
+
+@dataclass
+class IpnsApiCreateNameRequest:
+    name: str
     """
-    True to configure the instance so it uses the new routed IP mode (once this is set to True you cannot set it back to False).
+    Name for your records.
     """
 
-    enable_ipv6: bool
+    value: str
     """
-    True if IPv6 is enabled.
+    Value you want to associate with your records, CID or IPNS key.
     """
 
-    hostname: str
+    region: Optional[Region]
     """
-    Instance host name.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    image: Optional[Image]
+    project_id: Optional[str]
     """
-    Provide information on the Instance image.
+    Project ID.
     """
 
-    protected: bool
+
+@dataclass
+class IpnsApiDeleteNameRequest:
+    name_id: str
     """
-    Instance protection option is activated.
+    Name ID you wish to delete.
     """
 
-    private_ip: Optional[str]
+    region: Optional[Region]
     """
-    Instance private IP address.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    public_ip: Optional[ServerIp]
+
+@dataclass
+class IpnsApiExportKeyNameRequest:
+    name_id: str
     """
-    Information about the public IP.
+    Name ID whose keys you want to export.
     """
 
-    public_ips: Optional[List[ServerIp]]
+    region: Optional[Region]
     """
-    Information about all the public IPs attached to the server.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    modification_date: Optional[datetime]
+
+@dataclass
+class IpnsApiGetNameRequest:
+    name_id: str
     """
-    Instance modification date.
+    Name ID whose information you want to retrieve.
     """
 
-    state: ServerState
+    region: Optional[Region]
     """
-    Instance state.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    location: Optional[ServerLocation]
+
+@dataclass
+class IpnsApiImportKeyNameRequest:
+    name: str
     """
-    Instance location.
+    Name for your records.
     """
 
-    ipv6: Optional[ServerIpv6]
+    private_key: str
     """
-    Instance IPv6 address.
+    Base64 private key.
     """
 
-    bootscript: Optional[Bootscript]
+    value: str
     """
-    Instance bootscript.
-    :deprecated
+    Value you want to associate with your records, CID or IPNS key.
     """
 
-    boot_type: BootType
+    region: Optional[Region]
     """
-    Instance boot type.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    volumes: Optional[Dict[str, Volume]]
+    project_id: Optional[str]
     """
-    Instance volumes.
+    Project ID.
     """
 
-    security_group: Optional[SecurityGroupSummary]
+
+@dataclass
+class IpnsApiListNamesRequest:
+    region: Optional[Region]
     """
-    Instance security group.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    maintenances: Optional[List[ServerMaintenance]]
+    project_id: Optional[str]
     """
-    Instance planned maintenances.
+    Project ID.
     """
 
-    state_detail: str
+    organization_id: Optional[str]
     """
-    Instance state_detail.
+    Organization ID.
     """
 
-    arch: Arch
+    order_by: Optional[ListNamesRequestOrderBy]
     """
-    Instance architecture (refers to the CPU architecture used for the Instance, e.g. x86_64, arm64).
+    Sort the order of the returned names.
     """
 
-    placement_group: Optional[PlacementGroup]
+    page: Optional[int]
     """
-    Instance placement group.
+    Page number.
     """
 
-    private_nics: Optional[List[PrivateNIC]]
+    page_size: Optional[int]
     """
-    Instance private NICs.
+    Maximum number of names to return per page.
     """
 
 
 @dataclass
-class _UpdateServerRequest:
-    zone: Optional[Zone]
+class IpnsApiUpdateNameRequest:
+    name_id: str
     """
-    Zone to target. If none is passed will use default zone from the config.
+    Name ID you wish to update.
     """
 
-    server_id: str
+    region: Optional[Region]
     """
-    UUID of the Instance.
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Name of the Instance.
+    New name you want to associate with your record.
     """
 
-    boot_type: Optional[BootType]
-
     tags: Optional[List[str]]
     """
-    Tags of the Instance.
+    New tags you want to associate with your record.
     """
 
-    volumes: Optional[Dict[str, VolumeServerTemplate]]
-
-    bootscript: Optional[str]
+    value: Optional[str]
     """
-    :deprecated
+    Value you want to associate with your records, CID or IPNS key.
     """
 
-    dynamic_ip_required: Optional[bool]
 
-    routed_ip_enabled: Optional[bool]
+@dataclass
+class ListNamesResponse:
+    names: List[Name]
+
+    total_count: int
+
+
+@dataclass
+class ListPinsRequest:
+    volume_id: str
     """
-    True to configure the instance so it uses the new routed IP mode (once this is set to True you cannot set it back to False).
+    Volume ID of which you want to list the pins.
     """
 
-    public_ips: Optional[List[str]]
+    region: Optional[Region]
     """
-    A list of reserved IP IDs to attach to the Instance.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    enable_ipv6: Optional[bool]
-
-    protected: Optional[bool]
-
-    security_group: Optional[SecurityGroupTemplate]
-
-    placement_group: Optional[str]
+    project_id: Optional[str]
     """
-    Placement group ID if Instance must be part of a placement group.
+    Project ID.
     """
 
-    private_nics: Optional[List[str]]
+    organization_id: Optional[str]
     """
-    Instance private NICs.
+    Organization ID.
     """
 
-    commercial_type: Optional[str]
+    order_by: Optional[ListPinsRequestOrderBy]
     """
-    Set the commercial_type for this Instance.
-    Warning: This field has some restrictions:
-    - Cannot be changed if the Instance is not in `stopped` state.
-    - Cannot be changed if the Instance is in a placement group.
-    - Local storage requirements of the target commercial_types must be fulfilled (i.e. if an Instance has 80GB of local storage, it can be changed into a GP1-XS, which has a maximum of 150GB, but it cannot be changed into a DEV1-S, which has only 20GB).
+    Sort order of the returned Volume.
     """
 
-
-@dataclass
-class _SetImageRequest:
-    zone: Optional[Zone]
+    page: Optional[int]
     """
-    Zone to target. If none is passed will use default zone from the config.
+    Page number.
     """
 
-    id: str
-
-    name: str
-
-    arch: Arch
-
-    creation_date: Optional[datetime]
-
-    modification_date: Optional[datetime]
-
-    default_bootscript: Optional[Bootscript]
+    page_size: Optional[int]
     """
-    :deprecated
+    Maximum number of volumes to return per page.
     """
 
-    extra_volumes: Optional[Dict[str, Volume]]
-
-    from_server: str
-
-    organization: Optional[str]
-
-    public: bool
-
-    root_volume: Optional[VolumeSummary]
-
-    state: ImageState
-
-    project: Optional[str]
-
-    tags: Optional[List[str]]
-
-
-@dataclass
-class _SetSnapshotRequest:
-    zone: Optional[Zone]
+    status: Optional[PinStatus]
     """
-    Zone to target. If none is passed will use default zone from the config.
+    List pins by status.
     """
 
-    snapshot_id: str
-
-    id: str
-
-    name: str
-
-    organization: Optional[str]
-
-    volume_type: VolumeVolumeType
-
-    size: int
-
-    state: SnapshotState
 
-    base_volume: Optional[SnapshotBaseVolume]
-
-    creation_date: Optional[datetime]
-
-    modification_date: Optional[datetime]
-
-    project: Optional[str]
+@dataclass
+class ListPinsResponse:
+    total_count: int
 
-    tags: Optional[List[str]]
+    pins: List[Pin]
 
 
 @dataclass
-class _SetSecurityGroupRequest:
-    zone: Optional[Zone]
+class ListVolumesRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    id: str
+    project_id: Optional[str]
     """
-    ID of the security group (will be ignored).
+    Project ID, only volumes belonging to this project will be listed.
     """
 
-    name: str
+    order_by: Optional[ListVolumesRequestOrderBy]
     """
-    Name of the security group.
+    Sort the order of the returned volumes.
     """
 
-    tags: Optional[List[str]]
+    page: Optional[int]
     """
-    Tags of the security group.
+    Page number.
     """
 
-    creation_date: Optional[datetime]
+    page_size: Optional[int]
     """
-    Creation date of the security group (will be ignored).
+    Maximum number of volumes to return per page.
     """
 
-    modification_date: Optional[datetime]
-    """
-    Modification date of the security group (will be ignored).
-    """
 
-    description: str
-    """
-    Description of the security group.
-    """
+@dataclass
+class ListVolumesResponse:
+    volumes: List[Volume]
+
+    total_count: int
 
-    enable_default_security: bool
+
+@dataclass
+class ReplacePinRequest:
+    volume_id: str
     """
-    True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
+    Volume ID.
     """
 
-    inbound_default_policy: SecurityGroupPolicy
+    pin_id: str
     """
-    Default inbound policy.
+    Pin ID whose information you wish to replace.
     """
 
-    outbound_default_policy: SecurityGroupPolicy
+    cid: str
     """
-    Default outbound policy.
+    New CID you want to pin in place of the old one.
     """
 
-    organization: Optional[str]
+    region: Optional[Region]
     """
-    Security groups Organization ID.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    project: Optional[str]
+    name: Optional[str]
     """
-    Security group Project ID.
+    New name to replace.
     """
 
-    organization_default: Optional[bool]
+    origins: Optional[List[str]]
     """
-    Please use project_default instead.
-    :deprecated
+    Node containing the content you want to pin.
     """
 
-    project_default: bool
+
+@dataclass
+class ReplacePinResponse:
+    pin: Optional[Pin]
+
+
+@dataclass
+class UpdateVolumeRequest:
+    volume_id: str
     """
-    True use this security group for future Instances created in this project.
+    Volume ID.
     """
 
-    servers: Optional[List[ServerSummary]]
+    region: Optional[Region]
     """
-    Instances attached to this security group.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    stateful: bool
+    name: Optional[str]
     """
-    True to set the security group as stateful.
+    Volume name.
     """
 
-
-@dataclass
-class _SetSecurityGroupRuleRequest:
-    zone: Optional[Zone]
+    tags: Optional[List[str]]
     """
-    Zone to target. If none is passed will use default zone from the config.
+    Tags of the volume.
     """
-
-    security_group_id: str
-
-    security_group_rule_id: str
-
-    id: str
-
-    protocol: SecurityGroupRuleProtocol
-
-    direction: SecurityGroupRuleDirection
-
-    action: SecurityGroupRuleAction
-
-    ip_range: str
-
-    dest_port_from: Optional[int]
-
-    dest_port_to: Optional[int]
-
-    position: int
-
-    editable: bool
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/iot/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/iot/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/iot/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/iot/v1/api.py`

 * *Files 1% similar despite different names*

```diff
@@ -214,14 +214,15 @@
         :param product_plan: Hub product plan.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Hub name (up to 255 characters).
         :param project_id: Project/Organization ID to filter for, only Hubs from this Project/Organization will be returned.
         :param disable_events: Disable Hub events.
         :param events_topic_prefix: Topic prefix (default '$SCW/events') of Hub events.
         :param twins_graphite_config: BETA - not implemented yet.
+        One-Of ('twins_db_config'): at most one of 'twins_graphite_config' could be set.
         :return: :class:`Hub <Hub>`
 
         Usage:
         ::
 
             result = await api.create_hub(
                 product_plan=plan_shared,
@@ -342,14 +343,15 @@
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Hub name (up to 255 characters).
         :param product_plan: Hub product plan.
         :param disable_events: Disable Hub events.
         :param events_topic_prefix: Topic prefix of Hub events.
         :param enable_device_auto_provisioning: Enable device auto provisioning.
         :param twins_graphite_config: BETA - not implemented yet.
+        One-Of ('twins_db_config'): at most one of 'twins_graphite_config' could be set.
         :return: :class:`Hub <Hub>`
 
         Usage:
         ::
 
             result = await api.update_hub(
                 hub_id="example",
@@ -1225,16 +1227,19 @@
           You need to create the bucket yourself and grant write access.
           Granting can be done with s3cmd (`s3cmd setacl s3://<my-bucket> --acl-grant=write:555c69c3-87d0-4bf8-80f1-99a2f757d031:555c69c3-87d0-4bf8-80f1-99a2f757d031`).
         :param hub_id: Hub ID of the route.
         :param topic: Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Route name.
         :param s3_config: If creating S3 Route, S3-specific configuration fields.
+        One-Of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :param db_config: If creating Database Route, DB-specific configuration fields.
+        One-Of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :param rest_config: If creating Rest Route, Rest-specific configuration fields.
+        One-Of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
             result = await api.create_route(
                 hub_id="example",
@@ -1281,16 +1286,19 @@
         Update a route.
         Update the parameters of an existing route, specified by its route ID.
         :param route_id: Route id.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Route name.
         :param topic: Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters.
         :param s3_config: When updating S3 Route, S3-specific configuration fields.
+        One-Of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :param db_config: When updating Database Route, DB-specific configuration fields.
+        One-Of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :param rest_config: When updating Rest Route, Rest-specific configuration fields.
+        One-Of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
             result = await api.update_route(
                 route_id="example",
@@ -1397,15 +1405,14 @@
         order_by: Optional[ListNetworksRequestOrderBy] = None,
         name: Optional[str] = None,
         hub_id: Optional[str] = None,
         topic_prefix: Optional[str] = None,
     ) -> ListNetworksResponse:
         """
         List the networks.
-        List the networks.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number to return, from the paginated results.
         :param page_size: Number of networks to return. The maximum value is 100.
         :param order_by: Ordering of requested routes.
         :param name: Network name to filter for.
         :param hub_id: Hub ID to filter for.
         :param topic_prefix: Topic prefix to filter for.
@@ -1446,15 +1453,14 @@
         order_by: Optional[ListNetworksRequestOrderBy] = None,
         name: Optional[str] = None,
         hub_id: Optional[str] = None,
         topic_prefix: Optional[str] = None,
     ) -> List[Network]:
         """
         List the networks.
-        List the networks.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: Page number to return, from the paginated results.
         :param page_size: Number of networks to return. The maximum value is 100.
         :param order_by: Ordering of requested routes.
         :param name: Network name to filter for.
         :param hub_id: Hub ID to filter for.
         :param topic_prefix: Topic prefix to filter for.
@@ -1603,15 +1609,14 @@
         *,
         twin_id: str,
         document_name: str,
         region: Optional[Region] = None,
     ) -> TwinDocument:
         """
         BETA - Get a Cloud Twin Document.
-        BETA - Get a Cloud Twin Document.
         :param twin_id: Twin ID.
         :param document_name: Name of the document.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`TwinDocument <TwinDocument>`
 
         Usage:
         ::
@@ -1643,15 +1648,14 @@
         document_name: str,
         region: Optional[Region] = None,
         version: Optional[int] = None,
         data: Optional[Dict[str, Any]] = None,
     ) -> TwinDocument:
         """
         BETA - Update a Cloud Twin Document.
-        BETA - Update a Cloud Twin Document.
         :param twin_id: Twin ID.
         :param document_name: Name of the document.
         :param region: Region to target. If none is passed will use default region from the config.
         :param version: If set, ensures that the current version of the document matches before persisting the update.
         :param data: New data that will replace the contents of the document.
         :return: :class:`TwinDocument <TwinDocument>`
 
@@ -1695,15 +1699,14 @@
         document_name: str,
         region: Optional[Region] = None,
         version: Optional[int] = None,
         data: Optional[Dict[str, Any]] = None,
     ) -> TwinDocument:
         """
         BETA - Patch a Cloud Twin Document.
-        BETA - Patch a Cloud Twin Document.
         :param twin_id: Twin ID.
         :param document_name: Name of the document.
         :param region: Region to target. If none is passed will use default region from the config.
         :param version: If set, ensures that the current version of the document matches before persisting the update.
         :param data: A json data that will be applied on the document's current data.
         Patching rules:
         * The patch goes recursively through the patch objects.
@@ -1750,15 +1753,14 @@
         *,
         twin_id: str,
         document_name: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         BETA - Delete a Cloud Twin Document.
-        BETA - Delete a Cloud Twin Document.
         :param twin_id: Twin ID.
         :param document_name: Name of the document.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
@@ -1785,15 +1787,14 @@
         self,
         *,
         twin_id: str,
         region: Optional[Region] = None,
     ) -> ListTwinDocumentsResponse:
         """
         BETA - List the documents of a Cloud Twin.
-        BETA - List the documents of a Cloud Twin.
         :param twin_id: Twin ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`ListTwinDocumentsResponse <ListTwinDocumentsResponse>`
 
         Usage:
         ::
 
@@ -1819,15 +1820,14 @@
         self,
         *,
         twin_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         BETA - Delete all the documents of a Cloud Twin.
-        BETA - Delete all the documents of a Cloud Twin.
         :param twin_id: Twin ID.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.delete_twin_documents(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/iot/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/iot/v1/marshalling.py`

 * *Files 3% similar despite different names*

```diff
@@ -71,14 +71,16 @@
     field = data.get("policy", None)
     if field is not None:
         args["policy"] = field
 
     field = data.get("topics", None)
     if field is not None:
         args["topics"] = field
+    else:
+        args["topics"] = None
 
     return DeviceMessageFiltersRule(**args)
 
 
 def unmarshal_DeviceMessageFilters(data: Any) -> DeviceMessageFilters:
     if not isinstance(data, dict):
         raise TypeError(
@@ -86,18 +88,22 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("publish", None)
     if field is not None:
         args["publish"] = unmarshal_DeviceMessageFiltersRule(field)
+    else:
+        args["publish"] = None
 
     field = data.get("subscribe", None)
     if field is not None:
         args["subscribe"] = unmarshal_DeviceMessageFiltersRule(field)
+    else:
+        args["subscribe"] = None
 
     return DeviceMessageFilters(**args)
 
 
 def unmarshal_Device(data: Any) -> Device:
     if not isinstance(data, dict):
         raise TypeError(
@@ -127,14 +133,16 @@
         args["hub_id"] = field
 
     field = data.get("last_activity_at", None)
     if field is not None:
         args["last_activity_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["last_activity_at"] = None
 
     field = data.get("is_connected", None)
     if field is not None:
         args["is_connected"] = field
 
     field = data.get("allow_insecure", None)
     if field is not None:
@@ -147,22 +155,28 @@
     field = data.get("has_custom_certificate", None)
     if field is not None:
         args["has_custom_certificate"] = field
 
     field = data.get("message_filters", None)
     if field is not None:
         args["message_filters"] = unmarshal_DeviceMessageFilters(field)
+    else:
+        args["message_filters"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Device(**args)
 
 
 def unmarshal_Network(data: Any) -> Network:
     if not isinstance(data, dict):
         raise TypeError(
@@ -175,15 +189,15 @@
     if field is not None:
         args["id"] = field
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("endpoint", None)
     if field is not None:
         args["endpoint"] = field
 
@@ -194,14 +208,16 @@
     field = data.get("topic_prefix", None)
     if field is not None:
         args["topic_prefix"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return Network(**args)
 
 
 def unmarshal_HubTwinsGraphiteConfig(data: Any) -> HubTwinsGraphiteConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -284,22 +300,28 @@
     field = data.get("has_custom_ca", None)
     if field is not None:
         args["has_custom_ca"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("twins_graphite_config", None)
     if field is not None:
         args["twins_graphite_config"] = unmarshal_HubTwinsGraphiteConfig(field)
+    else:
+        args["twins_graphite_config"] = None
 
     return Hub(**args)
 
 
 def unmarshal_Certificate(data: Any) -> Certificate:
     if not isinstance(data, dict):
         raise TypeError(
@@ -326,18 +348,22 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("device", None)
     if field is not None:
         args["device"] = unmarshal_Device(field)
+    else:
+        args["device"] = None
 
     field = data.get("certificate", None)
     if field is not None:
         args["certificate"] = unmarshal_Certificate(field)
+    else:
+        args["certificate"] = None
 
     return CreateDeviceResponse(**args)
 
 
 def unmarshal_CreateNetworkResponse(data: Any) -> CreateNetworkResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -349,14 +375,16 @@
     field = data.get("secret", None)
     if field is not None:
         args["secret"] = field
 
     field = data.get("network", None)
     if field is not None:
         args["network"] = unmarshal_Network(field)
+    else:
+        args["network"] = None
 
     return CreateNetworkResponse(**args)
 
 
 def unmarshal_GetDeviceCertificateResponse(data: Any) -> GetDeviceCertificateResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -368,14 +396,16 @@
     field = data.get("certificate_pem", None)
     if field is not None:
         args["certificate_pem"] = field
 
     field = data.get("device", None)
     if field is not None:
         args["device"] = unmarshal_Device(field)
+    else:
+        args["device"] = None
 
     return GetDeviceCertificateResponse(**args)
 
 
 def unmarshal_GetDeviceMetricsResponse(data: Any) -> GetDeviceMetricsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -506,25 +536,29 @@
     if field is not None:
         args["hub_id"] = field
 
     field = data.get("topic", None)
     if field is not None:
         args["topic"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return RouteSummary(**args)
 
 
 def unmarshal_ListRoutesResponse(data: Any) -> ListRoutesResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -591,18 +625,22 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("device", None)
     if field is not None:
         args["device"] = unmarshal_Device(field)
+    else:
+        args["device"] = None
 
     field = data.get("certificate", None)
     if field is not None:
         args["certificate"] = unmarshal_Certificate(field)
+    else:
+        args["certificate"] = None
 
     return RenewDeviceCertificateResponse(**args)
 
 
 def unmarshal_RouteDatabaseConfig(data: Any) -> RouteDatabaseConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -712,37 +750,47 @@
     if field is not None:
         args["hub_id"] = field
 
     field = data.get("topic", None)
     if field is not None:
         args["topic"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("s3_config", None)
     if field is not None:
         args["s3_config"] = unmarshal_RouteS3Config(field)
+    else:
+        args["s3_config"] = None
 
     field = data.get("db_config", None)
     if field is not None:
         args["db_config"] = unmarshal_RouteDatabaseConfig(field)
+    else:
+        args["db_config"] = None
 
     field = data.get("rest_config", None)
     if field is not None:
         args["rest_config"] = unmarshal_RouteRestConfig(field)
+    else:
+        args["rest_config"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Route(**args)
 
 
 def unmarshal_SetDeviceCertificateResponse(data: Any) -> SetDeviceCertificateResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -754,14 +802,16 @@
     field = data.get("certificate_pem", None)
     if field is not None:
         args["certificate_pem"] = field
 
     field = data.get("device", None)
     if field is not None:
         args["device"] = unmarshal_Device(field)
+    else:
+        args["device"] = None
 
     return SetDeviceCertificateResponse(**args)
 
 
 def unmarshal_TwinDocument(data: Any) -> TwinDocument:
     if not isinstance(data, dict):
         raise TypeError(
@@ -781,14 +831,16 @@
     field = data.get("version", None)
     if field is not None:
         args["version"] = field
 
     field = data.get("data", None)
     if field is not None:
         args["data"] = field
+    else:
+        args["data"] = None
 
     return TwinDocument(**args)
 
 
 def marshal_DeviceMessageFiltersRule(
     request: DeviceMessageFiltersRule,
     defaults: ProfileDefaults,
@@ -1121,17 +1173,17 @@
     if request.disable_events is not None:
         output["disable_events"] = request.disable_events
 
     if request.events_topic_prefix is not None:
         output["events_topic_prefix"] = request.events_topic_prefix
 
     if request.enable_device_auto_provisioning is not None:
-        output[
-            "enable_device_auto_provisioning"
-        ] = request.enable_device_auto_provisioning
+        output["enable_device_auto_provisioning"] = (
+            request.enable_device_auto_provisioning
+        )
 
     return output
 
 
 def marshal_UpdateRouteRequestDatabaseConfig(
     request: UpdateRouteRequestDatabaseConfig,
     defaults: ProfileDefaults,
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/iot/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/iot/v1/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/ipam/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/ipam/v1/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,28 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import ListIPsRequestOrderBy
 from .types import ResourceType
 from .types import Resource
+from .types import Reverse
 from .types import Source
 from .types import IP
 from .types import BookIPRequest
 from .types import GetIPRequest
 from .types import ListIPsRequest
 from .types import ListIPsResponse
 from .types import ReleaseIPRequest
 from .types import UpdateIPRequest
 from .api import IpamV1API
 
 __all__ = [
     "ListIPsRequestOrderBy",
     "ResourceType",
     "Resource",
+    "Reverse",
     "Source",
     "IP",
     "BookIPRequest",
     "GetIPRequest",
     "ListIPsRequest",
     "ListIPsResponse",
     "ReleaseIPRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/ipam/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/ipam/v1/api.py`

 * *Files 4% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 )
 from .types import (
     ListIPsRequestOrderBy,
     ResourceType,
     BookIPRequest,
     IP,
     ListIPsResponse,
+    Reverse,
     Source,
     UpdateIPRequest,
 )
 from .marshalling import (
     unmarshal_IP,
     unmarshal_ListIPsResponse,
     marshal_BookIPRequest,
@@ -157,21 +158,23 @@
 
     async def update_ip(
         self,
         *,
         ip_id: str,
         region: Optional[Region] = None,
         tags: Optional[List[str]] = None,
+        reverses: Optional[List[Reverse]] = None,
     ) -> IP:
         """
         Update an IP.
         Update parameters including tags of the specified IP.
         :param ip_id: IP ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param tags: Tags for the IP.
+        :param reverses: Array of reverse domain names associated with an IP in the subnet of the current IP.
         :return: :class:`IP <IP>`
 
         Usage:
         ::
 
             result = await api.update_ip(
                 ip_id="example",
@@ -187,14 +190,15 @@
             "PATCH",
             f"/ipam/v1/regions/{param_region}/ips/{param_ip_id}",
             body=marshal_UpdateIPRequest(
                 UpdateIPRequest(
                     ip_id=ip_id,
                     region=region,
                     tags=tags,
+                    reverses=reverses,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_IP(res.json())
@@ -223,15 +227,17 @@
         List existing IPs in the specified region using various filters. For example, you can filter for IPs within a specified Private Network, or for public IPs within a specified Project. By default, the IPs returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of the returned IPs.
         :param page: Page number to return, from the paginated results.
         :param page_size: Maximum number of IPs to return per page.
         :param project_id: Project ID to filter for. Only IPs belonging to this Project will be returned.
         :param zonal: Zone to filter for. Only IPs that are zonal, and in this zone, will be returned.
+        One-Of ('source'): at most one of 'zonal', 'private_network_id' could be set.
         :param private_network_id: Only IPs that are private, and in this Private Network, will be returned.
+        One-Of ('source'): at most one of 'zonal', 'private_network_id' could be set.
         :param attached: Defines whether to filter only for IPs which are attached to a resource.
         :param resource_id: Resource ID to filter for. Only IPs attached to this resource will be returned.
         :param resource_type: Resource type to filter for. Only IPs attached to this type of resource will be returned.
         :param mac_address: MAC address to filter for. Only IPs attached to a resource with this MAC address will be returned.
         :param tags: Tags to filter for, only IPs with one or more matching tags will be returned.
         :param organization_id: Organization ID to filter for. Only IPs belonging to this Organization will be returned.
         :param is_ipv6: Defines whether to filter only for IPv4s or IPv6s.
@@ -301,15 +307,17 @@
         List existing IPs in the specified region using various filters. For example, you can filter for IPs within a specified Private Network, or for public IPs within a specified Project. By default, the IPs returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of the returned IPs.
         :param page: Page number to return, from the paginated results.
         :param page_size: Maximum number of IPs to return per page.
         :param project_id: Project ID to filter for. Only IPs belonging to this Project will be returned.
         :param zonal: Zone to filter for. Only IPs that are zonal, and in this zone, will be returned.
+        One-Of ('source'): at most one of 'zonal', 'private_network_id' could be set.
         :param private_network_id: Only IPs that are private, and in this Private Network, will be returned.
+        One-Of ('source'): at most one of 'zonal', 'private_network_id' could be set.
         :param attached: Defines whether to filter only for IPs which are attached to a resource.
         :param resource_id: Resource ID to filter for. Only IPs attached to this resource will be returned.
         :param resource_type: Resource type to filter for. Only IPs attached to this type of resource will be returned.
         :param mac_address: MAC address to filter for. Only IPs attached to a resource with this MAC address will be returned.
         :param tags: Tags to filter for, only IPs with one or more matching tags will be returned.
         :param organization_id: Organization ID to filter for. Only IPs belonging to this Organization will be returned.
         :param is_ipv6: Defines whether to filter only for IPv4s or IPv6s.
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/ipam/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/ipam/v1/marshalling.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,14 +7,15 @@
 from scaleway_core.profile import ProfileDefaults
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from .types import (
     Resource,
+    Reverse,
     Source,
     IP,
     ListIPsResponse,
     BookIPRequest,
     UpdateIPRequest,
 )
 
@@ -42,14 +43,33 @@
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
     return Resource(**args)
 
 
+def unmarshal_Reverse(data: Any) -> Reverse:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'Reverse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("hostname", None)
+    if field is not None:
+        args["hostname"] = field
+
+    field = data.get("address", None)
+    if field is not None:
+        args["address"] = field
+
+    return Reverse(**args)
+
+
 def unmarshal_Source(data: Any) -> Source:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Source' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -97,14 +117,20 @@
     if field is not None:
         args["source"] = unmarshal_Source(field)
 
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
+    field = data.get("reverses", None)
+    if field is not None:
+        args["reverses"] = (
+            [unmarshal_Reverse(v) for v in field] if field is not None else None
+        )
+
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
@@ -181,17 +207,37 @@
 
     if request.tags is not None:
         output["tags"] = request.tags
 
     return output
 
 
+def marshal_Reverse(
+    request: Reverse,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.hostname is not None:
+        output["hostname"] = request.hostname
+
+    if request.address is not None:
+        output["address"] = request.address
+
+    return output
+
+
 def marshal_UpdateIPRequest(
     request: UpdateIPRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.tags is not None:
         output["tags"] = request.tags
 
+    if request.reverses is not None:
+        output["reverses"] = [
+            marshal_Reverse(item, defaults) for item in request.reverses
+        ]
+
     return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/ipam/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/ipam/v1/types.py`

 * *Files 6% similar despite different names*

```diff
@@ -39,14 +39,15 @@
     VPC_GATEWAY_NETWORK = "vpc_gateway_network"
     K8S_NODE = "k8s_node"
     K8S_CLUSTER = "k8s_cluster"
     RDB_INSTANCE = "rdb_instance"
     REDIS_CLUSTER = "redis_cluster"
     BAREMETAL_SERVER = "baremetal_server"
     BAREMETAL_PRIVATE_NIC = "baremetal_private_nic"
+    LLM_DEPLOYMENT = "llm_deployment"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
 class Resource:
@@ -68,14 +69,27 @@
     name: Optional[str]
     """
     When the IP is in a Private Network, then a DNS record is available to resolve the resource name to this IP.
     """
 
 
 @dataclass
+class Reverse:
+    hostname: str
+    """
+    Reverse domain name.
+    """
+
+    address: Optional[str]
+    """
+    IP corresponding to the hostname.
+    """
+
+
+@dataclass
 class Source:
     zonal: Optional[str]
 
     private_network_id: Optional[str]
 
     subnet_id: Optional[str]
 
@@ -108,14 +122,19 @@
     """
 
     tags: List[str]
     """
     Tags for the IP.
     """
 
+    reverses: List[Reverse]
+    """
+    Array of reverses associated with the IP.
+    """
+
     region: Region
     """
     Region of the IP.
     """
 
     created_at: Optional[datetime]
     """
@@ -288,7 +307,12 @@
     Region to target. If none is passed will use default region from the config.
     """
 
     tags: Optional[List[str]]
     """
     Tags for the IP.
     """
+
+    reverses: Optional[List[Reverse]]
+    """
+    Array of reverse domain names associated with an IP in the subnet of the current IP.
+    """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/api.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/content.py` & `scaleway_async-2.1.0/scaleway_async/ipfs/v1alpha1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/jobs/v1alpha1/marshalling.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,491 +2,404 @@
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 from dateutil import parser
 
 from scaleway_core.profile import ProfileDefaults
 from .types import (
-    Name,
-    PinCIDMeta,
-    PinCID,
-    PinInfo,
-    Pin,
-    Volume,
-    ExportKeyNameResponse,
-    ListNamesResponse,
-    ListPinsResponse,
-    ListVolumesResponse,
-    ReplacePinResponse,
-    CreatePinByCIDRequest,
-    CreatePinByURLRequest,
-    CreateVolumeRequest,
-    IpnsApiCreateNameRequest,
-    IpnsApiImportKeyNameRequest,
-    IpnsApiUpdateNameRequest,
-    ReplacePinRequest,
-    UpdateVolumeRequest,
+    CronSchedule,
+    JobDefinition,
+    JobRun,
+    ListJobDefinitionsResponse,
+    ListJobRunsResponse,
+    StartJobDefinitionResponse,
+    CreateJobDefinitionRequestCronScheduleConfig,
+    CreateJobDefinitionRequest,
+    StartJobDefinitionRequest,
+    UpdateJobDefinitionRequestCronScheduleConfig,
+    UpdateJobDefinitionRequest,
 )
 
 
-def unmarshal_Name(data: Any) -> Name:
+def unmarshal_CronSchedule(data: Any) -> CronSchedule:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Name' failed as data isn't a dictionary."
+            "Unmarshalling the type 'CronSchedule' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("name_id", None)
+    field = data.get("schedule", None)
     if field is not None:
-        args["name_id"] = field
+        args["schedule"] = field
 
-    field = data.get("project_id", None)
-    if field is not None:
-        args["project_id"] = field
-
-    field = data.get("tags", None)
-    if field is not None:
-        args["tags"] = field
-
-    field = data.get("name", None)
+    field = data.get("timezone", None)
     if field is not None:
-        args["name"] = field
+        args["timezone"] = field
 
-    field = data.get("key", None)
-    if field is not None:
-        args["key"] = field
+    return CronSchedule(**args)
 
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
 
-    field = data.get("value", None)
-    if field is not None:
-        args["value"] = field
-
-    field = data.get("region", None)
-    if field is not None:
-        args["region"] = field
-
-    field = data.get("created_at", None)
-    if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("updated_at", None)
-    if field is not None:
-        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    return Name(**args)
-
-
-def unmarshal_PinCIDMeta(data: Any) -> PinCIDMeta:
+def unmarshal_JobDefinition(data: Any) -> JobDefinition:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'PinCIDMeta' failed as data isn't a dictionary."
+            "Unmarshalling the type 'JobDefinition' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    return PinCIDMeta(**args)
-
-
-def unmarshal_PinCID(data: Any) -> PinCID:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'PinCID' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("origins", None)
-    if field is not None:
-        args["origins"] = field
-
-    field = data.get("cid", None)
-    if field is not None:
-        args["cid"] = field
-
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
-    field = data.get("meta", None)
+    field = data.get("cpu_limit", None)
     if field is not None:
-        args["meta"] = unmarshal_PinCIDMeta(field)
-
-    return PinCID(**args)
-
-
-def unmarshal_PinInfo(data: Any) -> PinInfo:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'PinInfo' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
+        args["cpu_limit"] = field
 
-    field = data.get("status_details", None)
+    field = data.get("memory_limit", None)
     if field is not None:
-        args["status_details"] = field
+        args["memory_limit"] = field
 
-    field = data.get("id", None)
+    field = data.get("image_uri", None)
     if field is not None:
-        args["id"] = field
+        args["image_uri"] = field
 
-    field = data.get("url", None)
+    field = data.get("command", None)
     if field is not None:
-        args["url"] = field
+        args["command"] = field
 
-    field = data.get("size", None)
+    field = data.get("project_id", None)
     if field is not None:
-        args["size"] = field
+        args["project_id"] = field
 
-    field = data.get("progress", None)
+    field = data.get("created_at", None)
     if field is not None:
-        args["progress"] = field
-
-    return PinInfo(**args)
-
-
-def unmarshal_Pin(data: Any) -> Pin:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Pin' failed as data isn't a dictionary."
-        )
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
-    args: Dict[str, Any] = {}
+    field = data.get("updated_at", None)
+    if field is not None:
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
-    field = data.get("pin_id", None)
+    field = data.get("environment_variables", None)
     if field is not None:
-        args["pin_id"] = field
+        args["environment_variables"] = field
 
-    field = data.get("status", None)
+    field = data.get("description", None)
     if field is not None:
-        args["status"] = field
+        args["description"] = field
 
-    field = data.get("delegates", None)
+    field = data.get("local_storage_capacity", None)
     if field is not None:
-        args["delegates"] = field
+        args["local_storage_capacity"] = field
 
-    field = data.get("created_at", None)
+    field = data.get("region", None)
     if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["region"] = field
 
-    field = data.get("cid", None)
+    field = data.get("job_timeout", None)
     if field is not None:
-        args["cid"] = unmarshal_PinCID(field)
+        args["job_timeout"] = field
+    else:
+        args["job_timeout"] = None
 
-    field = data.get("info", None)
+    field = data.get("cron_schedule", None)
     if field is not None:
-        args["info"] = unmarshal_PinInfo(field)
+        args["cron_schedule"] = unmarshal_CronSchedule(field)
+    else:
+        args["cron_schedule"] = None
 
-    return Pin(**args)
+    return JobDefinition(**args)
 
 
-def unmarshal_Volume(data: Any) -> Volume:
+def unmarshal_JobRun(data: Any) -> JobRun:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Volume' failed as data isn't a dictionary."
+            "Unmarshalling the type 'JobRun' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("project_id", None)
+    field = data.get("job_definition_id", None)
     if field is not None:
-        args["project_id"] = field
+        args["job_definition_id"] = field
 
-    field = data.get("region", None)
+    field = data.get("state", None)
     if field is not None:
-        args["region"] = field
+        args["state"] = field
 
-    field = data.get("count_pin", None)
+    field = data.get("error_message", None)
     if field is not None:
-        args["count_pin"] = field
+        args["error_message"] = field
 
-    field = data.get("tags", None)
+    field = data.get("cpu_limit", None)
     if field is not None:
-        args["tags"] = field
+        args["cpu_limit"] = field
 
-    field = data.get("name", None)
+    field = data.get("memory_limit", None)
     if field is not None:
-        args["name"] = field
+        args["memory_limit"] = field
+
+    field = data.get("command", None)
+    if field is not None:
+        args["command"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
-    field = data.get("size", None)
+    field = data.get("terminated_at", None)
     if field is not None:
-        args["size"] = field
-
-    return Volume(**args)
-
-
-def unmarshal_ExportKeyNameResponse(data: Any) -> ExportKeyNameResponse:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'ExportKeyNameResponse' failed as data isn't a dictionary."
+        args["terminated_at"] = (
+            parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["terminated_at"] = None
 
-    args: Dict[str, Any] = {}
-
-    field = data.get("name_id", None)
+    field = data.get("exit_code", None)
     if field is not None:
-        args["name_id"] = field
+        args["exit_code"] = field
+    else:
+        args["exit_code"] = None
 
-    field = data.get("project_id", None)
+    field = data.get("run_duration", None)
     if field is not None:
-        args["project_id"] = field
+        args["run_duration"] = field
+    else:
+        args["run_duration"] = None
 
-    field = data.get("public_key", None)
+    field = data.get("environment_variables", None)
     if field is not None:
-        args["public_key"] = field
+        args["environment_variables"] = field
 
-    field = data.get("private_key", None)
+    field = data.get("local_storage_capacity", None)
     if field is not None:
-        args["private_key"] = field
+        args["local_storage_capacity"] = field
 
-    field = data.get("created_at", None)
+    field = data.get("region", None)
     if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["region"] = field
 
-    field = data.get("updated_at", None)
+    field = data.get("started_at", None)
     if field is not None:
-        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["started_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["started_at"] = None
 
-    return ExportKeyNameResponse(**args)
+    return JobRun(**args)
 
 
-def unmarshal_ListNamesResponse(data: Any) -> ListNamesResponse:
+def unmarshal_ListJobDefinitionsResponse(data: Any) -> ListJobDefinitionsResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListNamesResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListJobDefinitionsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("names", None)
+    field = data.get("job_definitions", None)
     if field is not None:
-        args["names"] = (
-            [unmarshal_Name(v) for v in field] if field is not None else None
+        args["job_definitions"] = (
+            [unmarshal_JobDefinition(v) for v in field] if field is not None else None
         )
 
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    return ListNamesResponse(**args)
+    return ListJobDefinitionsResponse(**args)
 
 
-def unmarshal_ListPinsResponse(data: Any) -> ListPinsResponse:
+def unmarshal_ListJobRunsResponse(data: Any) -> ListJobRunsResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListPinsResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListJobRunsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count", None)
+    field = data.get("job_runs", None)
     if field is not None:
-        args["total_count"] = field
-
-    field = data.get("pins", None)
-    if field is not None:
-        args["pins"] = [unmarshal_Pin(v) for v in field] if field is not None else None
-
-    return ListPinsResponse(**args)
-
-
-def unmarshal_ListVolumesResponse(data: Any) -> ListVolumesResponse:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'ListVolumesResponse' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("volumes", None)
-    if field is not None:
-        args["volumes"] = (
-            [unmarshal_Volume(v) for v in field] if field is not None else None
+        args["job_runs"] = (
+            [unmarshal_JobRun(v) for v in field] if field is not None else None
         )
 
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    return ListVolumesResponse(**args)
+    return ListJobRunsResponse(**args)
 
 
-def unmarshal_ReplacePinResponse(data: Any) -> ReplacePinResponse:
+def unmarshal_StartJobDefinitionResponse(data: Any) -> StartJobDefinitionResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ReplacePinResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'StartJobDefinitionResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("pin", None)
+    field = data.get("job_runs", None)
     if field is not None:
-        args["pin"] = unmarshal_Pin(field)
+        args["job_runs"] = (
+            [unmarshal_JobRun(v) for v in field] if field is not None else None
+        )
 
-    return ReplacePinResponse(**args)
+    return StartJobDefinitionResponse(**args)
 
 
-def marshal_CreatePinByCIDRequest(
-    request: CreatePinByCIDRequest,
+def marshal_CreateJobDefinitionRequestCronScheduleConfig(
+    request: CreateJobDefinitionRequestCronScheduleConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.volume_id is not None:
-        output["volume_id"] = request.volume_id
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
 
-    if request.cid is not None:
-        output["cid"] = request.cid
-
-    if request.origins is not None:
-        output["origins"] = request.origins
-
-    if request.name is not None:
-        output["name"] = request.name
+    if request.timezone is not None:
+        output["timezone"] = request.timezone
 
     return output
 
 
-def marshal_CreatePinByURLRequest(
-    request: CreatePinByURLRequest,
+def marshal_CreateJobDefinitionRequest(
+    request: CreateJobDefinitionRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.volume_id is not None:
-        output["volume_id"] = request.volume_id
+    if request.cpu_limit is not None:
+        output["cpu_limit"] = request.cpu_limit
 
-    if request.url is not None:
-        output["url"] = request.url
+    if request.memory_limit is not None:
+        output["memory_limit"] = request.memory_limit
 
-    if request.name is not None:
-        output["name"] = request.name
-
-    return output
+    if request.image_uri is not None:
+        output["image_uri"] = request.image_uri
 
+    if request.command is not None:
+        output["command"] = request.command
 
-def marshal_CreateVolumeRequest(
-    request: CreateVolumeRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
+    if request.description is not None:
+        output["description"] = request.description
 
     if request.name is not None:
         output["name"] = request.name
 
+    if request.local_storage_capacity is not None:
+        output["local_storage_capacity"] = request.local_storage_capacity
+
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
+    if request.environment_variables is not None:
+        output["environment_variables"] = {
+            key: value for key, value in request.environment_variables.items()
+        }
+
+    if request.job_timeout is not None:
+        output["job_timeout"] = request.job_timeout
+
+    if request.cron_schedule is not None:
+        output["cron_schedule"] = (
+            marshal_CreateJobDefinitionRequestCronScheduleConfig(
+                request.cron_schedule, defaults
+            ),
+        )
+
     return output
 
 
-def marshal_IpnsApiCreateNameRequest(
-    request: IpnsApiCreateNameRequest,
+def marshal_StartJobDefinitionRequest(
+    request: StartJobDefinitionRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.name is not None:
-        output["name"] = request.name
+    if request.command is not None:
+        output["command"] = request.command
 
-    if request.value is not None:
-        output["value"] = request.value
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
 
-    if request.project_id is not None:
-        output["project_id"] = request.project_id or defaults.default_project_id
+    if request.replicas is not None:
+        output["replicas"] = request.replicas
 
     return output
 
 
-def marshal_IpnsApiImportKeyNameRequest(
-    request: IpnsApiImportKeyNameRequest,
+def marshal_UpdateJobDefinitionRequestCronScheduleConfig(
+    request: UpdateJobDefinitionRequestCronScheduleConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.name is not None:
-        output["name"] = request.name
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
 
-    if request.private_key is not None:
-        output["private_key"] = request.private_key
-
-    if request.value is not None:
-        output["value"] = request.value
-
-    if request.project_id is not None:
-        output["project_id"] = request.project_id or defaults.default_project_id
+    if request.timezone is not None:
+        output["timezone"] = request.timezone
 
     return output
 
 
-def marshal_IpnsApiUpdateNameRequest(
-    request: IpnsApiUpdateNameRequest,
+def marshal_UpdateJobDefinitionRequest(
+    request: UpdateJobDefinitionRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.name is not None:
         output["name"] = request.name
 
-    if request.tags is not None:
-        output["tags"] = request.tags
+    if request.cpu_limit is not None:
+        output["cpu_limit"] = request.cpu_limit
 
-    if request.value is not None:
-        output["value"] = request.value
+    if request.memory_limit is not None:
+        output["memory_limit"] = request.memory_limit
 
-    return output
-
-
-def marshal_ReplacePinRequest(
-    request: ReplacePinRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
-
-    if request.volume_id is not None:
-        output["volume_id"] = request.volume_id
-
-    if request.cid is not None:
-        output["cid"] = request.cid
-
-    if request.name is not None:
-        output["name"] = request.name
+    if request.local_storage_capacity is not None:
+        output["local_storage_capacity"] = request.local_storage_capacity
 
-    if request.origins is not None:
-        output["origins"] = request.origins
+    if request.image_uri is not None:
+        output["image_uri"] = request.image_uri
 
-    return output
+    if request.command is not None:
+        output["command"] = request.command
 
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
 
-def marshal_UpdateVolumeRequest(
-    request: UpdateVolumeRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
+    if request.description is not None:
+        output["description"] = request.description
 
-    if request.name is not None:
-        output["name"] = request.name
+    if request.job_timeout is not None:
+        output["job_timeout"] = request.job_timeout
 
-    if request.tags is not None:
-        output["tags"] = request.tags
+    if request.cron_schedule is not None:
+        output["cron_schedule"] = (
+            marshal_UpdateJobDefinitionRequestCronScheduleConfig(
+                request.cron_schedule, defaults
+            ),
+        )
 
     return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/ipfs/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/webhosting/v1alpha1/types.py`

 * *Files 24% similar despite different names*

```diff
@@ -4,629 +4,717 @@
 
 from dataclasses import dataclass
 from datetime import datetime
 from enum import Enum
 from typing import List, Optional
 
 from scaleway_core.bridge import (
+    Money,
     Region,
 )
 from scaleway_core.utils import (
     StrEnumMeta,
 )
 
+from ...std.types import (
+    LanguageCode as StdLanguageCode,
+)
 
-class ListNamesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
+
+class DnsRecordStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_STATUS = "unknown_status"
+    VALID = "valid"
+    INVALID = "invalid"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListPinsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
+class DnsRecordType(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_TYPE = "unknown_type"
+    A = "a"
+    CNAME = "cname"
+    MX = "mx"
+    TXT = "txt"
+    NS = "ns"
+    AAAA = "aaaa"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListVolumesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
+class DnsRecordsStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN = "unknown"
+    VALID = "valid"
+    INVALID = "invalid"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class NameStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_STATUS = "unknown_status"
-    QUEUED = "queued"
-    PUBLISHING = "publishing"
-    FAILED = "failed"
-    PUBLISHED = "published"
+class HostingDnsStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_DNS_STATUS = "unknown_dns_status"
+    VALID = "valid"
+    INVALID = "invalid"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class PinDetails(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_DETAILS = "unknown_details"
-    PINNING_LOOKING_FOR_PROVIDER = "pinning_looking_for_provider"
-    PINNING_IN_PROGRESS = "pinning_in_progress"
-    PINNING_BLOCKS_FETCHED = "pinning_blocks_fetched"
-    PINNING_FETCHING_URL_DATA = "pinning_fetching_url_data"
-    PINNED_OK = "pinned_ok"
-    UNPINNED_OK = "unpinned_ok"
-    UNPINNING_IN_PROGRESS = "unpinning_in_progress"
-    FAILED_CONTAINS_BANNED_CID = "failed_contains_banned_cid"
-    FAILED_PINNING = "failed_pinning"
-    FAILED_PINNING_NO_PROVIDER = "failed_pinning_no_provider"
-    FAILED_PINNING_BAD_CID_FORMAT = "failed_pinning_bad_cid_format"
-    FAILED_PINNING_TIMEOUT = "failed_pinning_timeout"
-    FAILED_PINNING_TOO_BIG_CONTENT = "failed_pinning_too_big_content"
-    FAILED_PINNING_UNREACHABLE_URL = "failed_pinning_unreachable_url"
-    FAILED_PINNING_BAD_URL_FORMAT = "failed_pinning_bad_url_format"
-    FAILED_PINNING_NO_URL_CONTENT_LENGTH = "failed_pinning_no_url_content_length"
-    FAILED_PINNING_BAD_URL_STATUS_CODE = "failed_pinning_bad_url_status_code"
-    FAILED_UNPINNING = "failed_unpinning"
-    CHECKING_COHERENCE = "checking_coherence"
-    RESCHEDULED = "rescheduled"
+class HostingStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_STATUS = "unknown_status"
+    DELIVERING = "delivering"
+    READY = "ready"
+    DELETING = "deleting"
+    ERROR = "error"
+    LOCKED = "locked"
+    MIGRATING = "migrating"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class PinStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_STATUS = "unknown_status"
-    QUEUED = "queued"
-    PINNING = "pinning"
-    FAILED = "failed"
-    PINNED = "pinned"
+class ListHostingsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-@dataclass
-class PinCIDMeta:
-    id: Optional[str]
-
+class ListOffersRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    PRICE_ASC = "price_asc"
 
-@dataclass
-class PinCID:
-    origins: List[str]
+    def __str__(self) -> str:
+        return str(self.value)
 
-    cid: Optional[str]
 
-    name: Optional[str]
+class NameserverStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_STATUS = "unknown_status"
+    VALID = "valid"
+    INVALID = "invalid"
 
-    meta: Optional[PinCIDMeta]
+    def __str__(self) -> str:
+        return str(self.value)
 
 
-@dataclass
-class PinInfo:
-    status_details: PinDetails
+class OfferQuotaWarning(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_QUOTA_WARNING = "unknown_quota_warning"
+    EMAIL_COUNT_EXCEEDED = "email_count_exceeded"
+    DATABASE_COUNT_EXCEEDED = "database_count_exceeded"
+    DISK_USAGE_EXCEEDED = "disk_usage_exceeded"
 
-    id: Optional[str]
+    def __str__(self) -> str:
+        return str(self.value)
 
-    url: Optional[str]
 
-    size: Optional[int]
+@dataclass
+class HostingCpanelUrls:
+    dashboard: str
 
-    progress: Optional[int]
+    webmail: str
 
 
 @dataclass
-class Name:
-    name_id: str
-
-    project_id: str
-
-    tags: List[str]
+class HostingOption:
+    id: str
+    """
+    Option ID.
+    """
 
     name: str
-
-    key: str
-
-    status: NameStatus
-
-    value: str
-
-    region: Region
     """
-    Region to target. If none is passed will use default region from the config.
+    Option name.
     """
 
-    created_at: Optional[datetime]
-
-    updated_at: Optional[datetime]
-
 
 @dataclass
-class Pin:
-    pin_id: str
-
-    status: PinStatus
+class OfferProduct:
+    name: str
+    """
+    Product name.
+    """
 
-    delegates: List[str]
+    option: bool
+    """
+    Product option.
+    """
 
-    created_at: Optional[datetime]
+    email_accounts_quota: int
+    """
+    Limit number of email accounts.
+    """
 
-    cid: Optional[PinCID]
+    email_storage_quota: int
+    """
+    Limit quantity of email storage in gigabytes.
+    """
 
-    info: Optional[PinInfo]
+    databases_quota: int
+    """
+    Limit number of databases.
+    """
 
+    hosting_storage_quota: int
+    """
+    Limit quantity of hosting storage in gigabytes.
+    """
 
-@dataclass
-class Volume:
-    id: str
+    support_included: bool
+    """
+    Whether or not support is included.
+    """
 
-    project_id: str
+    v_cpu: int
+    """
+    Limit number of virtual CPU.
+    """
 
-    region: Region
+    ram: int
     """
-    Region to target. If none is passed will use default region from the config.
+    Limit quantity of memory in gigabytes.
     """
 
-    count_pin: int
+    max_addon_domains: int
+    """
+    Limit number of add-on domains.
+    """
 
-    tags: List[str]
 
-    name: str
+@dataclass
+class CreateHostingRequestDomainConfiguration:
+    update_nameservers: bool
 
-    created_at: Optional[datetime]
+    update_web_record: bool
 
-    updated_at: Optional[datetime]
+    update_mail_record: bool
 
-    size: Optional[int]
+    update_all_records: bool
 
 
 @dataclass
-class CreatePinByCIDRequest:
-    volume_id: str
+class DnsRecord:
+    name: str
     """
-    Volume ID on which you want to pin your content.
+    Record name.
     """
 
-    cid: str
+    type_: DnsRecordType
     """
-    CID containing the content you want to pin.
+    Record type.
     """
 
-    region: Optional[Region]
+    ttl: int
     """
-    Region to target. If none is passed will use default region from the config.
+    Record time-to-live.
     """
 
-    origins: Optional[List[str]]
+    value: str
     """
-    Node containing the content you want to pin.
+    Record value.
     """
 
-    name: Optional[str]
+    status: DnsRecordStatus
     """
-    Pin name.
+    Record status.
     """
 
-
-@dataclass
-class CreatePinByURLRequest:
-    volume_id: str
+    priority: Optional[int]
     """
-    Volume ID on which you want to pin your content.
+    Record priority level.
     """
 
-    url: str
+
+@dataclass
+class Nameserver:
+    hostname: str
     """
-    URL containing the content you want to pin.
+    Hostname of the nameserver.
     """
 
-    region: Optional[Region]
+    status: NameserverStatus
     """
-    Region to target. If none is passed will use default region from the config.
+    Status of the nameserver.
     """
 
-    name: Optional[str]
+    is_default: bool
     """
-    Pin name.
+    Defines whether the nameserver is the default one.
     """
 
 
 @dataclass
-class CreateVolumeRequest:
+class ControlPanel:
     name: str
     """
-    Volume name.
+    Control panel name.
     """
 
-    region: Optional[Region]
+    available: bool
     """
-    Region to target. If none is passed will use default region from the config.
+    Define if the control panel type is available to order.
     """
 
-    project_id: Optional[str]
+    logo_url: str
     """
-    Project ID.
+    URL of this control panel's logo.
     """
 
 
 @dataclass
-class DeletePinRequest:
-    volume_id: str
+class Hosting:
+    id: str
     """
-    Volume ID.
+    ID of the Web Hosting plan.
     """
 
-    pin_id: str
+    organization_id: str
     """
-    Pin ID you want to remove from the volume.
+    ID of the Scaleway Organization the Web Hosting plan belongs to.
     """
 
-    region: Optional[Region]
+    project_id: str
     """
-    Region to target. If none is passed will use default region from the config.
+    ID of the Scaleway Project the Web Hosting plan belongs to.
     """
 
-
-@dataclass
-class DeleteVolumeRequest:
-    volume_id: str
+    status: HostingStatus
     """
-    Volume ID.
+    Status of the Web Hosting plan.
     """
 
-    region: Optional[Region]
+    platform_hostname: str
     """
-    Region to target. If none is passed will use default region from the config.
+    Hostname of the host platform.
     """
 
+    offer_id: str
+    """
+    ID of the active offer for the Web Hosting plan.
+    """
 
-@dataclass
-class ExportKeyNameResponse:
-    name_id: str
-
-    project_id: str
-
-    public_key: str
+    offer_name: str
+    """
+    Name of the active offer for the Web Hosting plan.
+    """
 
-    private_key: str
+    domain: str
+    """
+    Main domain associated with the Web Hosting plan.
+    """
 
-    created_at: Optional[datetime]
+    tags: List[str]
+    """
+    List of tags associated with the Web Hosting plan.
+    """
 
     updated_at: Optional[datetime]
-
-
-@dataclass
-class GetPinRequest:
-    volume_id: str
     """
-    Volume ID.
+    Date on which the Web Hosting plan was last updated.
     """
 
-    pin_id: str
+    created_at: Optional[datetime]
     """
-    Pin ID of which you want to obtain information.
+    Date on which the Web Hosting plan was created.
     """
 
-    region: Optional[Region]
+    platform_number: Optional[int]
     """
-    Region to target. If none is passed will use default region from the config.
+    Number of the host platform.
     """
 
-
-@dataclass
-class GetVolumeRequest:
-    volume_id: str
+    options: List[HostingOption]
     """
-    Volume ID.
+    Array of any options activated for the Web Hosting plan.
     """
 
-    region: Optional[Region]
+    dns_status: HostingDnsStatus
     """
-    Region to target. If none is passed will use default region from the config.
+    DNS status of the Web Hosting plan.
     """
 
-
-@dataclass
-class IpnsApiCreateNameRequest:
-    name: str
+    username: str
     """
-    Name for your records.
+    Main Web Hosting cPanel username.
     """
 
-    value: str
+    offer_end_of_life: bool
     """
-    Value you want to associate with your records, CID or IPNS key.
+    Indicates if the hosting offer has reached its end of life.
     """
 
-    region: Optional[Region]
+    control_panel_name: str
     """
-    Region to target. If none is passed will use default region from the config.
+    Name of the control panel.
     """
 
-    project_id: Optional[str]
+    platform_group: str
     """
-    Project ID.
+    Group of the hosting's host server/platform.
     """
 
+    ipv4: str
+    """
+    IPv4 address of the hosting's host server.
+    """
 
-@dataclass
-class IpnsApiDeleteNameRequest:
-    name_id: str
+    ipv6: str
     """
-    Name ID you wish to delete.
+    IPv6 address of the hosting's host server.
     """
 
-    region: Optional[Region]
+    protected: bool
     """
-    Region to target. If none is passed will use default region from the config.
+    Whether the hosting is protected or not.
     """
 
+    one_time_password: str
+    """
+    One-time-password used for the first login or reset password, empty after first use.
+    """
 
-@dataclass
-class IpnsApiExportKeyNameRequest:
-    name_id: str
+    region: Region
     """
-    Name ID whose keys you want to export.
+    Region where the Web Hosting plan is hosted.
     """
 
-    region: Optional[Region]
+    cpanel_urls: Optional[HostingCpanelUrls]
     """
-    Region to target. If none is passed will use default region from the config.
+    URL to connect to cPanel dashboard and to Webmail interface.
     """
 
 
 @dataclass
-class IpnsApiGetNameRequest:
-    name_id: str
+class Offer:
+    id: str
     """
-    Name ID whose information you want to retrieve.
+    Offer ID.
     """
 
-    region: Optional[Region]
+    billing_operation_path: str
     """
-    Region to target. If none is passed will use default region from the config.
+    Unique identifier used for billing.
     """
 
+    available: bool
+    """
+    If a hosting_id was specified in the call, defines whether this offer is available for that Web Hosting plan to migrate (update) to.
+    """
 
-@dataclass
-class IpnsApiImportKeyNameRequest:
-    name: str
+    quota_warnings: List[OfferQuotaWarning]
     """
-    Name for your records.
+    Quota warnings, if the offer is not available for the specified hosting_id.
     """
 
-    private_key: str
+    end_of_life: bool
     """
-    Base64 private key.
+    Indicates if the offer has reached its end of life.
     """
 
-    value: str
+    control_panel_name: str
     """
-    Value you want to associate with your records, CID or IPNS key.
+    Name of the control panel.
     """
 
-    region: Optional[Region]
+    product: Optional[OfferProduct]
     """
-    Region to target. If none is passed will use default region from the config.
+    Product constituting this offer.
     """
 
-    project_id: Optional[str]
+    price: Optional[Money]
     """
-    Project ID.
+    Price of this offer.
     """
 
 
 @dataclass
-class IpnsApiListNamesRequest:
+class CreateHostingRequest:
+    offer_id: str
+    """
+    ID of the selected offer for the Web Hosting plan.
+    """
+
+    domain: str
+    """
+    Domain name to link to the Web Hosting plan. You must already own this domain name, and have completed the DNS validation process beforehand.
+    """
+
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
     project_id: Optional[str]
     """
-    Project ID.
+    ID of the Scaleway Project in which to create the Web Hosting plan.
     """
 
-    organization_id: Optional[str]
+    email: Optional[str]
     """
-    Organization ID.
+    Contact email for the Web Hosting client.
     """
 
-    order_by: Optional[ListNamesRequestOrderBy]
+    tags: Optional[List[str]]
     """
-    Sort the order of the returned names.
+    List of tags for the Web Hosting plan.
     """
 
-    page: Optional[int]
+    option_ids: Optional[List[str]]
     """
-    Page number.
+    IDs of any selected additional options for the Web Hosting plan.
     """
 
-    page_size: Optional[int]
+    language: Optional[StdLanguageCode]
+    """
+    Default language for the control panel interface.
+    """
+
+    domain_configuration: Optional[CreateHostingRequestDomainConfiguration]
     """
-    Maximum number of names to return per page.
+    Indicates whether to update hosting domain name servers and DNS records for domains managed by Scaleway Elements.
     """
 
 
 @dataclass
-class IpnsApiUpdateNameRequest:
-    name_id: str
+class DeleteHostingRequest:
+    hosting_id: str
     """
-    Name ID you wish to update.
+    Hosting ID.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+
+@dataclass
+class DnsRecords:
+    records: List[DnsRecord]
     """
-    New name you want to associate with your record.
+    List of DNS records.
     """
 
-    tags: Optional[List[str]]
+    name_servers: List[Nameserver]
     """
-    New tags you want to associate with your record.
+    List of nameservers.
     """
 
-    value: Optional[str]
+    status: DnsRecordsStatus
     """
-    Value you want to associate with your records, CID or IPNS key.
+    Status of the records.
     """
 
 
 @dataclass
-class ListNamesResponse:
-    names: List[Name]
-
-    total_count: int
-
-
-@dataclass
-class ListPinsRequest:
-    volume_id: str
+class GetDomainDnsRecordsRequest:
+    domain: str
     """
-    Volume ID of which you want to list the pins.
+    Domain associated with the DNS records.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    project_id: Optional[str]
+
+@dataclass
+class GetHostingRequest:
+    hosting_id: str
     """
-    Project ID.
+    Hosting ID.
     """
 
-    organization_id: Optional[str]
+    region: Optional[Region]
     """
-    Organization ID.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    order_by: Optional[ListPinsRequestOrderBy]
+
+@dataclass
+class ListControlPanelsRequest:
+    region: Optional[Region]
     """
-    Sort order of the returned Volume.
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    Page number.
+    Page number to return, from the paginated results (must be a positive integer).
     """
 
     page_size: Optional[int]
     """
-    Maximum number of volumes to return per page.
-    """
-
-    status: Optional[PinStatus]
-    """
-    List pins by status.
+    Number of control panels to return (must be a positive integer lower or equal to 100).
     """
 
 
 @dataclass
-class ListPinsResponse:
+class ListControlPanelsResponse:
     total_count: int
+    """
+    Number of control panels returned.
+    """
 
-    pins: List[Pin]
+    control_panels: List[ControlPanel]
+    """
+    List of control panels.
+    """
 
 
 @dataclass
-class ListVolumesRequest:
+class ListHostingsRequest:
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    project_id: Optional[str]
+    page: Optional[int]
     """
-    Project ID, only volumes belonging to this project will be listed.
+    Page number to return, from the paginated results (must be a positive integer).
     """
 
-    order_by: Optional[ListVolumesRequestOrderBy]
+    page_size: Optional[int]
     """
-    Sort the order of the returned volumes.
+    Number of Web Hosting plans to return (must be a positive integer lower or equal to 100).
     """
 
-    page: Optional[int]
+    order_by: Optional[ListHostingsRequestOrderBy]
     """
-    Page number.
+    Sort order for Web Hosting plans in the response.
     """
 
-    page_size: Optional[int]
+    tags: Optional[List[str]]
+    """
+    Tags to filter for, only Web Hosting plans with matching tags will be returned.
+    """
+
+    statuses: Optional[List[HostingStatus]]
     """
-    Maximum number of volumes to return per page.
+    Statuses to filter for, only Web Hosting plans with matching statuses will be returned.
     """
 
+    domain: Optional[str]
+    """
+    Domain to filter for, only Web Hosting plans associated with this domain will be returned.
+    """
 
-@dataclass
-class ListVolumesResponse:
-    volumes: List[Volume]
+    project_id: Optional[str]
+    """
+    Project ID to filter for, only Web Hosting plans from this Project will be returned.
+    """
 
-    total_count: int
+    organization_id: Optional[str]
+    """
+    Organization ID to filter for, only Web Hosting plans from this Organization will be returned.
+    """
+
+    control_panels: Optional[List[str]]
+    """
+    Name of the control panel to filter for, only Web Hosting plans from this control panel will be returned.
+    """
 
 
 @dataclass
-class ReplacePinRequest:
-    volume_id: str
+class ListHostingsResponse:
+    total_count: int
     """
-    Volume ID.
+    Number of Web Hosting plans returned.
     """
 
-    pin_id: str
+    hostings: List[Hosting]
     """
-    Pin ID whose information you wish to replace.
+    List of Web Hosting plans.
     """
 
-    cid: str
+
+@dataclass
+class ListOffersRequest:
+    without_options: bool
+    """
+    Defines whether the response should consist of offers only, without options.
+    """
+
+    only_options: bool
     """
-    New CID you want to pin in place of the old one.
+    Defines whether the response should consist of options only, without offers.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+    order_by: Optional[ListOffersRequestOrderBy]
+    """
+    Sort order of offers in the response.
+    """
+
+    hosting_id: Optional[str]
     """
-    New name to replace.
+    ID of a Web Hosting plan, to check compatibility with returned offers (in case of wanting to update the plan).
     """
 
-    origins: Optional[List[str]]
+    control_panels: Optional[List[str]]
     """
-    Node containing the content you want to pin.
+    Name of the control panel to filter for.
     """
 
 
 @dataclass
-class ReplacePinResponse:
-    pin: Optional[Pin]
+class ListOffersResponse:
+    offers: List[Offer]
+    """
+    List of offers.
+    """
 
 
 @dataclass
-class UpdateVolumeRequest:
-    volume_id: str
+class RestoreHostingRequest:
+    hosting_id: str
     """
-    Volume ID.
+    Hosting ID.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+
+@dataclass
+class UpdateHostingRequest:
+    hosting_id: str
     """
-    Volume name.
+    Hosting ID.
+    """
+
+    region: Optional[Region]
+    """
+    Region to target. If none is passed will use default region from the config.
+    """
+
+    email: Optional[str]
+    """
+    New contact email for the Web Hosting plan.
     """
 
     tags: Optional[List[str]]
     """
-    Tags of the volume.
+    New tags for the Web Hosting plan.
+    """
+
+    option_ids: Optional[List[str]]
+    """
+    IDs of the new options for the Web Hosting plan.
+    """
+
+    offer_id: Optional[str]
+    """
+    ID of the new offer for the Web Hosting plan.
+    """
+
+    protected: Optional[bool]
+    """
+    Whether the hosting is protected or not.
     """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/jobs/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/jobs/v1alpha1/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,43 +1,49 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import JobRunState
-from .content import JOBRUN_TRANSIENT_STATUSES
+from .content import JOB_RUN_TRANSIENT_STATUSES
 from .types import ListJobDefinitionsRequestOrderBy
 from .types import ListJobRunsRequestOrderBy
+from .types import CronSchedule
+from .types import CreateJobDefinitionRequestCronScheduleConfig
 from .types import JobDefinition
 from .types import JobRun
+from .types import UpdateJobDefinitionRequestCronScheduleConfig
 from .types import CreateJobDefinitionRequest
 from .types import DeleteJobDefinitionRequest
 from .types import GetJobDefinitionRequest
 from .types import GetJobRunRequest
-from .types import GetServiceInfoRequest
 from .types import ListJobDefinitionsRequest
 from .types import ListJobDefinitionsResponse
 from .types import ListJobRunsRequest
 from .types import ListJobRunsResponse
 from .types import StartJobDefinitionRequest
+from .types import StartJobDefinitionResponse
 from .types import StopJobRunRequest
 from .types import UpdateJobDefinitionRequest
 from .api import JobsV1Alpha1API
 
 __all__ = [
     "JobRunState",
-    "JOBRUN_TRANSIENT_STATUSES",
+    "JOB_RUN_TRANSIENT_STATUSES",
     "ListJobDefinitionsRequestOrderBy",
     "ListJobRunsRequestOrderBy",
+    "CronSchedule",
+    "CreateJobDefinitionRequestCronScheduleConfig",
     "JobDefinition",
     "JobRun",
+    "UpdateJobDefinitionRequestCronScheduleConfig",
     "CreateJobDefinitionRequest",
     "DeleteJobDefinitionRequest",
     "GetJobDefinitionRequest",
     "GetJobRunRequest",
-    "GetServiceInfoRequest",
     "ListJobDefinitionsRequest",
     "ListJobDefinitionsResponse",
     "ListJobRunsRequest",
     "ListJobRunsResponse",
     "StartJobDefinitionRequest",
+    "StartJobDefinitionResponse",
     "StopJobRunRequest",
     "UpdateJobDefinitionRequest",
     "JobsV1Alpha1API",
 ]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/jobs/v1alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/jobs/v1alpha1/api.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,99 +2,81 @@
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Dict, List, Optional
 
 from scaleway_core.api import API
 from scaleway_core.bridge import (
     Region,
-    ServiceInfo,
-    unmarshal_ServiceInfo,
 )
 from scaleway_core.utils import (
     random_name,
     validate_path_param,
     fetch_all_pages_async,
 )
 from .types import (
     ListJobDefinitionsRequestOrderBy,
     ListJobRunsRequestOrderBy,
     CreateJobDefinitionRequest,
+    CreateJobDefinitionRequestCronScheduleConfig,
     JobDefinition,
     JobRun,
     ListJobDefinitionsResponse,
     ListJobRunsResponse,
+    StartJobDefinitionRequest,
+    StartJobDefinitionResponse,
     UpdateJobDefinitionRequest,
+    UpdateJobDefinitionRequestCronScheduleConfig,
 )
 from .marshalling import (
     unmarshal_JobDefinition,
     unmarshal_JobRun,
     unmarshal_ListJobDefinitionsResponse,
     unmarshal_ListJobRunsResponse,
+    unmarshal_StartJobDefinitionResponse,
     marshal_CreateJobDefinitionRequest,
+    marshal_StartJobDefinitionRequest,
     marshal_UpdateJobDefinitionRequest,
 )
 
 
 class JobsV1Alpha1API(API):
     """
     Serverless Jobs API.
     """
 
-    async def get_service_info(
-        self,
-        *,
-        region: Optional[Region] = None,
-    ) -> ServiceInfo:
-        """
-        :param region: Region to target. If none is passed will use default region from the config.
-        :return: :class:`ServiceInfo <ServiceInfo>`
-
-        Usage:
-        ::
-
-            result = await api.get_service_info()
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-
-        res = self._request(
-            "GET",
-            f"/serverless-jobs/v1alpha1/regions/{param_region}",
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_ServiceInfo(res.json())
-
     async def create_job_definition(
         self,
         *,
         cpu_limit: int,
         memory_limit: int,
         image_uri: str,
         command: str,
         description: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
+        local_storage_capacity: Optional[int] = None,
         project_id: Optional[str] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         job_timeout: Optional[str] = None,
+        cron_schedule: Optional[CreateJobDefinitionRequestCronScheduleConfig] = None,
     ) -> JobDefinition:
         """
-        :param cpu_limit:
-        :param memory_limit:
-        :param image_uri:
-        :param command:
-        :param description:
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param name:
-        :param project_id:
-        :param environment_variables:
-        :param job_timeout:
+        Create a new job definition in a specified Project.
+        :param cpu_limit: CPU limit of the job.
+        :param memory_limit: Memory limit of the job (in MiB).
+        :param image_uri: Image to use for the job.
+        :param command: Startup command. If empty or not defined, the image's default command is used.
+        :param description: Description of the job.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Name of the job definition.
+        :param local_storage_capacity: Local storage capacity of the job (in MiB).
+        :param project_id: UUID of the Scaleway Project containing the job.
+        :param environment_variables: Environment variables of the job.
+        :param job_timeout: Timeout of the job in seconds.
+        :param cron_schedule:
         :return: :class:`JobDefinition <JobDefinition>`
 
         Usage:
         ::
 
             result = await api.create_job_definition(
                 cpu_limit=1,
@@ -117,72 +99,80 @@
                     cpu_limit=cpu_limit,
                     memory_limit=memory_limit,
                     image_uri=image_uri,
                     command=command,
                     description=description,
                     region=region,
                     name=name or random_name(prefix="job"),
+                    local_storage_capacity=local_storage_capacity,
                     project_id=project_id,
                     environment_variables=environment_variables,
                     job_timeout=job_timeout,
+                    cron_schedule=cron_schedule,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_JobDefinition(res.json())
 
     async def get_job_definition(
         self,
         *,
-        id: str,
+        job_definition_id: str,
         region: Optional[Region] = None,
     ) -> JobDefinition:
         """
-        :param id:
+        Get a job definition by its unique identifier.
+        :param job_definition_id: UUID of the job definition to get.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`JobDefinition <JobDefinition>`
 
         Usage:
         ::
 
             result = await api.get_job_definition(
-                id="example",
+                job_definition_id="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_id = validate_path_param("id", id)
+        param_job_definition_id = validate_path_param(
+            "job_definition_id", job_definition_id
+        )
 
         res = self._request(
             "GET",
-            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-definitions/{param_id}",
+            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-definitions/{param_job_definition_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_JobDefinition(res.json())
 
     async def list_job_definitions(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListJobDefinitionsRequestOrderBy] = None,
         project_id: Optional[str] = None,
+        organization_id: Optional[str] = None,
     ) -> ListJobDefinitionsResponse:
         """
+        List all your job definitions with filters.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page:
         :param page_size:
         :param order_by:
         :param project_id:
+        :param organization_id:
         :return: :class:`ListJobDefinitionsResponse <ListJobDefinitionsResponse>`
 
         Usage:
         ::
 
             result = await api.list_job_definitions()
         """
@@ -192,14 +182,16 @@
         )
 
         res = self._request(
             "GET",
             f"/serverless-jobs/v1alpha1/regions/{param_region}/job-definitions",
             params={
                 "order_by": order_by,
+                "organization_id": organization_id
+                or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
             },
         )
 
         self._throw_on_error(res)
@@ -209,21 +201,24 @@
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListJobDefinitionsRequestOrderBy] = None,
         project_id: Optional[str] = None,
+        organization_id: Optional[str] = None,
     ) -> List[JobDefinition]:
         """
+        List all your job definitions with filters.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page:
         :param page_size:
         :param order_by:
         :param project_id:
+        :param organization_id:
         :return: :class:`List[JobDefinition] <List[JobDefinition]>`
 
         Usage:
         ::
 
             result = await api.list_job_definitions_all()
         """
@@ -234,225 +229,261 @@
             fetcher=self.list_job_definitions,
             args={
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
                 "project_id": project_id,
+                "organization_id": organization_id,
             },
         )
 
     async def update_job_definition(
         self,
         *,
-        id: str,
+        job_definition_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         cpu_limit: Optional[int] = None,
         memory_limit: Optional[int] = None,
+        local_storage_capacity: Optional[int] = None,
         image_uri: Optional[str] = None,
         command: Optional[str] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         description: Optional[str] = None,
         job_timeout: Optional[str] = None,
+        cron_schedule: Optional[UpdateJobDefinitionRequestCronScheduleConfig] = None,
     ) -> JobDefinition:
         """
-        :param id:
+        Update an existing job definition associated with the specified unique identifier.
+        :param job_definition_id: UUID of the job definition to update.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param name:
-        :param cpu_limit:
-        :param memory_limit:
-        :param image_uri:
-        :param command:
-        :param environment_variables:
-        :param description:
-        :param job_timeout:
+        :param name: Name of the job definition.
+        :param cpu_limit: CPU limit of the job.
+        :param memory_limit: Memory limit of the job (in MiB).
+        :param local_storage_capacity: Local storage capacity of the job (in MiB).
+        :param image_uri: Image to use for the job.
+        :param command: Startup command.
+        :param environment_variables: Environment variables of the job.
+        :param description: Description of the job.
+        :param job_timeout: Timeout of the job in seconds.
+        :param cron_schedule:
         :return: :class:`JobDefinition <JobDefinition>`
 
         Usage:
         ::
 
             result = await api.update_job_definition(
-                id="example",
+                job_definition_id="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_id = validate_path_param("id", id)
+        param_job_definition_id = validate_path_param(
+            "job_definition_id", job_definition_id
+        )
 
         res = self._request(
             "PATCH",
-            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-definitions/{param_id}",
+            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-definitions/{param_job_definition_id}",
             body=marshal_UpdateJobDefinitionRequest(
                 UpdateJobDefinitionRequest(
-                    id=id,
+                    job_definition_id=job_definition_id,
                     region=region,
                     name=name,
                     cpu_limit=cpu_limit,
                     memory_limit=memory_limit,
+                    local_storage_capacity=local_storage_capacity,
                     image_uri=image_uri,
                     command=command,
                     environment_variables=environment_variables,
                     description=description,
                     job_timeout=job_timeout,
+                    cron_schedule=cron_schedule,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_JobDefinition(res.json())
 
     async def delete_job_definition(
         self,
         *,
-        id: str,
+        job_definition_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
-        :param id:
+        Delete an exsisting job definition by its unique identifier.
+        :param job_definition_id: UUID of the job definition to delete.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.delete_job_definition(
-                id="example",
+                job_definition_id="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_id = validate_path_param("id", id)
+        param_job_definition_id = validate_path_param(
+            "job_definition_id", job_definition_id
+        )
 
         res = self._request(
             "DELETE",
-            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-definitions/{param_id}",
+            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-definitions/{param_job_definition_id}",
         )
 
         self._throw_on_error(res)
 
     async def start_job_definition(
         self,
         *,
-        id: str,
+        job_definition_id: str,
         region: Optional[Region] = None,
-    ) -> JobRun:
+        command: Optional[str] = None,
+        environment_variables: Optional[Dict[str, str]] = None,
+        replicas: Optional[int] = None,
+    ) -> StartJobDefinitionResponse:
         """
-        :param id:
+        Run an existing job definition by its unique identifier. This will create a new job run.
+        :param job_definition_id: UUID of the job definition to start.
         :param region: Region to target. If none is passed will use default region from the config.
-        :return: :class:`JobRun <JobRun>`
+        :param command: Contextual startup command for this specific job run.
+        :param environment_variables: Contextual environment variables for this specific job run.
+        :param replicas: Number of jobs to run.
+        :return: :class:`StartJobDefinitionResponse <StartJobDefinitionResponse>`
 
         Usage:
         ::
 
             result = await api.start_job_definition(
-                id="example",
+                job_definition_id="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_id = validate_path_param("id", id)
+        param_job_definition_id = validate_path_param(
+            "job_definition_id", job_definition_id
+        )
 
         res = self._request(
             "POST",
-            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-definitions/{param_id}/start",
-            body={},
+            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-definitions/{param_job_definition_id}/start",
+            body=marshal_StartJobDefinitionRequest(
+                StartJobDefinitionRequest(
+                    job_definition_id=job_definition_id,
+                    region=region,
+                    command=command,
+                    environment_variables=environment_variables,
+                    replicas=replicas,
+                ),
+                self.client,
+            ),
         )
 
         self._throw_on_error(res)
-        return unmarshal_JobRun(res.json())
+        return unmarshal_StartJobDefinitionResponse(res.json())
 
     async def get_job_run(
         self,
         *,
-        id: str,
+        job_run_id: str,
         region: Optional[Region] = None,
     ) -> JobRun:
         """
-        :param id:
+        Get a job run by its unique identifier.
+        :param job_run_id: UUID of the job run to get.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`JobRun <JobRun>`
 
         Usage:
         ::
 
             result = await api.get_job_run(
-                id="example",
+                job_run_id="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_id = validate_path_param("id", id)
+        param_job_run_id = validate_path_param("job_run_id", job_run_id)
 
         res = self._request(
             "GET",
-            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-runs/{param_id}",
+            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-runs/{param_job_run_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_JobRun(res.json())
 
     async def stop_job_run(
         self,
         *,
-        id: str,
+        job_run_id: str,
         region: Optional[Region] = None,
     ) -> JobRun:
         """
-        :param id:
+        Stop a job run by its unique identifier.
+        :param job_run_id: UUID of the job run to stop.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`JobRun <JobRun>`
 
         Usage:
         ::
 
             result = await api.stop_job_run(
-                id="example",
+                job_run_id="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_id = validate_path_param("id", id)
+        param_job_run_id = validate_path_param("job_run_id", job_run_id)
 
         res = self._request(
             "POST",
-            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-runs/{param_id}/stop",
+            f"/serverless-jobs/v1alpha1/regions/{param_region}/job-runs/{param_job_run_id}/stop",
             body={},
         )
 
         self._throw_on_error(res)
         return unmarshal_JobRun(res.json())
 
     async def list_job_runs(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListJobRunsRequestOrderBy] = None,
-        id: Optional[str] = None,
+        job_definition_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        organization_id: Optional[str] = None,
     ) -> ListJobRunsResponse:
         """
+        List all job runs with filters.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page:
         :param page_size:
         :param order_by:
-        :param id:
+        :param job_definition_id:
         :param project_id:
+        :param organization_id:
         :return: :class:`ListJobRunsResponse <ListJobRunsResponse>`
 
         Usage:
         ::
 
             result = await api.list_job_runs()
         """
@@ -461,16 +492,18 @@
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
             f"/serverless-jobs/v1alpha1/regions/{param_region}/job-runs",
             params={
-                "id": id,
+                "job_definition_id": job_definition_id,
                 "order_by": order_by,
+                "organization_id": organization_id
+                or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
             },
         )
 
         self._throw_on_error(res)
@@ -479,24 +512,27 @@
     async def list_job_runs_all(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListJobRunsRequestOrderBy] = None,
-        id: Optional[str] = None,
+        job_definition_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        organization_id: Optional[str] = None,
     ) -> List[JobRun]:
         """
+        List all job runs with filters.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page:
         :param page_size:
         :param order_by:
-        :param id:
+        :param job_definition_id:
         :param project_id:
+        :param organization_id:
         :return: :class:`List[JobRun] <List[JobRun]>`
 
         Usage:
         ::
 
             result = await api.list_job_runs_all()
         """
@@ -506,11 +542,12 @@
             key="job_runs",
             fetcher=self.list_job_runs,
             args={
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
-                "id": id,
+                "job_definition_id": job_definition_id,
                 "project_id": project_id,
+                "organization_id": organization_id,
             },
         )
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/jobs/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/serverless_sqldb/v1alpha1/marshalling.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,243 +2,240 @@
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 from dateutil import parser
 
 from scaleway_core.profile import ProfileDefaults
 from .types import (
-    JobDefinition,
-    JobRun,
-    ListJobDefinitionsResponse,
-    ListJobRunsResponse,
-    CreateJobDefinitionRequest,
-    UpdateJobDefinitionRequest,
+    DatabaseBackup,
+    Database,
+    ListDatabaseBackupsResponse,
+    ListDatabasesResponse,
+    CreateDatabaseRequest,
+    RestoreDatabaseFromBackupRequest,
+    UpdateDatabaseRequest,
 )
 
 
-def unmarshal_JobDefinition(data: Any) -> JobDefinition:
+def unmarshal_DatabaseBackup(data: Any) -> DatabaseBackup:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'JobDefinition' failed as data isn't a dictionary."
+            "Unmarshalling the type 'DatabaseBackup' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
-    field = data.get("cpu_limit", None)
+    field = data.get("status", None)
     if field is not None:
-        args["cpu_limit"] = field
+        args["status"] = field
 
-    field = data.get("memory_limit", None)
+    field = data.get("organization_id", None)
     if field is not None:
-        args["memory_limit"] = field
+        args["organization_id"] = field
 
-    field = data.get("image_uri", None)
+    field = data.get("project_id", None)
     if field is not None:
-        args["image_uri"] = field
+        args["project_id"] = field
 
-    field = data.get("command", None)
+    field = data.get("database_id", None)
     if field is not None:
-        args["command"] = field
+        args["database_id"] = field
 
-    field = data.get("project_id", None)
+    field = data.get("region", None)
     if field is not None:
-        args["project_id"] = field
+        args["region"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
-    field = data.get("updated_at", None)
-    if field is not None:
-        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("environment_variables", None)
+    field = data.get("expires_at", None)
     if field is not None:
-        args["environment_variables"] = field
+        args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
-    field = data.get("description", None)
+    field = data.get("size", None)
     if field is not None:
-        args["description"] = field
+        args["size"] = field
+    else:
+        args["size"] = None
 
-    field = data.get("region", None)
+    field = data.get("download_url", None)
     if field is not None:
-        args["region"] = field
+        args["download_url"] = field
+    else:
+        args["download_url"] = None
 
-    field = data.get("job_timeout", None)
+    field = data.get("download_url_expires_at", None)
     if field is not None:
-        args["job_timeout"] = field
+        args["download_url_expires_at"] = (
+            parser.isoparse(field) if isinstance(field, str) else field
+        )
+    else:
+        args["download_url_expires_at"] = None
 
-    return JobDefinition(**args)
+    return DatabaseBackup(**args)
 
 
-def unmarshal_JobRun(data: Any) -> JobRun:
+def unmarshal_Database(data: Any) -> Database:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'JobRun' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Database' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("job_definition_id", None)
+    field = data.get("name", None)
+    if field is not None:
+        args["name"] = field
+
+    field = data.get("status", None)
+    if field is not None:
+        args["status"] = field
+
+    field = data.get("endpoint", None)
     if field is not None:
-        args["job_definition_id"] = field
+        args["endpoint"] = field
 
-    field = data.get("state", None)
+    field = data.get("organization_id", None)
     if field is not None:
-        args["state"] = field
+        args["organization_id"] = field
 
-    field = data.get("error_message", None)
+    field = data.get("project_id", None)
     if field is not None:
-        args["error_message"] = field
+        args["project_id"] = field
 
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
-    field = data.get("created_at", None)
+    field = data.get("cpu_min", None)
     if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["cpu_min"] = field
 
-    field = data.get("updated_at", None)
+    field = data.get("cpu_max", None)
     if field is not None:
-        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["cpu_max"] = field
 
-    field = data.get("terminated_at", None)
+    field = data.get("cpu_current", None)
     if field is not None:
-        args["terminated_at"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["cpu_current"] = field
+
+    field = data.get("started", None)
+    if field is not None:
+        args["started"] = field
 
-    field = data.get("exit_code", None)
+    field = data.get("engine_major_version", None)
     if field is not None:
-        args["exit_code"] = field
+        args["engine_major_version"] = field
 
-    field = data.get("run_duration", None)
+    field = data.get("created_at", None)
     if field is not None:
-        args["run_duration"] = field
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
-    return JobRun(**args)
+    return Database(**args)
 
 
-def unmarshal_ListJobDefinitionsResponse(data: Any) -> ListJobDefinitionsResponse:
+def unmarshal_ListDatabaseBackupsResponse(data: Any) -> ListDatabaseBackupsResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListJobDefinitionsResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListDatabaseBackupsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("job_definitions", None)
+    field = data.get("backups", None)
     if field is not None:
-        args["job_definitions"] = (
-            [unmarshal_JobDefinition(v) for v in field] if field is not None else None
+        args["backups"] = (
+            [unmarshal_DatabaseBackup(v) for v in field] if field is not None else None
         )
 
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    return ListJobDefinitionsResponse(**args)
+    return ListDatabaseBackupsResponse(**args)
 
 
-def unmarshal_ListJobRunsResponse(data: Any) -> ListJobRunsResponse:
+def unmarshal_ListDatabasesResponse(data: Any) -> ListDatabasesResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListJobRunsResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListDatabasesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("job_runs", None)
+    field = data.get("databases", None)
     if field is not None:
-        args["job_runs"] = (
-            [unmarshal_JobRun(v) for v in field] if field is not None else None
+        args["databases"] = (
+            [unmarshal_Database(v) for v in field] if field is not None else None
         )
 
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    return ListJobRunsResponse(**args)
+    return ListDatabasesResponse(**args)
 
 
-def marshal_CreateJobDefinitionRequest(
-    request: CreateJobDefinitionRequest,
+def marshal_CreateDatabaseRequest(
+    request: CreateDatabaseRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.cpu_limit is not None:
-        output["cpu_limit"] = request.cpu_limit
-
-    if request.memory_limit is not None:
-        output["memory_limit"] = request.memory_limit
-
-    if request.image_uri is not None:
-        output["image_uri"] = request.image_uri
-
-    if request.command is not None:
-        output["command"] = request.command
-
-    if request.description is not None:
-        output["description"] = request.description
-
     if request.name is not None:
         output["name"] = request.name
 
+    if request.cpu_min is not None:
+        output["cpu_min"] = request.cpu_min
+
+    if request.cpu_max is not None:
+        output["cpu_max"] = request.cpu_max
+
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
-    if request.environment_variables is not None:
-        output["environment_variables"] = {
-            key: value for key, value in request.environment_variables.items()
-        }
-
-    if request.job_timeout is not None:
-        output["job_timeout"] = request.job_timeout
+    if request.from_backup_id is not None:
+        output["from_backup_id"] = request.from_backup_id
 
     return output
 
 
-def marshal_UpdateJobDefinitionRequest(
-    request: UpdateJobDefinitionRequest,
+def marshal_RestoreDatabaseFromBackupRequest(
+    request: RestoreDatabaseFromBackupRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.name is not None:
-        output["name"] = request.name
-
-    if request.cpu_limit is not None:
-        output["cpu_limit"] = request.cpu_limit
-
-    if request.memory_limit is not None:
-        output["memory_limit"] = request.memory_limit
+    if request.backup_id is not None:
+        output["backup_id"] = request.backup_id
 
-    if request.image_uri is not None:
-        output["image_uri"] = request.image_uri
+    return output
 
-    if request.command is not None:
-        output["command"] = request.command
 
-    if request.environment_variables is not None:
-        output["environment_variables"] = request.environment_variables
+def marshal_UpdateDatabaseRequest(
+    request: UpdateDatabaseRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    if request.description is not None:
-        output["description"] = request.description
+    if request.cpu_min is not None:
+        output["cpu_min"] = request.cpu_min
 
-    if request.job_timeout is not None:
-        output["job_timeout"] = request.job_timeout
+    if request.cpu_max is not None:
+        output["cpu_max"] = request.cpu_max
 
     return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/jobs/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/jobs/v1alpha1/types.py`

 * *Files 27% similar despite different names*

```diff
@@ -19,14 +19,15 @@
     UNKNOWN_STATE = "unknown_state"
     QUEUED = "queued"
     SCHEDULED = "scheduled"
     RUNNING = "running"
     SUCCEEDED = "succeeded"
     FAILED = "failed"
     CANCELED = "canceled"
+    INTERNAL_ERROR = "internal_error"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class ListJobDefinitionsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
     CREATED_AT_ASC = "created_at_asc"
@@ -41,14 +42,34 @@
     CREATED_AT_DESC = "created_at_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
+class CronSchedule:
+    schedule: str
+    """
+    UNIX cron schedule to run job (e.g., '* * * * *').
+    """
+
+    timezone: str
+    """
+    Timezone for the cron schedule, in tz database format (e.g., 'Europe/Paris').
+    """
+
+
+@dataclass
+class CreateJobDefinitionRequestCronScheduleConfig:
+    schedule: str
+
+    timezone: str
+
+
+@dataclass
 class JobDefinition:
     id: str
 
     name: str
 
     cpu_limit: int
 
@@ -64,106 +85,164 @@
 
     updated_at: Optional[datetime]
 
     environment_variables: Dict[str, str]
 
     description: str
 
+    local_storage_capacity: int
+
     region: Region
     """
     Region to target. If none is passed will use default region from the config.
     """
 
     job_timeout: Optional[str]
 
+    cron_schedule: Optional[CronSchedule]
+
 
 @dataclass
 class JobRun:
     id: str
 
     job_definition_id: str
 
     state: JobRunState
 
     error_message: str
 
-    region: Region
-    """
-    Region to target. If none is passed will use default region from the config.
-    """
+    cpu_limit: int
+
+    memory_limit: int
+
+    command: str
 
     created_at: Optional[datetime]
 
     updated_at: Optional[datetime]
 
     terminated_at: Optional[datetime]
 
     exit_code: Optional[int]
 
     run_duration: Optional[str]
 
+    environment_variables: Dict[str, str]
+
+    local_storage_capacity: int
+
+    region: Region
+    """
+    Region to target. If none is passed will use default region from the config.
+    """
+
+    started_at: Optional[datetime]
+
+
+@dataclass
+class UpdateJobDefinitionRequestCronScheduleConfig:
+    schedule: Optional[str]
+
+    timezone: Optional[str]
+
 
 @dataclass
 class CreateJobDefinitionRequest:
     cpu_limit: int
+    """
+    CPU limit of the job.
+    """
 
     memory_limit: int
+    """
+    Memory limit of the job (in MiB).
+    """
 
     image_uri: str
+    """
+    Image to use for the job.
+    """
 
     command: str
+    """
+    Startup command. If empty or not defined, the image's default command is used.
+    """
 
     description: str
+    """
+    Description of the job.
+    """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
+    """
+    Name of the job definition.
+    """
+
+    local_storage_capacity: Optional[int]
+    """
+    Local storage capacity of the job (in MiB).
+    """
 
     project_id: Optional[str]
+    """
+    UUID of the Scaleway Project containing the job.
+    """
 
     environment_variables: Optional[Dict[str, str]]
+    """
+    Environment variables of the job.
+    """
 
     job_timeout: Optional[str]
+    """
+    Timeout of the job in seconds.
+    """
+
+    cron_schedule: Optional[CreateJobDefinitionRequestCronScheduleConfig]
 
 
 @dataclass
 class DeleteJobDefinitionRequest:
-    id: str
+    job_definition_id: str
+    """
+    UUID of the job definition to delete.
+    """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
 class GetJobDefinitionRequest:
-    id: str
+    job_definition_id: str
+    """
+    UUID of the job definition to get.
+    """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
 class GetJobRunRequest:
-    id: str
-
-    region: Optional[Region]
+    job_run_id: str
     """
-    Region to target. If none is passed will use default region from the config.
+    UUID of the job run to get.
     """
 
-
-@dataclass
-class GetServiceInfoRequest:
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
@@ -177,14 +256,16 @@
 
     page_size: Optional[int]
 
     order_by: Optional[ListJobDefinitionsRequestOrderBy]
 
     project_id: Optional[str]
 
+    organization_id: Optional[str]
+
 
 @dataclass
 class ListJobDefinitionsResponse:
     job_definitions: List[JobDefinition]
 
     total_count: int
 
@@ -198,63 +279,125 @@
 
     page: Optional[int]
 
     page_size: Optional[int]
 
     order_by: Optional[ListJobRunsRequestOrderBy]
 
-    id: Optional[str]
+    job_definition_id: Optional[str]
 
     project_id: Optional[str]
 
+    organization_id: Optional[str]
+
 
 @dataclass
 class ListJobRunsResponse:
     job_runs: List[JobRun]
 
     total_count: int
 
 
 @dataclass
 class StartJobDefinitionRequest:
-    id: str
+    job_definition_id: str
+    """
+    UUID of the job definition to start.
+    """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
+    command: Optional[str]
+    """
+    Contextual startup command for this specific job run.
+    """
+
+    environment_variables: Optional[Dict[str, str]]
+    """
+    Contextual environment variables for this specific job run.
+    """
+
+    replicas: Optional[int]
+    """
+    Number of jobs to run.
+    """
+
+
+@dataclass
+class StartJobDefinitionResponse:
+    job_runs: List[JobRun]
+
 
 @dataclass
 class StopJobRunRequest:
-    id: str
+    job_run_id: str
+    """
+    UUID of the job run to stop.
+    """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
 class UpdateJobDefinitionRequest:
-    id: str
+    job_definition_id: str
+    """
+    UUID of the job definition to update.
+    """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
+    """
+    Name of the job definition.
+    """
 
     cpu_limit: Optional[int]
+    """
+    CPU limit of the job.
+    """
 
     memory_limit: Optional[int]
+    """
+    Memory limit of the job (in MiB).
+    """
+
+    local_storage_capacity: Optional[int]
+    """
+    Local storage capacity of the job (in MiB).
+    """
 
     image_uri: Optional[str]
+    """
+    Image to use for the job.
+    """
 
     command: Optional[str]
+    """
+    Startup command.
+    """
 
     environment_variables: Optional[Dict[str, str]]
+    """
+    Environment variables of the job.
+    """
 
     description: Optional[str]
+    """
+    Description of the job.
+    """
 
     job_timeout: Optional[str]
+    """
+    Timeout of the job in seconds.
+    """
+
+    cron_schedule: Optional[UpdateJobDefinitionRequestCronScheduleConfig]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/k8s/v1/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 from .types import AutoscalerEstimator
 from .types import AutoscalerExpander
 from .types import CNI
 from .types import ClusterStatus
 from .content import CLUSTER_TRANSIENT_STATUSES
 from .types import ClusterTypeAvailability
 from .types import ClusterTypeResiliency
-from .types import Ingress
 from .types import ListClustersRequestOrderBy
 from .types import ListNodesRequestOrderBy
 from .types import ListPoolsRequestOrderBy
 from .types import MaintenanceWindowDayOfTheWeek
 from .types import NodeStatus
 from .content import NODE_TRANSIENT_STATUSES
 from .types import PoolStatus
@@ -26,14 +25,15 @@
 from .types import ClusterOpenIDConnectConfig
 from .types import Pool
 from .types import CreateClusterRequestAutoUpgrade
 from .types import CreateClusterRequestAutoscalerConfig
 from .types import CreateClusterRequestOpenIDConnectConfig
 from .types import CreateClusterRequestPoolConfig
 from .types import CreatePoolRequestUpgradePolicy
+from .types import ExternalNodeCoreV1Taint
 from .types import ClusterType
 from .types import Version
 from .types import Cluster
 from .types import Node
 from .types import UpdateClusterRequestAutoUpgrade
 from .types import UpdateClusterRequestAutoscalerConfig
 from .types import UpdateClusterRequestOpenIDConnectConfig
@@ -79,15 +79,14 @@
     "AutoscalerEstimator",
     "AutoscalerExpander",
     "CNI",
     "ClusterStatus",
     "CLUSTER_TRANSIENT_STATUSES",
     "ClusterTypeAvailability",
     "ClusterTypeResiliency",
-    "Ingress",
     "ListClustersRequestOrderBy",
     "ListNodesRequestOrderBy",
     "ListPoolsRequestOrderBy",
     "MaintenanceWindowDayOfTheWeek",
     "NodeStatus",
     "NODE_TRANSIENT_STATUSES",
     "PoolStatus",
@@ -102,14 +101,15 @@
     "ClusterOpenIDConnectConfig",
     "Pool",
     "CreateClusterRequestAutoUpgrade",
     "CreateClusterRequestAutoscalerConfig",
     "CreateClusterRequestOpenIDConnectConfig",
     "CreateClusterRequestPoolConfig",
     "CreatePoolRequestUpgradePolicy",
+    "ExternalNodeCoreV1Taint",
     "ClusterType",
     "Version",
     "Cluster",
     "Node",
     "UpdateClusterRequestAutoUpgrade",
     "UpdateClusterRequestAutoscalerConfig",
     "UpdateClusterRequestOpenIDConnectConfig",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/k8s/v1/api.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,14 @@
     validate_path_param,
     fetch_all_pages_async,
     wait_for_resource_async,
 )
 from .types import (
     CNI,
     ClusterStatus,
-    Ingress,
     ListClustersRequestOrderBy,
     ListNodesRequestOrderBy,
     ListPoolsRequestOrderBy,
     NodeStatus,
     PoolStatus,
     PoolVolumeType,
     Runtime,
@@ -213,16 +212,14 @@
         version: str,
         region: Optional[Region] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         cni: CNI,
-        enable_dashboard: Optional[bool] = None,
-        ingress: Optional[Ingress] = None,
         pools: Optional[List[CreateClusterRequestPoolConfig]] = None,
         autoscaler_config: Optional[CreateClusterRequestAutoscalerConfig] = None,
         auto_upgrade: Optional[CreateClusterRequestAutoUpgrade] = None,
         feature_gates: Optional[List[str]] = None,
         admission_plugins: Optional[List[str]] = None,
         open_id_connect_config: Optional[
             CreateClusterRequestOpenIDConnectConfig
@@ -234,20 +231,20 @@
         Create a new Cluster.
         Create a new Kubernetes cluster in a Scaleway region.
         :param type_: Type of the cluster (possible values are kapsule, multicloud, kapsule-dedicated-8, kapsule-dedicated-16).
         :param description: Cluster description.
         :param version: Kubernetes version of the cluster.
         :param region: Region to target. If none is passed will use default region from the config.
         :param organization_id: Organization ID in which the cluster will be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: Project ID in which the cluster will be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param name: Cluster name.
         :param tags: Tags associated with the cluster.
         :param cni: Container Network Interface (CNI) plugin running in the cluster.
-        :param enable_dashboard: Defines whether the Kubernetes Dashboard is enabled in the cluster.
-        :param ingress: Ingress Controller running in the cluster (deprecated feature).
         :param pools: Pools created along with the cluster.
         :param autoscaler_config: Autoscaler configuration for the cluster. It allows you to set (to an extent) your preferred autoscaler configuration, which is an implementation of the cluster-autoscaler (https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/).
         :param auto_upgrade: Auto upgrade configuration of the cluster. This configuration enables to set a specific 2-hour time window in which the cluster can be automatically updated to the latest patch version.
         :param feature_gates: List of feature gates to enable.
         :param admission_plugins: List of admission plugins to enable.
         :param open_id_connect_config: OpenID Connect configuration of the cluster. This configuration enables to update the OpenID Connect configuration of the Kubernetes API server.
         :param apiserver_cert_sans: Additional Subject Alternative Names for the Kubernetes API server certificate.
@@ -270,23 +267,21 @@
         )
 
         res = self._request(
             "POST",
             f"/k8s/v1/regions/{param_region}/clusters",
             body=marshal_CreateClusterRequest(
                 CreateClusterRequest(
-                    region=region,
                     type_=type_,
                     description=description,
                     version=version,
-                    cni=cni,
+                    region=region,
                     name=name or random_name(prefix="k8s"),
                     tags=tags,
-                    enable_dashboard=enable_dashboard,
-                    ingress=ingress,
+                    cni=cni,
                     pools=pools,
                     autoscaler_config=autoscaler_config,
                     auto_upgrade=auto_upgrade,
                     feature_gates=feature_gates,
                     admission_plugins=admission_plugins,
                     open_id_connect_config=open_id_connect_config,
                     apiserver_cert_sans=apiserver_cert_sans,
@@ -377,16 +372,14 @@
         *,
         cluster_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         description: Optional[str] = None,
         tags: Optional[List[str]] = None,
         autoscaler_config: Optional[UpdateClusterRequestAutoscalerConfig] = None,
-        enable_dashboard: Optional[bool] = None,
-        ingress: Optional[Ingress] = None,
         auto_upgrade: Optional[UpdateClusterRequestAutoUpgrade] = None,
         feature_gates: Optional[List[str]] = None,
         admission_plugins: Optional[List[str]] = None,
         open_id_connect_config: Optional[
             UpdateClusterRequestOpenIDConnectConfig
         ] = None,
         apiserver_cert_sans: Optional[List[str]] = None,
@@ -396,16 +389,14 @@
         Update information on a specific Kubernetes cluster. You can update details such as its name, description, tags and configuration. To upgrade a cluster, you will need to use the dedicated endpoint.
         :param cluster_id: ID of the cluster to update.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: New external name for the cluster.
         :param description: New description for the cluster.
         :param tags: New tags associated with the cluster.
         :param autoscaler_config: New autoscaler config for the cluster.
-        :param enable_dashboard: New value for the Kubernetes Dashboard enablement.
-        :param ingress: New Ingress Controller for the cluster (deprecated feature).
         :param auto_upgrade: New auto upgrade configuration for the cluster. Note that all fields need to be set.
         :param feature_gates: List of feature gates to enable.
         :param admission_plugins: List of admission plugins to enable.
         :param open_id_connect_config: OpenID Connect configuration of the cluster. This configuration enables to update the OpenID Connect configuration of the Kubernetes API server.
         :param apiserver_cert_sans: Additional Subject Alternative Names for the Kubernetes API server certificate.
         :return: :class:`Cluster <Cluster>`
 
@@ -429,16 +420,14 @@
                 UpdateClusterRequest(
                     cluster_id=cluster_id,
                     region=region,
                     name=name,
                     description=description,
                     tags=tags,
                     autoscaler_config=autoscaler_config,
-                    enable_dashboard=enable_dashboard,
-                    ingress=ingress,
                     auto_upgrade=auto_upgrade,
                     feature_gates=feature_gates,
                     admission_plugins=admission_plugins,
                     open_id_connect_config=open_id_connect_config,
                     apiserver_cert_sans=apiserver_cert_sans,
                 ),
                 self.client,
@@ -651,21 +640,23 @@
         return unmarshal_ListClusterAvailableTypesResponse(res.json())
 
     async def _get_cluster_kube_config(
         self,
         *,
         cluster_id: str,
         region: Optional[Region] = None,
+        redacted: Optional[bool] = None,
     ) -> ScwFile:
         """
         Download the kubeconfig for a Cluster.
         Download the Kubernetes cluster config file (also known as `kubeconfig`) for a specific cluster to use it with `kubectl`.
         Tip: add `?dl=1` at the end of the URL to directly retrieve the base64 decoded kubeconfig. If you choose not to, the kubeconfig will be base64 encoded.
         :param cluster_id: Cluster ID for which to download the kubeconfig.
         :param region: Region to target. If none is passed will use default region from the config.
+        :param redacted: Hide the legacy token from the kubeconfig.
         :return: :class:`ScwFile <ScwFile>`
 
         Usage:
         ::
 
             result = await api._get_cluster_kube_config(
                 cluster_id="example",
@@ -676,14 +667,17 @@
             "region", region or self.client.default_region
         )
         param_cluster_id = validate_path_param("cluster_id", cluster_id)
 
         res = self._request(
             "GET",
             f"/k8s/v1/regions/{param_region}/clusters/{param_cluster_id}/kubeconfig",
+            params={
+                "redacted": redacted,
+            },
         )
 
         self._throw_on_error(res)
         return unmarshal_ScwFile(res.json())
 
     async def reset_cluster_admin_token(
         self,
@@ -1457,15 +1451,15 @@
         replace: bool,
         region: Optional[Region] = None,
     ) -> Node:
         """
         Delete a Node in a Cluster.
         Delete a specific Node. Note that when there is not enough space to reschedule all the pods (such as in a one-node cluster), disruption of your applications can be expected.
         :param node_id: ID of the node to replace.
-        :param skip_drain: Skip draining node from its workload.
+        :param skip_drain: Skip draining node from its workload (Note: this parameter is currently inactive).
         :param replace: Add a new node after the deletion of this node.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Node <Node>`
 
         Usage:
         ::
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/content.py` & `scaleway_async-2.1.0/scaleway_async/k8s/v1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/k8s/v1/marshalling.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,25 +7,25 @@
 from scaleway_core.profile import ProfileDefaults
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from .types import (
     CNI,
-    Ingress,
     Runtime,
     PoolUpgradePolicy,
     Pool,
     Version,
     MaintenanceWindow,
     ClusterAutoUpgrade,
     ClusterAutoscalerConfig,
     ClusterOpenIDConnectConfig,
     Cluster,
     Node,
+    ExternalNodeCoreV1Taint,
     ExternalNode,
     ClusterType,
     ListClusterAvailableTypesResponse,
     ListClusterAvailableVersionsResponse,
     ListClusterTypesResponse,
     ListClustersResponse,
     ListNodesResponse,
@@ -110,18 +110,22 @@
     field = data.get("size", None)
     if field is not None:
         args["size"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("min_size", None)
     if field is not None:
         args["min_size"] = field
 
     field = data.get("max_size", None)
     if field is not None:
@@ -158,22 +162,28 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("placement_group_id", None)
     if field is not None:
         args["placement_group_id"] = field
+    else:
+        args["placement_group_id"] = None
 
     field = data.get("upgrade_policy", None)
     if field is not None:
         args["upgrade_policy"] = unmarshal_PoolUpgradePolicy(field)
+    else:
+        args["upgrade_policy"] = None
 
     field = data.get("root_volume_size", None)
     if field is not None:
         args["root_volume_size"] = field
+    else:
+        args["root_volume_size"] = None
 
     return Pool(**args)
 
 
 def unmarshal_Version(data: Any) -> Version:
     if not isinstance(data, dict):
         raise TypeError(
@@ -212,20 +222,14 @@
     if field is not None:
         args["available_admission_plugins"] = field
 
     field = data.get("available_kubelet_args", None)
     if field is not None:
         args["available_kubelet_args"] = field
 
-    field = data.get("available_ingresses", None)
-    if field is not None:
-        args["available_ingresses"] = (
-            [Ingress(v) for v in field] if field is not None else None
-        )
-
     return Version(**args)
 
 
 def unmarshal_MaintenanceWindow(data: Any) -> MaintenanceWindow:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'MaintenanceWindow' failed as data isn't a dictionary."
@@ -255,14 +259,16 @@
     field = data.get("enabled", None)
     if field is not None:
         args["enabled"] = field
 
     field = data.get("maintenance_window", None)
     if field is not None:
         args["maintenance_window"] = unmarshal_MaintenanceWindow(field)
+    else:
+        args["maintenance_window"] = None
 
     return ClusterAutoUpgrade(**args)
 
 
 def unmarshal_ClusterAutoscalerConfig(data: Any) -> ClusterAutoscalerConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -361,15 +367,15 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
@@ -409,38 +415,14 @@
     if field is not None:
         args["cluster_url"] = field
 
     field = data.get("dns_wildcard", None)
     if field is not None:
         args["dns_wildcard"] = field
 
-    field = data.get("created_at", None)
-    if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("updated_at", None)
-    if field is not None:
-        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("autoscaler_config", None)
-    if field is not None:
-        args["autoscaler_config"] = unmarshal_ClusterAutoscalerConfig(field)
-
-    field = data.get("dashboard_enabled", None)
-    if field is not None:
-        args["dashboard_enabled"] = field
-
-    field = data.get("ingress", None)
-    if field is not None:
-        args["ingress"] = field
-
-    field = data.get("auto_upgrade", None)
-    if field is not None:
-        args["auto_upgrade"] = unmarshal_ClusterAutoUpgrade(field)
-
     field = data.get("upgrade_available", None)
     if field is not None:
         args["upgrade_available"] = field
 
     field = data.get("feature_gates", None)
     if field is not None:
         args["feature_gates"] = field
@@ -449,27 +431,67 @@
     if field is not None:
         args["admission_plugins"] = field
 
     field = data.get("apiserver_cert_sans", None)
     if field is not None:
         args["apiserver_cert_sans"] = field
 
+    field = data.get("created_at", None)
+    if field is not None:
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
+
+    field = data.get("updated_at", None)
+    if field is not None:
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
+
+    field = data.get("autoscaler_config", None)
+    if field is not None:
+        args["autoscaler_config"] = unmarshal_ClusterAutoscalerConfig(field)
+    else:
+        args["autoscaler_config"] = None
+
+    field = data.get("auto_upgrade", None)
+    if field is not None:
+        args["auto_upgrade"] = unmarshal_ClusterAutoUpgrade(field)
+    else:
+        args["auto_upgrade"] = None
+
     field = data.get("open_id_connect_config", None)
     if field is not None:
         args["open_id_connect_config"] = unmarshal_ClusterOpenIDConnectConfig(field)
+    else:
+        args["open_id_connect_config"] = None
 
     field = data.get("private_network_id", None)
     if field is not None:
         args["private_network_id"] = field
+    else:
+        args["private_network_id"] = None
 
     field = data.get("commitment_ends_at", None)
     if field is not None:
         args["commitment_ends_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["commitment_ends_at"] = None
+
+    field = data.get("routed_ip_enabled", None)
+    if field is not None:
+        args["routed_ip_enabled"] = field
+    else:
+        args["routed_ip_enabled"] = None
+
+    field = data.get("routed_ip_enabled", None)
+    if field is not None:
+        args["routed_ip_enabled"] = field
 
     return Cluster(**args)
 
 
 def unmarshal_Node(data: Any) -> Node:
     if not isinstance(data, dict):
         raise TypeError(
@@ -501,42 +523,77 @@
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
     field = data.get("public_ip_v4", None)
     if field is not None:
         args["public_ip_v4"] = field
+    else:
+        args["public_ip_v4"] = None
 
     field = data.get("public_ip_v6", None)
     if field is not None:
         args["public_ip_v6"] = field
+    else:
+        args["public_ip_v6"] = None
 
     field = data.get("conditions", None)
     if field is not None:
         args["conditions"] = field
+    else:
+        args["conditions"] = None
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("error_message", None)
     if field is not None:
         args["error_message"] = field
+    else:
+        args["error_message"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Node(**args)
 
 
+def unmarshal_ExternalNodeCoreV1Taint(data: Any) -> ExternalNodeCoreV1Taint:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'ExternalNodeCoreV1Taint' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("key", None)
+    if field is not None:
+        args["key"] = field
+
+    field = data.get("value", None)
+    if field is not None:
+        args["value"] = field
+
+    field = data.get("effect", None)
+    if field is not None:
+        args["effect"] = field
+
+    return ExternalNodeCoreV1Taint(**args)
+
+
 def unmarshal_ExternalNode(data: Any) -> ExternalNode:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ExternalNode' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -569,14 +626,38 @@
     if field is not None:
         args["kubelet_config"] = field
 
     field = data.get("external_ip", None)
     if field is not None:
         args["external_ip"] = field
 
+    field = data.get("containerd_version", None)
+    if field is not None:
+        args["containerd_version"] = field
+
+    field = data.get("runc_version", None)
+    if field is not None:
+        args["runc_version"] = field
+
+    field = data.get("cni_plugins_version", None)
+    if field is not None:
+        args["cni_plugins_version"] = field
+
+    field = data.get("node_labels", None)
+    if field is not None:
+        args["node_labels"] = field
+
+    field = data.get("node_taints", None)
+    if field is not None:
+        args["node_taints"] = (
+            [unmarshal_ExternalNodeCoreV1Taint(v) for v in field]
+            if field is not None
+            else None
+        )
+
     return ExternalNode(**args)
 
 
 def unmarshal_ClusterType(data: Any) -> ClusterType:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ClusterType' failed as data isn't a dictionary."
@@ -608,17 +689,23 @@
     if field is not None:
         args["memory"] = field
 
     field = data.get("dedicated", None)
     if field is not None:
         args["dedicated"] = field
 
+    field = data.get("audit_logs_supported", None)
+    if field is not None:
+        args["audit_logs_supported"] = field
+
     field = data.get("commitment_delay", None)
     if field is not None:
         args["commitment_delay"] = field
+    else:
+        args["commitment_delay"] = None
 
     return ClusterType(**args)
 
 
 def unmarshal_ListClusterAvailableTypesResponse(
     data: Any,
 ) -> ListClusterAvailableTypesResponse:
@@ -830,25 +917,25 @@
     if request.ignore_daemonsets_utilization is not None:
         output["ignore_daemonsets_utilization"] = request.ignore_daemonsets_utilization
 
     if request.balance_similar_node_groups is not None:
         output["balance_similar_node_groups"] = request.balance_similar_node_groups
 
     if request.expendable_pods_priority_cutoff is not None:
-        output[
-            "expendable_pods_priority_cutoff"
-        ] = request.expendable_pods_priority_cutoff
+        output["expendable_pods_priority_cutoff"] = (
+            request.expendable_pods_priority_cutoff
+        )
 
     if request.scale_down_unneeded_time is not None:
         output["scale_down_unneeded_time"] = request.scale_down_unneeded_time
 
     if request.scale_down_utilization_threshold is not None:
-        output[
-            "scale_down_utilization_threshold"
-        ] = request.scale_down_utilization_threshold
+        output["scale_down_utilization_threshold"] = (
+            request.scale_down_utilization_threshold
+        )
 
     if request.max_graceful_termination_sec is not None:
         output["max_graceful_termination_sec"] = request.max_graceful_termination_sec
 
     return output
 
 
@@ -970,28 +1057,22 @@
 
     if request.description is not None:
         output["description"] = request.description
 
     if request.version is not None:
         output["version"] = request.version
 
-    if request.cni is not None:
-        output["cni"] = str(request.cni)
-
     if request.name is not None:
         output["name"] = request.name
 
     if request.tags is not None:
         output["tags"] = request.tags
 
-    if request.enable_dashboard is not None:
-        output["enable_dashboard"] = request.enable_dashboard
-
-    if request.ingress is not None:
-        output["ingress"] = str(request.ingress)
+    if request.cni is not None:
+        output["cni"] = str(request.cni)
 
     if request.pools is not None:
         output["pools"] = [
             marshal_CreateClusterRequestPoolConfig(item, defaults)
             for item in request.pools
         ]
 
@@ -1167,25 +1248,25 @@
     if request.ignore_daemonsets_utilization is not None:
         output["ignore_daemonsets_utilization"] = request.ignore_daemonsets_utilization
 
     if request.balance_similar_node_groups is not None:
         output["balance_similar_node_groups"] = request.balance_similar_node_groups
 
     if request.expendable_pods_priority_cutoff is not None:
-        output[
-            "expendable_pods_priority_cutoff"
-        ] = request.expendable_pods_priority_cutoff
+        output["expendable_pods_priority_cutoff"] = (
+            request.expendable_pods_priority_cutoff
+        )
 
     if request.scale_down_unneeded_time is not None:
         output["scale_down_unneeded_time"] = request.scale_down_unneeded_time
 
     if request.scale_down_utilization_threshold is not None:
-        output[
-            "scale_down_utilization_threshold"
-        ] = request.scale_down_utilization_threshold
+        output["scale_down_utilization_threshold"] = (
+            request.scale_down_utilization_threshold
+        )
 
     if request.max_graceful_termination_sec is not None:
         output["max_graceful_termination_sec"] = request.max_graceful_termination_sec
 
     return output
 
 
@@ -1237,20 +1318,14 @@
     if request.autoscaler_config is not None:
         output["autoscaler_config"] = (
             marshal_UpdateClusterRequestAutoscalerConfig(
                 request.autoscaler_config, defaults
             ),
         )
 
-    if request.enable_dashboard is not None:
-        output["enable_dashboard"] = request.enable_dashboard
-
-    if request.ingress is not None:
-        output["ingress"] = str(request.ingress)
-
     if request.auto_upgrade is not None:
         output["auto_upgrade"] = (
             marshal_UpdateClusterRequestAutoUpgrade(request.auto_upgrade, defaults),
         )
 
     if request.feature_gates is not None:
         output["feature_gates"] = request.feature_gates
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/k8s/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/k8s/v1/types.py`

 * *Files 2% similar despite different names*

```diff
@@ -39,14 +39,15 @@
 class CNI(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN_CNI = "unknown_cni"
     CILIUM = "cilium"
     CALICO = "calico"
     WEAVE = "weave"
     FLANNEL = "flannel"
     KILO = "kilo"
+    NONE = "none"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class ClusterStatus(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN = "unknown"
@@ -76,25 +77,14 @@
     STANDARD = "standard"
     HIGH_AVAILABILITY = "high_availability"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class Ingress(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_INGRESS = "unknown_ingress"
-    NONE = "none"
-    NGINX = "nginx"
-    TRAEFIK = "traefik"
-    TRAEFIK2 = "traefik2"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
 class ListClustersRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
     UPDATED_AT_ASC = "updated_at_asc"
     UPDATED_AT_DESC = "updated_at_desc"
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
@@ -642,14 +632,23 @@
 class CreatePoolRequestUpgradePolicy:
     max_unavailable: Optional[int]
 
     max_surge: Optional[int]
 
 
 @dataclass
+class ExternalNodeCoreV1Taint:
+    key: str
+
+    value: str
+
+    effect: str
+
+
+@dataclass
 class ClusterType:
     name: str
     """
     Cluster type name.
     """
 
     availability: ClusterTypeAvailability
@@ -678,14 +677,19 @@
     """
 
     dedicated: bool
     """
     Returns information if this offer uses dedicated resources.
     """
 
+    audit_logs_supported: bool
+    """
+    True if the offer allows activation of the audit log functionality. Please note that audit logs are sent to Cockpit.
+    """
+
     commitment_delay: Optional[str]
     """
     Time period during which you can no longer switch to a lower offer.
     """
 
 
 @dataclass
@@ -726,19 +730,14 @@
     """
 
     available_kubelet_args: Dict[str, str]
     """
     Supported kubelet arguments for this version.
     """
 
-    available_ingresses: Optional[List[Ingress]]
-    """
-    Supported Ingress Controllers for this version.
-    """
-
 
 @dataclass
 class Cluster:
     id: str
     """
     Cluster ID.
     """
@@ -799,62 +798,52 @@
     """
 
     dns_wildcard: str
     """
     Wildcard DNS resolving all the ready cluster nodes.
     """
 
-    created_at: Optional[datetime]
-    """
-    Date on which the cluster was created.
-    """
-
-    updated_at: Optional[datetime]
-    """
-    Date on which the cluster was last updated.
-    """
-
-    autoscaler_config: Optional[ClusterAutoscalerConfig]
+    upgrade_available: bool
     """
-    Autoscaler config for the cluster.
+    Defines whether a new Kubernetes version is available.
     """
 
-    dashboard_enabled: Optional[bool]
+    feature_gates: List[str]
     """
-    Defines whether the Kubernetes dashboard is enabled for the cluster.
+    List of enabled feature gates.
     """
 
-    ingress: Optional[Ingress]
+    admission_plugins: List[str]
     """
-    Managed Ingress controller used in the cluster (deprecated feature).
+    List of enabled admission plugins.
     """
 
-    auto_upgrade: Optional[ClusterAutoUpgrade]
+    apiserver_cert_sans: List[str]
     """
-    Auto upgrade configuration of the cluster.
+    Additional Subject Alternative Names for the Kubernetes API server certificate.
     """
 
-    upgrade_available: bool
+    created_at: Optional[datetime]
     """
-    Defines whether a new Kubernetes version is available.
+    Date on which the cluster was created.
     """
 
-    feature_gates: List[str]
+    updated_at: Optional[datetime]
     """
-    List of enabled feature gates.
+    Date on which the cluster was last updated.
     """
 
-    admission_plugins: List[str]
+    autoscaler_config: Optional[ClusterAutoscalerConfig]
     """
-    List of enabled admission plugins.
+    Autoscaler config for the cluster.
     """
 
-    apiserver_cert_sans: List[str]
+    auto_upgrade: Optional[ClusterAutoUpgrade]
     """
-    Additional Subject Alternative Names for the Kubernetes API server certificate.
+    Auto upgrade configuration of the cluster.
     """
 
     open_id_connect_config: Optional[ClusterOpenIDConnectConfig]
     """
     This configuration enables to update the OpenID Connect configuration of the Kubernetes API server.
     """
 
@@ -864,14 +853,19 @@
     """
 
     commitment_ends_at: Optional[datetime]
     """
     Date on which it will be possible to switch to a smaller offer.
     """
 
+    routed_ip_enabled: Optional[bool]
+    """
+    Defines whether routed IPs are enabled for nodes of this cluster.
+    """
+
 
 @dataclass
 class Node:
     id: str
     """
     Node ID.
     """
@@ -1046,19 +1040,14 @@
     max_unavailable: Optional[int]
 
     max_surge: Optional[int]
 
 
 @dataclass
 class CreateClusterRequest:
-    region: Optional[Region]
-    """
-    Region to target. If none is passed will use default region from the config.
-    """
-
     type_: str
     """
     Type of the cluster (possible values are kapsule, multicloud, kapsule-dedicated-8, kapsule-dedicated-16).
     """
 
     description: str
     """
@@ -1066,37 +1055,32 @@
     """
 
     version: str
     """
     Kubernetes version of the cluster.
     """
 
-    cni: CNI
+    region: Optional[Region]
     """
-    Container Network Interface (CNI) plugin running in the cluster.
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
     Cluster name.
     """
 
     tags: Optional[List[str]]
     """
     Tags associated with the cluster.
     """
 
-    enable_dashboard: Optional[bool]
-    """
-    Defines whether the Kubernetes Dashboard is enabled in the cluster.
-    """
-
-    ingress: Optional[Ingress]
+    cni: CNI
     """
-    Ingress Controller running in the cluster (deprecated feature).
+    Container Network Interface (CNI) plugin running in the cluster.
     """
 
     pools: Optional[List[CreateClusterRequestPoolConfig]]
     """
     Pools created along with the cluster.
     """
 
@@ -1266,15 +1250,15 @@
     node_id: str
     """
     ID of the node to replace.
     """
 
     skip_drain: bool
     """
-    Skip draining node from its workload.
+    Skip draining node from its workload (Note: this parameter is currently inactive).
     """
 
     replace: bool
     """
     Add a new node after the deletion of this node.
     """
 
@@ -1311,27 +1295,42 @@
 
     kube_token: str
 
     kubelet_config: str
 
     external_ip: str
 
+    containerd_version: str
+
+    runc_version: str
+
+    cni_plugins_version: str
+
+    node_labels: Dict[str, str]
+
+    node_taints: List[ExternalNodeCoreV1Taint]
+
 
 @dataclass
 class GetClusterKubeConfigRequest:
     cluster_id: str
     """
     Cluster ID for which to download the kubeconfig.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
+    redacted: Optional[bool]
+    """
+    Hide the legacy token from the kubeconfig.
+    """
+
 
 @dataclass
 class GetClusterRequest:
     cluster_id: str
     """
     ID of the requested cluster.
     """
@@ -1751,24 +1750,14 @@
     """
 
     autoscaler_config: Optional[UpdateClusterRequestAutoscalerConfig]
     """
     New autoscaler config for the cluster.
     """
 
-    enable_dashboard: Optional[bool]
-    """
-    New value for the Kubernetes Dashboard enablement.
-    """
-
-    ingress: Optional[Ingress]
-    """
-    New Ingress Controller for the cluster (deprecated feature).
-    """
-
     auto_upgrade: Optional[UpdateClusterRequestAutoUpgrade]
     """
     New auto upgrade configuration for the cluster. Note that all fields need to be set.
     """
 
     feature_gates: Optional[List[str]]
     """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/lb/v1/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,21 +14,22 @@
 from .types import LbStatus
 from .content import LB_TRANSIENT_STATUSES
 from .types import LbTypeStock
 from .types import ListAclRequestOrderBy
 from .types import ListBackendsRequestOrderBy
 from .types import ListCertificatesRequestOrderBy
 from .types import ListFrontendsRequestOrderBy
+from .types import ListIpsRequestIpType
 from .types import ListLbsRequestOrderBy
 from .types import ListPrivateNetworksRequestOrderBy
 from .types import ListRoutesRequestOrderBy
 from .types import ListSubscriberRequestOrderBy
 from .types import OnMarkedDownAction
 from .types import PrivateNetworkStatus
-from .content import PRIVATENETWORK_TRANSIENT_STATUSES
+from .content import PRIVATE_NETWORK_TRANSIENT_STATUSES
 from .types import Protocol
 from .types import ProxyProtocol
 from .types import SSLCompatibilityLevel
 from .types import StickySessionsType
 from .types import SubscriberEmailConfig
 from .types import SubscriberWebhookConfig
 from .types import HealthCheckHttpConfig
@@ -199,21 +200,22 @@
     "LbStatus",
     "LB_TRANSIENT_STATUSES",
     "LbTypeStock",
     "ListAclRequestOrderBy",
     "ListBackendsRequestOrderBy",
     "ListCertificatesRequestOrderBy",
     "ListFrontendsRequestOrderBy",
+    "ListIpsRequestIpType",
     "ListLbsRequestOrderBy",
     "ListPrivateNetworksRequestOrderBy",
     "ListRoutesRequestOrderBy",
     "ListSubscriberRequestOrderBy",
     "OnMarkedDownAction",
     "PrivateNetworkStatus",
-    "PRIVATENETWORK_TRANSIENT_STATUSES",
+    "PRIVATE_NETWORK_TRANSIENT_STATUSES",
     "Protocol",
     "ProxyProtocol",
     "SSLCompatibilityLevel",
     "StickySessionsType",
     "SubscriberEmailConfig",
     "SubscriberWebhookConfig",
     "HealthCheckHttpConfig",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/lb/v1/api.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,14 +17,15 @@
 )
 from .types import (
     ForwardPortAlgorithm,
     ListAclRequestOrderBy,
     ListBackendsRequestOrderBy,
     ListCertificatesRequestOrderBy,
     ListFrontendsRequestOrderBy,
+    ListIpsRequestIpType,
     ListLbsRequestOrderBy,
     ListPrivateNetworksRequestOrderBy,
     ListRoutesRequestOrderBy,
     ListSubscriberRequestOrderBy,
     OnMarkedDownAction,
     Protocol,
     ProxyProtocol,
@@ -210,25 +211,27 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         order_by: Optional[ListLbsRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        tags: Optional[List[str]] = None,
     ) -> ListLbsResponse:
         """
         List Load Balancers.
         List all Load Balancers in the specified zone, for a Scaleway Organization or Scaleway Project. By default, the Load Balancers returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param name: Load Balancer name to filter for.
         :param order_by: Sort order of Load Balancers in the response.
         :param page_size: Number of Load Balancers to return.
         :param page: Page number to return, from the paginated results.
         :param organization_id: Organization ID to filter for, only Load Balancers from this Organization will be returned.
         :param project_id: Project ID to filter for, only Load Balancers from this Project will be returned.
+        :param tags: Filter by tag, only Load Balancers with one or more matching tags will be returned.
         :return: :class:`ListLbsResponse <ListLbsResponse>`
 
         Usage:
         ::
 
             result = await api.list_lbs()
         """
@@ -242,14 +245,15 @@
                 "name": name,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
+                "tags": tags,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListLbsResponse(res.json())
 
     async def list_lbs_all(
@@ -258,25 +262,27 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         order_by: Optional[ListLbsRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        tags: Optional[List[str]] = None,
     ) -> List[Lb]:
         """
         List Load Balancers.
         List all Load Balancers in the specified zone, for a Scaleway Organization or Scaleway Project. By default, the Load Balancers returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param name: Load Balancer name to filter for.
         :param order_by: Sort order of Load Balancers in the response.
         :param page_size: Number of Load Balancers to return.
         :param page: Page number to return, from the paginated results.
         :param organization_id: Organization ID to filter for, only Load Balancers from this Organization will be returned.
         :param project_id: Project ID to filter for, only Load Balancers from this Project will be returned.
+        :param tags: Filter by tag, only Load Balancers with one or more matching tags will be returned.
         :return: :class:`List[Lb] <List[Lb]>`
 
         Usage:
         ::
 
             result = await api.list_lbs_all()
         """
@@ -289,42 +295,49 @@
                 "zone": zone,
                 "name": name,
                 "order_by": order_by,
                 "page_size": page_size,
                 "page": page,
                 "organization_id": organization_id,
                 "project_id": project_id,
+                "tags": tags,
             },
         )
 
     async def create_lb(
         self,
         *,
         description: str,
         type_: str,
         zone: Optional[Zone] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         name: Optional[str] = None,
         ip_id: Optional[str] = None,
         assign_flexible_ip: Optional[bool] = None,
+        assign_flexible_ipv6: Optional[bool] = None,
+        ip_ids: Optional[List[str]] = None,
         tags: Optional[List[str]] = None,
         ssl_compatibility_level: Optional[SSLCompatibilityLevel] = None,
     ) -> Lb:
         """
         Create a Load Balancer.
         Create a new Load Balancer. Note that the Load Balancer will be created without frontends or backends; these must be created separately via the dedicated endpoints.
         :param description: Description for the Load Balancer.
         :param type_: Load Balancer commercial offer type. Use the Load Balancer types endpoint to retrieve a list of available offer types.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param organization_id: Scaleway Organization to create the Load Balancer in.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: Scaleway Project to create the Load Balancer in.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param name: Name for the Load Balancer.
         :param ip_id: ID of an existing flexible IP address to attach to the Load Balancer.
         :param assign_flexible_ip: Defines whether to automatically assign a flexible public IP to lb. Default value is `false` (do not assign).
+        :param assign_flexible_ipv6: Defines whether to automatically assign a flexible public IPv6 to the Load Balancer. Default value is `false` (do not assign).
+        :param ip_ids: List of IP IDs to attach to the Load Balancer.
         :param tags: List of tags for the Load Balancer.
         :param ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and do not need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
@@ -343,14 +356,16 @@
                 ZonedApiCreateLbRequest(
                     description=description,
                     type_=type_,
                     zone=zone,
                     name=name or random_name(prefix="lb"),
                     ip_id=ip_id,
                     assign_flexible_ip=assign_flexible_ip,
+                    assign_flexible_ipv6=assign_flexible_ipv6,
+                    ip_ids=ip_ids,
                     tags=tags,
                     ssl_compatibility_level=ssl_compatibility_level,
                     project_id=project_id,
                     organization_id=organization_id,
                 ),
                 self.client,
             ),
@@ -565,24 +580,26 @@
         *,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         ip_address: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        ip_type: Optional[ListIpsRequestIpType] = None,
     ) -> ListIpsResponse:
         """
         List IP addresses.
         List the Load Balancer flexible IP addresses held in the account (filtered by Organization ID or Project ID). It is also possible to search for a specific IP address.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of IP addresses to return.
         :param ip_address: IP address to filter for.
         :param organization_id: Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
         :param project_id: Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
+        :param ip_type: IP type to filter for.
         :return: :class:`ListIpsResponse <ListIpsResponse>`
 
         Usage:
         ::
 
             result = await api.list_i_ps()
         """
@@ -590,14 +607,15 @@
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
 
         res = self._request(
             "GET",
             f"/lb/v1/zones/{param_zone}/ips",
             params={
                 "ip_address": ip_address,
+                "ip_type": ip_type,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
             },
         )
@@ -610,24 +628,26 @@
         *,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         ip_address: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        ip_type: Optional[ListIpsRequestIpType] = None,
     ) -> List[Ip]:
         """
         List IP addresses.
         List the Load Balancer flexible IP addresses held in the account (filtered by Organization ID or Project ID). It is also possible to search for a specific IP address.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of IP addresses to return.
         :param ip_address: IP address to filter for.
         :param organization_id: Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
         :param project_id: Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
+        :param ip_type: IP type to filter for.
         :return: :class:`List[Ip] <List[Ip]>`
 
         Usage:
         ::
 
             result = await api.list_i_ps_all()
         """
@@ -639,47 +659,55 @@
             args={
                 "zone": zone,
                 "page": page,
                 "page_size": page_size,
                 "ip_address": ip_address,
                 "organization_id": organization_id,
                 "project_id": project_id,
+                "ip_type": ip_type,
             },
         )
 
     async def create_ip(
         self,
         *,
+        is_ipv6: bool,
         zone: Optional[Zone] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         reverse: Optional[str] = None,
     ) -> Ip:
         """
         Create an IP address.
         Create a new Load Balancer flexible IP address, in the specified Scaleway Project. This can be attached to new Load Balancers created in the future.
+        :param is_ipv6: If true, creates a Flexible IP with an ipv6 address.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param organization_id: Organization ID of the Organization where the IP address should be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: Project ID of the Project where the IP address should be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param reverse: Reverse DNS (domain name) for the IP address.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
-            result = await api.create_ip()
+            result = await api.create_ip(
+                is_ipv6=False,
+            )
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
 
         res = self._request(
             "POST",
             f"/lb/v1/zones/{param_zone}/ips",
             body=marshal_ZonedApiCreateIpRequest(
                 ZonedApiCreateIpRequest(
+                    is_ipv6=is_ipv6,
                     zone=zone,
                     reverse=reverse,
                     project_id=project_id,
                     organization_id=organization_id,
                 ),
                 self.client,
             ),
@@ -752,21 +780,23 @@
 
     async def update_ip(
         self,
         *,
         ip_id: str,
         zone: Optional[Zone] = None,
         reverse: Optional[str] = None,
+        lb_id: Optional[str] = None,
     ) -> Ip:
         """
         Update an IP address.
         Update the reverse DNS of a Load Balancer flexible IP address.
         :param ip_id: IP address ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param reverse: Reverse DNS (domain name) for the IP address.
+        :param lb_id: ID of the server on which to attach the flexible IP.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
             result = await api.update_ip(
                 ip_id="example",
@@ -780,14 +810,15 @@
             "PATCH",
             f"/lb/v1/zones/{param_zone}/ips/{param_ip_id}",
             body=marshal_ZonedApiUpdateIpRequest(
                 ZonedApiUpdateIpRequest(
                     ip_id=ip_id,
                     zone=zone,
                     reverse=reverse,
+                    lb_id=lb_id,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Ip(res.json())
@@ -1309,20 +1340,27 @@
         :param check_max_retries: Number of consecutive unsuccessful health checks after which the server will be considered dead.
         :param backend_id: Backend ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param check_delay: Time to wait between two consecutive health checks.
         :param check_timeout: Maximum time a backend server has to reply to the health check.
         :param check_send_proxy: Defines whether proxy protocol should be activated for the health check.
         :param tcp_config: Object to configure a basic TCP health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param mysql_config: Object to configure a MySQL health check. The check requires MySQL >=3.22, for older versions, use a TCP health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param pgsql_config: Object to configure a PostgreSQL health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param ldap_config: Object to configure an LDAP health check. The response is analyzed to find the LDAPv3 response message.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param redis_config: Object to configure a Redis health check. The response is analyzed to find the +PONG response message.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param http_config: Object to configure an HTTP health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param https_config: Object to configure an HTTPS health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param transient_check_delay: Time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
         :return: :class:`HealthCheck <HealthCheck>`
 
         Usage:
         ::
 
             result = await api.update_health_check(
@@ -1879,15 +1917,14 @@
         *,
         lb_id: str,
         zone: Optional[Zone] = None,
         backend_id: Optional[str] = None,
     ) -> LbStats:
         """
         Get usage statistics of a given Load Balancer.
-        Get usage statistics of a given Load Balancer.
         :param lb_id: Load Balancer ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param backend_id: ID of the backend.
         :return: :class:`LbStats <LbStats>`
         :deprecated
 
         Usage:
@@ -2315,15 +2352,17 @@
         """
         Create an SSL/TLS certificate.
         Generate a new SSL/TLS certificate for a given Load Balancer. You can choose to create a Let's Encrypt certificate, or import a custom certificate.
         :param lb_id: Load Balancer ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param name: Name for the certificate.
         :param letsencrypt: Object to define a new Let's Encrypt certificate to be generated.
+        One-Of ('type'): at most one of 'letsencrypt', 'custom_certificate' could be set.
         :param custom_certificate: Object to define an existing custom certificate to be imported.
+        One-Of ('type'): at most one of 'letsencrypt', 'custom_certificate' could be set.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
             result = await api.create_certificate(
                 lb_id="example",
@@ -2663,17 +2702,21 @@
     ) -> Subscriber:
         """
         Create a subscriber.
         Create a new subscriber, either with an email configuration or a webhook configuration, for a specified Scaleway Project.
         :param name: Subscriber name.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param email_config: Email address configuration.
+        One-Of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :param webhook_config: WebHook URI configuration.
+        One-Of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :param organization_id: Organization ID to create the subscriber in.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: Project ID to create the subscriber in.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
             result = await api.create_subscriber(
                 name="example",
@@ -2837,15 +2880,17 @@
         """
         Update a subscriber.
         Update the parameters of a given subscriber (e.g. name, webhook configuration, email configuration), specified by its subscriber ID.
         :param subscriber_id: Subscriber ID.
         :param name: Subscriber name.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param email_config: Email address configuration.
+        One-Of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :param webhook_config: Webhook URI configuration.
+        One-Of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
             result = await api.update_subscriber(
                 subscriber_id="example",
@@ -3075,16 +3120,19 @@
         """
         Attach a Load Balancer to a Private Network.
         Attach a specified Load Balancer to a specified Private Network, defining a static or DHCP configuration for the Load Balancer on the network.
         :param lb_id: Load Balancer ID.
         :param private_network_id: Private Network ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param static_config: Object containing an array of a local IP address for the Load Balancer on this Private Network.
+        One-Of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :param dhcp_config: Defines whether to let DHCP assign IP addresses.
+        One-Of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :param ipam_config: For internal use only.
+        One-Of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :return: :class:`PrivateNetwork <PrivateNetwork>`
 
         Usage:
         ::
 
             result = await api.attach_private_network(
                 lb_id="example",
@@ -3166,25 +3214,26 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         order_by: Optional[ListLbsRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        tags: Optional[List[str]] = None,
     ) -> ListLbsResponse:
         """
         List load balancers.
-        List load balancers.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Load Balancer name to filter for.
         :param order_by: Sort order of Load Balancers in the response.
         :param page_size: Number of Load Balancers to return.
         :param page: Page number to return, from the paginated results.
         :param organization_id: Organization ID to filter for, only Load Balancers from this Organization will be returned.
         :param project_id: Project ID to filter for, only Load Balancers from this Project will be returned.
+        :param tags: Filter by tag, only Load Balancers with one or more matching tags will be returned.
         :return: :class:`ListLbsResponse <ListLbsResponse>`
 
         Usage:
         ::
 
             result = await api.list_lbs()
         """
@@ -3200,14 +3249,15 @@
                 "name": name,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
+                "tags": tags,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListLbsResponse(res.json())
 
     async def list_lbs_all(
@@ -3216,25 +3266,26 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         order_by: Optional[ListLbsRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        tags: Optional[List[str]] = None,
     ) -> List[Lb]:
         """
         List load balancers.
-        List load balancers.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Load Balancer name to filter for.
         :param order_by: Sort order of Load Balancers in the response.
         :param page_size: Number of Load Balancers to return.
         :param page: Page number to return, from the paginated results.
         :param organization_id: Organization ID to filter for, only Load Balancers from this Organization will be returned.
         :param project_id: Project ID to filter for, only Load Balancers from this Project will be returned.
+        :param tags: Filter by tag, only Load Balancers with one or more matching tags will be returned.
         :return: :class:`List[Lb] <List[Lb]>`
 
         Usage:
         ::
 
             result = await api.list_lbs_all()
         """
@@ -3247,42 +3298,48 @@
                 "region": region,
                 "name": name,
                 "order_by": order_by,
                 "page_size": page_size,
                 "page": page,
                 "organization_id": organization_id,
                 "project_id": project_id,
+                "tags": tags,
             },
         )
 
     async def create_lb(
         self,
         *,
         description: str,
         type_: str,
         region: Optional[Region] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         name: Optional[str] = None,
         ip_id: Optional[str] = None,
         assign_flexible_ip: Optional[bool] = None,
+        assign_flexible_ipv6: Optional[bool] = None,
+        ip_ids: Optional[List[str]] = None,
         tags: Optional[List[str]] = None,
         ssl_compatibility_level: Optional[SSLCompatibilityLevel] = None,
     ) -> Lb:
         """
         Create a load balancer.
-        Create a load balancer.
         :param description: Description for the Load Balancer.
         :param type_: Load Balancer commercial offer type. Use the Load Balancer types endpoint to retrieve a list of available offer types.
         :param region: Region to target. If none is passed will use default region from the config.
         :param organization_id: Scaleway Organization to create the Load Balancer in.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: Scaleway Project to create the Load Balancer in.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param name: Name for the Load Balancer.
         :param ip_id: ID of an existing flexible IP address to attach to the Load Balancer.
         :param assign_flexible_ip: Defines whether to automatically assign a flexible public IP to lb. Default value is `false` (do not assign).
+        :param assign_flexible_ipv6: Defines whether to automatically assign a flexible public IPv6 to the Load Balancer. Default value is `false` (do not assign).
+        :param ip_ids: List of IP IDs to attach to the Load Balancer.
         :param tags: List of tags for the Load Balancer.
         :param ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and do not need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
@@ -3303,14 +3360,16 @@
                 CreateLbRequest(
                     description=description,
                     type_=type_,
                     region=region,
                     name=name or random_name(prefix="lb"),
                     ip_id=ip_id,
                     assign_flexible_ip=assign_flexible_ip,
+                    assign_flexible_ipv6=assign_flexible_ipv6,
+                    ip_ids=ip_ids,
                     tags=tags,
                     ssl_compatibility_level=ssl_compatibility_level,
                     project_id=project_id,
                     organization_id=organization_id,
                 ),
                 self.client,
             ),
@@ -3323,15 +3382,14 @@
         self,
         *,
         lb_id: str,
         region: Optional[Region] = None,
     ) -> Lb:
         """
         Get a load balancer.
-        Get a load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
@@ -3358,15 +3416,14 @@
         *,
         lb_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Lb, Union[bool, Awaitable[bool]]]] = None,
     ) -> Lb:
         """
         Get a load balancer.
-        Get a load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
@@ -3398,15 +3455,14 @@
         description: str,
         region: Optional[Region] = None,
         tags: Optional[List[str]] = None,
         ssl_compatibility_level: Optional[SSLCompatibilityLevel] = None,
     ) -> Lb:
         """
         Update a load balancer.
-        Update a load balancer.
         :param lb_id: Load Balancer ID.
         :param name: Load Balancer name.
         :param description: Load Balancer description.
         :param region: Region to target. If none is passed will use default region from the config.
         :param tags: List of tags for the Load Balancer.
         :param ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and don't need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
         :return: :class:`Lb <Lb>`
@@ -3450,15 +3506,14 @@
         *,
         lb_id: str,
         release_ip: bool,
         region: Optional[Region] = None,
     ) -> None:
         """
         Delete a load balancer.
-        Delete a load balancer.
         :param lb_id: ID of the Load Balancer to delete.
         :param release_ip: Defines whether the Load Balancer's flexible IP should be deleted. Set to true to release the flexible IP, or false to keep it available in your account for future Load Balancers.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
@@ -3488,15 +3543,14 @@
         *,
         lb_id: str,
         type_: str,
         region: Optional[Region] = None,
     ) -> Lb:
         """
         Migrate a load balancer.
-        Migrate a load balancer.
         :param lb_id: Load Balancer ID.
         :param type_: Load Balancer type to migrate to (use the List all Load Balancer offer types endpoint to get a list of available offer types).
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
@@ -3533,24 +3587,25 @@
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         ip_address: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        ip_type: Optional[ListIpsRequestIpType] = None,
     ) -> ListIpsResponse:
         """
         List IPs.
-        List IPs.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of IP addresses to return.
         :param ip_address: IP address to filter for.
         :param organization_id: Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
         :param project_id: Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
+        :param ip_type: IP type to filter for.
         :return: :class:`ListIpsResponse <ListIpsResponse>`
 
         Usage:
         ::
 
             result = await api.list_i_ps()
         """
@@ -3560,14 +3615,15 @@
         )
 
         res = self._request(
             "GET",
             f"/lb/v1/regions/{param_region}/ips",
             params={
                 "ip_address": ip_address,
+                "ip_type": ip_type,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
             },
         )
@@ -3580,24 +3636,25 @@
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         ip_address: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
+        ip_type: Optional[ListIpsRequestIpType] = None,
     ) -> List[Ip]:
         """
         List IPs.
-        List IPs.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of IP addresses to return.
         :param ip_address: IP address to filter for.
         :param organization_id: Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
         :param project_id: Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
+        :param ip_type: IP type to filter for.
         :return: :class:`List[Ip] <List[Ip]>`
 
         Usage:
         ::
 
             result = await api.list_i_ps_all()
         """
@@ -3609,49 +3666,56 @@
             args={
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "ip_address": ip_address,
                 "organization_id": organization_id,
                 "project_id": project_id,
+                "ip_type": ip_type,
             },
         )
 
     async def create_ip(
         self,
         *,
+        is_ipv6: bool,
         region: Optional[Region] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         reverse: Optional[str] = None,
     ) -> Ip:
         """
         Create an IP.
-        Create an IP.
+        :param is_ipv6: If true, creates a Flexible IP with an ipv6 address.
         :param region: Region to target. If none is passed will use default region from the config.
         :param organization_id: Organization ID of the Organization where the IP address should be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: Project ID of the Project where the IP address should be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param reverse: Reverse DNS (domain name) for the IP address.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
-            result = await api.create_ip()
+            result = await api.create_ip(
+                is_ipv6=False,
+            )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
             f"/lb/v1/regions/{param_region}/ips",
             body=marshal_CreateIpRequest(
                 CreateIpRequest(
+                    is_ipv6=is_ipv6,
                     region=region,
                     reverse=reverse,
                     project_id=project_id,
                     organization_id=organization_id,
                 ),
                 self.client,
             ),
@@ -3664,15 +3728,14 @@
         self,
         *,
         ip_id: str,
         region: Optional[Region] = None,
     ) -> Ip:
         """
         Get an IP.
-        Get an IP.
         :param ip_id: IP address ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
@@ -3698,15 +3761,14 @@
         self,
         *,
         ip_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         Delete an IP.
-        Delete an IP.
         :param ip_id: IP address ID.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.release_ip(
@@ -3728,21 +3790,22 @@
 
     async def update_ip(
         self,
         *,
         ip_id: str,
         region: Optional[Region] = None,
         reverse: Optional[str] = None,
+        lb_id: Optional[str] = None,
     ) -> Ip:
         """
         Update an IP.
-        Update an IP.
         :param ip_id: IP address ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param reverse: Reverse DNS (domain name) for the IP address.
+        :param lb_id: ID of the server on which to attach the flexible IP.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
             result = await api.update_ip(
                 ip_id="example",
@@ -3758,14 +3821,15 @@
             "PATCH",
             f"/lb/v1/regions/{param_region}/ips/{param_ip_id}",
             body=marshal_UpdateIpRequest(
                 UpdateIpRequest(
                     ip_id=ip_id,
                     region=region,
                     reverse=reverse,
+                    lb_id=lb_id,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Ip(res.json())
@@ -3778,15 +3842,14 @@
         name: Optional[str] = None,
         order_by: Optional[ListBackendsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListBackendsResponse:
         """
         List backends in a given load balancer.
-        List backends in a given load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the backend to filter for.
         :param order_by: Sort order of backends in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of backends to return.
         :return: :class:`ListBackendsResponse <ListBackendsResponse>`
@@ -3826,15 +3889,14 @@
         name: Optional[str] = None,
         order_by: Optional[ListBackendsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Backend]:
         """
         List backends in a given load balancer.
-        List backends in a given load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the backend to filter for.
         :param order_by: Sort order of backends in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of backends to return.
         :return: :class:`List[Backend] <List[Backend]>`
@@ -3886,15 +3948,14 @@
         redispatch_attempt_count: Optional[int] = None,
         max_retries: Optional[int] = None,
         max_connections: Optional[int] = None,
         timeout_queue: Optional[str] = None,
     ) -> Backend:
         """
         Create a backend in a given load balancer.
-        Create a backend in a given load balancer.
         :param forward_protocol: Protocol to be used by the backend when forwarding traffic to backend servers.
         :param forward_port: Port to be used by the backend when forwarding traffic to backend servers.
         :param forward_port_algorithm: Load balancing algorithm to be used when determining which backend server to forward new traffic to.
         :param sticky_sessions: Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie TO stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
         :param sticky_sessions_cookie_name: Cookie name for cookie-based sticky sessions.
         :param lb_id: Load Balancer ID.
         :param health_check: Object defining the health check to be carried out by the backend when checking the status and health of backend servers.
@@ -3976,15 +4037,14 @@
         self,
         *,
         backend_id: str,
         region: Optional[Region] = None,
     ) -> Backend:
         """
         Get a backend in a given load balancer.
-        Get a backend in a given load balancer.
         :param backend_id: Backend ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
@@ -4029,15 +4089,14 @@
         redispatch_attempt_count: Optional[int] = None,
         max_retries: Optional[int] = None,
         max_connections: Optional[int] = None,
         timeout_queue: Optional[str] = None,
     ) -> Backend:
         """
         Update a backend in a given load balancer.
-        Update a backend in a given load balancer.
         :param backend_id: Backend ID.
         :param name: Backend name.
         :param forward_protocol: Protocol to be used by the backend when forwarding traffic to backend servers.
         :param forward_port: Port to be used by the backend when forwarding traffic to backend servers.
         :param forward_port_algorithm: Load balancing algorithm to be used when determining which backend server to forward new traffic to.
         :param sticky_sessions: Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie to stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
         :param sticky_sessions_cookie_name: Cookie name for cookie-based sticky sessions.
@@ -4114,15 +4173,14 @@
         self,
         *,
         backend_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         Delete a backend in a given load balancer.
-        Delete a backend in a given load balancer.
         :param backend_id: ID of the backend to delete.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.delete_backend(
@@ -4147,15 +4205,14 @@
         *,
         backend_id: str,
         server_ip: List[str],
         region: Optional[Region] = None,
     ) -> Backend:
         """
         Add a set of servers in a given backend.
-        Add a set of servers in a given backend.
         :param backend_id: Backend ID.
         :param server_ip: List of IP addresses to add to backend servers.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
@@ -4192,15 +4249,14 @@
         *,
         backend_id: str,
         server_ip: List[str],
         region: Optional[Region] = None,
     ) -> Backend:
         """
         Remove a set of servers for a given backend.
-        Remove a set of servers for a given backend.
         :param backend_id: Backend ID.
         :param server_ip: List of IP addresses to remove from backend servers.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
@@ -4237,15 +4293,14 @@
         *,
         backend_id: str,
         server_ip: List[str],
         region: Optional[Region] = None,
     ) -> Backend:
         """
         Define all servers in a given backend.
-        Define all servers in a given backend.
         :param backend_id: Backend ID.
         :param server_ip: List of IP addresses for backend servers. Any other existing backend servers will be removed.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
@@ -4294,29 +4349,35 @@
         redis_config: Optional[HealthCheckRedisConfig] = None,
         http_config: Optional[HealthCheckHttpConfig] = None,
         https_config: Optional[HealthCheckHttpsConfig] = None,
         transient_check_delay: Optional[str] = None,
     ) -> HealthCheck:
         """
         Update an health check for a given backend.
-        Update an health check for a given backend.
         :param port: Port to use for the backend server health check.
         :param check_max_retries: Number of consecutive unsuccessful health checks after which the server will be considered dead.
         :param backend_id: Backend ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param check_delay: Time to wait between two consecutive health checks.
         :param check_timeout: Maximum time a backend server has to reply to the health check.
         :param check_send_proxy: Defines whether proxy protocol should be activated for the health check.
         :param tcp_config: Object to configure a basic TCP health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param mysql_config: Object to configure a MySQL health check. The check requires MySQL >=3.22, for older versions, use a TCP health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param pgsql_config: Object to configure a PostgreSQL health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param ldap_config: Object to configure an LDAP health check. The response is analyzed to find the LDAPv3 response message.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param redis_config: Object to configure a Redis health check. The response is analyzed to find the +PONG response message.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param http_config: Object to configure an HTTP health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param https_config: Object to configure an HTTPS health check.
+        One-Of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
         :param transient_check_delay: Time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
         :return: :class:`HealthCheck <HealthCheck>`
 
         Usage:
         ::
 
             result = await api.update_health_check(
@@ -4368,15 +4429,14 @@
         name: Optional[str] = None,
         order_by: Optional[ListFrontendsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListFrontendsResponse:
         """
         List frontends in a given load balancer.
-        List frontends in a given load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the frontend to filter for.
         :param order_by: Sort order of frontends in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of frontends to return.
         :return: :class:`ListFrontendsResponse <ListFrontendsResponse>`
@@ -4416,15 +4476,14 @@
         name: Optional[str] = None,
         order_by: Optional[ListFrontendsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Frontend]:
         """
         List frontends in a given load balancer.
-        List frontends in a given load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the frontend to filter for.
         :param order_by: Sort order of frontends in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of frontends to return.
         :return: :class:`List[Frontend] <List[Frontend]>`
@@ -4462,15 +4521,14 @@
         name: Optional[str] = None,
         timeout_client: Optional[str] = None,
         certificate_id: Optional[str] = None,
         certificate_ids: Optional[List[str]] = None,
     ) -> Frontend:
         """
         Create a frontend in a given load balancer.
-        Create a frontend in a given load balancer.
         :param inbound_port: Port the frontend should listen on.
         :param lb_id: Load Balancer ID (ID of the Load Balancer to attach the frontend to).
         :param backend_id: Backend ID (ID of the backend the frontend should pass traffic to).
         :param enable_http3: Defines whether to enable HTTP/3 protocol on the frontend.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name for the frontend.
         :param timeout_client: Maximum allowed inactivity time on the client side.
@@ -4520,15 +4578,14 @@
         self,
         *,
         frontend_id: str,
         region: Optional[Region] = None,
     ) -> Frontend:
         """
         Get a frontend.
-        Get a frontend.
         :param frontend_id: Frontend ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Frontend <Frontend>`
 
         Usage:
         ::
 
@@ -4561,15 +4618,14 @@
         region: Optional[Region] = None,
         timeout_client: Optional[str] = None,
         certificate_id: Optional[str] = None,
         certificate_ids: Optional[List[str]] = None,
     ) -> Frontend:
         """
         Update a frontend.
-        Update a frontend.
         :param frontend_id: Frontend ID.
         :param name: Frontend name.
         :param inbound_port: Port the frontend should listen on.
         :param backend_id: Backend ID (ID of the backend the frontend should pass traffic to).
         :param enable_http3: Defines whether to enable HTTP/3 protocol on the frontend.
         :param region: Region to target. If none is passed will use default region from the config.
         :param timeout_client: Maximum allowed inactivity time on the client side.
@@ -4620,15 +4676,14 @@
         self,
         *,
         frontend_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         Delete a frontend.
-        Delete a frontend.
         :param frontend_id: ID of the frontend to delete.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.delete_frontend(
@@ -4655,15 +4710,14 @@
         order_by: Optional[ListRoutesRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         frontend_id: Optional[str] = None,
     ) -> ListRoutesResponse:
         """
         List all backend redirections.
-        List all backend redirections.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of routes in the response.
         :param page_size: The number of route objects to return.
         :param page: The page number to return, from the paginated results.
         :param frontend_id: Frontend ID to filter for, only Routes from this Frontend will be returned.
         :return: :class:`ListRoutesResponse <ListRoutesResponse>`
 
@@ -4698,15 +4752,14 @@
         order_by: Optional[ListRoutesRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         frontend_id: Optional[str] = None,
     ) -> List[Route]:
         """
         List all backend redirections.
-        List all backend redirections.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of routes in the response.
         :param page_size: The number of route objects to return.
         :param page: The page number to return, from the paginated results.
         :param frontend_id: Frontend ID to filter for, only Routes from this Frontend will be returned.
         :return: :class:`List[Route] <List[Route]>`
 
@@ -4735,15 +4788,14 @@
         frontend_id: str,
         backend_id: str,
         region: Optional[Region] = None,
         match: Optional[RouteMatch] = None,
     ) -> Route:
         """
         Create a backend redirection.
-        Create a backend redirection.
         :param frontend_id: ID of the source frontend to create the route on.
         :param backend_id: ID of the target backend for the route.
         :param region: Region to target. If none is passed will use default region from the config.
         :param match: Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
         :return: :class:`Route <Route>`
 
         Usage:
@@ -4780,15 +4832,14 @@
         self,
         *,
         route_id: str,
         region: Optional[Region] = None,
     ) -> Route:
         """
         Get single backend redirection.
-        Get single backend redirection.
         :param route_id: Route ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
@@ -4816,15 +4867,14 @@
         route_id: str,
         backend_id: str,
         region: Optional[Region] = None,
         match: Optional[RouteMatch] = None,
     ) -> Route:
         """
         Edit a backend redirection.
-        Edit a backend redirection.
         :param route_id: Route ID.
         :param backend_id: ID of the target backend for the route.
         :param region: Region to target. If none is passed will use default region from the config.
         :param match: Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
         :return: :class:`Route <Route>`
 
         Usage:
@@ -4862,15 +4912,14 @@
         self,
         *,
         route_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         Delete a backend redirection.
-        Delete a backend redirection.
         :param route_id: Route ID.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.delete_route(
@@ -4895,15 +4944,14 @@
         *,
         lb_id: str,
         region: Optional[Region] = None,
         backend_id: Optional[str] = None,
     ) -> LbStats:
         """
         Get usage statistics of a given load balancer.
-        Get usage statistics of a given load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param backend_id: ID of the backend.
         :return: :class:`LbStats <LbStats>`
         :deprecated
 
         Usage:
@@ -4937,15 +4985,14 @@
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         backend_id: Optional[str] = None,
     ) -> ListBackendStatsResponse:
         """
         List backend server statistics.
-        List backend server statistics.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of items to return.
         :param backend_id: ID of the backend.
         :return: :class:`ListBackendStatsResponse <ListBackendStatsResponse>`
 
@@ -4982,15 +5029,14 @@
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         backend_id: Optional[str] = None,
     ) -> List[BackendServerStats]:
         """
         List backend server statistics.
-        List backend server statistics.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of items to return.
         :param backend_id: ID of the backend.
         :return: :class:`List[BackendServerStats] <List[BackendServerStats]>`
 
@@ -5023,15 +5069,14 @@
         order_by: Optional[ListAclRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> ListAclResponse:
         """
         List ACL for a given frontend.
-        List ACL for a given frontend.
         :param frontend_id: Frontend ID (ACLs attached to this frontend will be returned in the response).
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of ACLs in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: The number of ACLs to return.
         :param name: ACL name to filter for.
         :return: :class:`ListAclResponse <ListAclResponse>`
@@ -5071,15 +5116,14 @@
         order_by: Optional[ListAclRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> List[Acl]:
         """
         List ACL for a given frontend.
-        List ACL for a given frontend.
         :param frontend_id: Frontend ID (ACLs attached to this frontend will be returned in the response).
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of ACLs in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: The number of ACLs to return.
         :param name: ACL name to filter for.
         :return: :class:`List[Acl] <List[Acl]>`
@@ -5115,15 +5159,14 @@
         description: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         match: Optional[AclMatch] = None,
     ) -> Acl:
         """
         Create an ACL for a given frontend.
-        Create an ACL for a given frontend.
         :param frontend_id: Frontend ID to attach the ACL to.
         :param action: Action to take when incoming traffic matches an ACL filter.
         :param index: Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
         :param description: ACL description.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: ACL name.
         :param match: ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
@@ -5169,15 +5212,14 @@
         self,
         *,
         acl_id: str,
         region: Optional[Region] = None,
     ) -> Acl:
         """
         Get an ACL.
-        Get an ACL.
         :param acl_id: ACL ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Acl <Acl>`
 
         Usage:
         ::
 
@@ -5208,15 +5250,14 @@
         index: int,
         region: Optional[Region] = None,
         match: Optional[AclMatch] = None,
         description: Optional[str] = None,
     ) -> Acl:
         """
         Update an ACL.
-        Update an ACL.
         :param acl_id: ACL ID.
         :param name: ACL name.
         :param action: Action to take when incoming traffic matches an ACL filter.
         :param index: Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
         :param region: Region to target. If none is passed will use default region from the config.
         :param match: ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
         :param description: ACL description.
@@ -5262,15 +5303,14 @@
         self,
         *,
         acl_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         Delete an ACL.
-        Delete an ACL.
         :param acl_id: ACL ID.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.delete_acl(
@@ -5302,15 +5342,17 @@
         """
         Create a TLS certificate.
         Generate a new TLS certificate using Let's Encrypt or import your certificate.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name for the certificate.
         :param letsencrypt: Object to define a new Let's Encrypt certificate to be generated.
+        One-Of ('type'): at most one of 'letsencrypt', 'custom_certificate' could be set.
         :param custom_certificate: Object to define an existing custom certificate to be imported.
+        One-Of ('type'): at most one of 'letsencrypt', 'custom_certificate' could be set.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
             result = await api.create_certificate(
                 lb_id="example",
@@ -5348,15 +5390,14 @@
         order_by: Optional[ListCertificatesRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> ListCertificatesResponse:
         """
         List all TLS certificates on a given load balancer.
-        List all TLS certificates on a given load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of certificates in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of certificates to return.
         :param name: Certificate name to filter for, only certificates of this name will be returned.
         :return: :class:`ListCertificatesResponse <ListCertificatesResponse>`
@@ -5396,15 +5437,14 @@
         order_by: Optional[ListCertificatesRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> List[Certificate]:
         """
         List all TLS certificates on a given load balancer.
-        List all TLS certificates on a given load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of certificates in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: Number of certificates to return.
         :param name: Certificate name to filter for, only certificates of this name will be returned.
         :return: :class:`List[Certificate] <List[Certificate]>`
@@ -5435,15 +5475,14 @@
         self,
         *,
         certificate_id: str,
         region: Optional[Region] = None,
     ) -> Certificate:
         """
         Get a TLS certificate.
-        Get a TLS certificate.
         :param certificate_id: Certificate ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
@@ -5472,15 +5511,14 @@
         region: Optional[Region] = None,
         options: Optional[
             WaitForOptions[Certificate, Union[bool, Awaitable[bool]]]
         ] = None,
     ) -> Certificate:
         """
         Get a TLS certificate.
-        Get a TLS certificate.
         :param certificate_id: Certificate ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
@@ -5509,15 +5547,14 @@
         *,
         certificate_id: str,
         name: str,
         region: Optional[Region] = None,
     ) -> Certificate:
         """
         Update a TLS certificate.
-        Update a TLS certificate.
         :param certificate_id: Certificate ID.
         :param name: Certificate name.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
@@ -5553,15 +5590,14 @@
         self,
         *,
         certificate_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         Delete a TLS certificate.
-        Delete a TLS certificate.
         :param certificate_id: Certificate ID.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.delete_certificate(
@@ -5586,15 +5622,14 @@
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListLbTypesResponse:
         """
         List all load balancer offer type.
-        List all load balancer offer type.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: The page number to return, from the paginated results.
         :param page_size: The number of items to return.
         :return: :class:`ListLbTypesResponse <ListLbTypesResponse>`
 
         Usage:
         ::
@@ -5623,15 +5658,14 @@
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[LbType]:
         """
         List all load balancer offer type.
-        List all load balancer offer type.
         :param region: Region to target. If none is passed will use default region from the config.
         :param page: The page number to return, from the paginated results.
         :param page_size: The number of items to return.
         :return: :class:`List[LbType] <List[LbType]>`
 
         Usage:
         ::
@@ -5658,21 +5692,24 @@
         email_config: Optional[SubscriberEmailConfig] = None,
         webhook_config: Optional[SubscriberWebhookConfig] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> Subscriber:
         """
         Create a subscriber, webhook or email.
-        Create a subscriber, webhook or email.
         :param name: Subscriber name.
         :param region: Region to target. If none is passed will use default region from the config.
         :param email_config: Email address configuration.
+        One-Of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :param webhook_config: WebHook URI configuration.
+        One-Of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :param organization_id: Organization ID to create the subscriber in.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: Project ID to create the subscriber in.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
             result = await api.create_subscriber(
                 name="example",
@@ -5706,15 +5743,14 @@
         self,
         *,
         subscriber_id: str,
         region: Optional[Region] = None,
     ) -> Subscriber:
         """
         Get a subscriber.
-        Get a subscriber.
         :param subscriber_id: Subscriber ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
@@ -5745,15 +5781,14 @@
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListSubscriberResponse:
         """
         List all subscriber.
-        List all subscriber.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of subscribers in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: The number of items to return.
         :param name: Subscriber name to search for.
         :param organization_id: Filter subscribers by Organization ID.
         :param project_id: Filter subscribers by Project ID.
@@ -5795,15 +5830,14 @@
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Subscriber]:
         """
         List all subscriber.
-        List all subscriber.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of subscribers in the response.
         :param page: The page number to return, from the paginated results.
         :param page_size: The number of items to return.
         :param name: Subscriber name to search for.
         :param organization_id: Filter subscribers by Organization ID.
         :param project_id: Filter subscribers by Project ID.
@@ -5837,20 +5871,21 @@
         name: str,
         region: Optional[Region] = None,
         email_config: Optional[SubscriberEmailConfig] = None,
         webhook_config: Optional[SubscriberWebhookConfig] = None,
     ) -> Subscriber:
         """
         Update a subscriber.
-        Update a subscriber.
         :param subscriber_id: Subscriber ID.
         :param name: Subscriber name.
         :param region: Region to target. If none is passed will use default region from the config.
         :param email_config: Email address configuration.
+        One-Of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :param webhook_config: Webhook URI configuration.
+        One-Of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
             result = await api.update_subscriber(
                 subscriber_id="example",
@@ -5885,15 +5920,14 @@
         self,
         *,
         subscriber_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         Delete a subscriber.
-        Delete a subscriber.
         :param subscriber_id: Subscriber ID.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.delete_subscriber(
@@ -5918,15 +5952,14 @@
         *,
         lb_id: str,
         subscriber_id: str,
         region: Optional[Region] = None,
     ) -> Lb:
         """
         Subscribe a subscriber to a given load balancer.
-        Subscribe a subscriber to a given load balancer.
         :param lb_id: Load Balancer ID.
         :param subscriber_id: Subscriber ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
@@ -5962,15 +5995,14 @@
         self,
         *,
         lb_id: str,
         region: Optional[Region] = None,
     ) -> Lb:
         """
         Unsubscribe a subscriber from a given load balancer.
-        Unsubscribe a subscriber from a given load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
@@ -5999,15 +6031,14 @@
         region: Optional[Region] = None,
         order_by: Optional[ListPrivateNetworksRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListLbPrivateNetworksResponse:
         """
         List attached private network of load balancer.
-        List attached private network of load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of Private Network objects in the response.
         :param page_size: Number of objects to return.
         :param page: The page number to return, from the paginated results.
         :return: :class:`ListLbPrivateNetworksResponse <ListLbPrivateNetworksResponse>`
 
@@ -6044,15 +6075,14 @@
         region: Optional[Region] = None,
         order_by: Optional[ListPrivateNetworksRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[PrivateNetwork]:
         """
         List attached private network of load balancer.
-        List attached private network of load balancer.
         :param lb_id: Load Balancer ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of Private Network objects in the response.
         :param page_size: Number of objects to return.
         :param page: The page number to return, from the paginated results.
         :return: :class:`List[PrivateNetwork] <List[PrivateNetwork]>`
 
@@ -6085,21 +6115,23 @@
         region: Optional[Region] = None,
         static_config: Optional[PrivateNetworkStaticConfig] = None,
         dhcp_config: Optional[PrivateNetworkDHCPConfig] = None,
         ipam_config: Optional[PrivateNetworkIpamConfig] = None,
     ) -> PrivateNetwork:
         """
         Add load balancer on instance private network.
-        Add load balancer on instance private network.
         :param lb_id: Load Balancer ID.
         :param private_network_id: Private Network ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param static_config: Object containing an array of a local IP address for the Load Balancer on this Private Network.
+        One-Of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :param dhcp_config: Defines whether to let DHCP assign IP addresses.
+        One-Of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :param ipam_config: For internal use only.
+        One-Of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :return: :class:`PrivateNetwork <PrivateNetwork>`
 
         Usage:
         ::
 
             result = await api.attach_private_network(
                 lb_id="example",
@@ -6139,15 +6171,14 @@
         *,
         lb_id: str,
         private_network_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         Remove load balancer of private network.
-        Remove load balancer of private network.
         :param lb_id: Load balancer ID.
         :param private_network_id: Set your instance private network id.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/content.py` & `scaleway_async-2.1.0/scaleway_async/lb/v1/content.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,13 +29,13 @@
     LbStatus.CREATING,
     LbStatus.TO_DELETE,
     LbStatus.DELETING,
 ]
 """
 Lists transient statutes of the enum :class:`LbStatus <LbStatus>`.
 """
-PRIVATENETWORK_TRANSIENT_STATUSES: List[PrivateNetworkStatus] = [
+PRIVATE_NETWORK_TRANSIENT_STATUSES: List[PrivateNetworkStatus] = [
     PrivateNetworkStatus.PENDING,
 ]
 """
 Lists transient statutes of the enum :class:`PrivateNetworkStatus <PrivateNetworkStatus>`.
 """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/lb/v1/marshalling.py`

 * *Files 2% similar despite different names*

```diff
@@ -136,18 +136,22 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("lb_id", None)
     if field is not None:
         args["lb_id"] = field
+    else:
+        args["lb_id"] = None
 
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
+    else:
+        args["region"] = None
 
     return Ip(**args)
 
 
 def unmarshal_SubscriberEmailConfig(data: Any) -> SubscriberEmailConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -193,18 +197,22 @@
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
     field = data.get("email_config", None)
     if field is not None:
         args["email_config"] = unmarshal_SubscriberEmailConfig(field)
+    else:
+        args["email_config"] = None
 
     field = data.get("webhook_config", None)
     if field is not None:
         args["webhook_config"] = unmarshal_SubscriberWebhookConfig(field)
+    else:
+        args["webhook_config"] = None
 
     return Subscriber(**args)
 
 
 def unmarshal_HealthCheckHttpConfig(data: Any) -> HealthCheckHttpConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -224,14 +232,16 @@
     field = data.get("host_header", None)
     if field is not None:
         args["host_header"] = field
 
     field = data.get("code", None)
     if field is not None:
         args["code"] = field
+    else:
+        args["code"] = None
 
     return HealthCheckHttpConfig(**args)
 
 
 def unmarshal_HealthCheckHttpsConfig(data: Any) -> HealthCheckHttpsConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -255,14 +265,16 @@
     field = data.get("sni", None)
     if field is not None:
         args["sni"] = field
 
     field = data.get("code", None)
     if field is not None:
         args["code"] = field
+    else:
+        args["code"] = None
 
     return HealthCheckHttpsConfig(**args)
 
 
 def unmarshal_HealthCheckLdapConfig(data: Any) -> HealthCheckLdapConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -341,54 +353,74 @@
     field = data.get("check_max_retries", None)
     if field is not None:
         args["check_max_retries"] = field
 
     field = data.get("check_delay", None)
     if field is not None:
         args["check_delay"] = field
+    else:
+        args["check_delay"] = None
 
     field = data.get("check_timeout", None)
     if field is not None:
         args["check_timeout"] = field
+    else:
+        args["check_timeout"] = None
 
     field = data.get("tcp_config", None)
     if field is not None:
         args["tcp_config"] = unmarshal_HealthCheckTcpConfig(field)
+    else:
+        args["tcp_config"] = None
 
     field = data.get("mysql_config", None)
     if field is not None:
         args["mysql_config"] = unmarshal_HealthCheckMysqlConfig(field)
+    else:
+        args["mysql_config"] = None
 
     field = data.get("check_send_proxy", None)
     if field is not None:
         args["check_send_proxy"] = field
 
     field = data.get("pgsql_config", None)
     if field is not None:
         args["pgsql_config"] = unmarshal_HealthCheckPgsqlConfig(field)
+    else:
+        args["pgsql_config"] = None
 
     field = data.get("ldap_config", None)
     if field is not None:
         args["ldap_config"] = unmarshal_HealthCheckLdapConfig(field)
+    else:
+        args["ldap_config"] = None
 
     field = data.get("redis_config", None)
     if field is not None:
         args["redis_config"] = unmarshal_HealthCheckRedisConfig(field)
+    else:
+        args["redis_config"] = None
 
     field = data.get("http_config", None)
     if field is not None:
         args["http_config"] = unmarshal_HealthCheckHttpConfig(field)
+    else:
+        args["http_config"] = None
 
     field = data.get("https_config", None)
     if field is not None:
         args["https_config"] = unmarshal_HealthCheckHttpsConfig(field)
+    else:
+        args["https_config"] = None
 
     field = data.get("transient_check_delay", None)
     if field is not None:
         args["transient_check_delay"] = field
+    else:
+        args["transient_check_delay"] = None
 
     return HealthCheck(**args)
 
 
 def unmarshal_Instance(data: Any) -> Instance:
     if not isinstance(data, dict):
         raise TypeError(
@@ -412,22 +444,28 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
+    else:
+        args["region"] = None
 
     return Instance(**args)
 
 
 def unmarshal_Lb(data: Any) -> Lb:
     if not isinstance(data, dict):
         raise TypeError(
@@ -478,15 +516,15 @@
     if field is not None:
         args["frontend_count"] = field
 
     field = data.get("backend_count", None)
     if field is not None:
         args["backend_count"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("ssl_compatibility_level", None)
     if field is not None:
         args["ssl_compatibility_level"] = field
 
@@ -501,26 +539,34 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("subscriber", None)
     if field is not None:
         args["subscriber"] = unmarshal_Subscriber(field)
+    else:
+        args["subscriber"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
+    else:
+        args["region"] = None
 
     return Lb(**args)
 
 
 def unmarshal_Backend(data: Any) -> Backend:
     if not isinstance(data, dict):
         raise TypeError(
@@ -568,83 +614,113 @@
     field = data.get("proxy_protocol", None)
     if field is not None:
         args["proxy_protocol"] = field
 
     field = data.get("health_check", None)
     if field is not None:
         args["health_check"] = unmarshal_HealthCheck(field)
+    else:
+        args["health_check"] = None
 
     field = data.get("lb", None)
     if field is not None:
         args["lb"] = unmarshal_Lb(field)
+    else:
+        args["lb"] = None
 
     field = data.get("send_proxy_v2", None)
     if field is not None:
         args["send_proxy_v2"] = field
+    else:
+        args["send_proxy_v2"] = None
 
     field = data.get("timeout_server", None)
     if field is not None:
         args["timeout_server"] = field
+    else:
+        args["timeout_server"] = None
 
     field = data.get("timeout_connect", None)
     if field is not None:
         args["timeout_connect"] = field
+    else:
+        args["timeout_connect"] = None
 
     field = data.get("timeout_tunnel", None)
     if field is not None:
         args["timeout_tunnel"] = field
+    else:
+        args["timeout_tunnel"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("failover_host", None)
     if field is not None:
         args["failover_host"] = field
+    else:
+        args["failover_host"] = None
 
     field = data.get("ssl_bridging", None)
     if field is not None:
         args["ssl_bridging"] = field
+    else:
+        args["ssl_bridging"] = None
 
     field = data.get("ignore_ssl_server_verify", None)
     if field is not None:
         args["ignore_ssl_server_verify"] = field
+    else:
+        args["ignore_ssl_server_verify"] = None
 
     field = data.get("redispatch_attempt_count", None)
     if field is not None:
         args["redispatch_attempt_count"] = field
+    else:
+        args["redispatch_attempt_count"] = None
 
     field = data.get("max_retries", None)
     if field is not None:
         args["max_retries"] = field
+    else:
+        args["max_retries"] = None
 
     field = data.get("max_connections", None)
     if field is not None:
         args["max_connections"] = field
+    else:
+        args["max_connections"] = None
 
     field = data.get("timeout_queue", None)
     if field is not None:
         args["timeout_queue"] = field
+    else:
+        args["timeout_queue"] = None
 
     return Backend(**args)
 
 
 def unmarshal_Certificate(data: Any) -> Certificate:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Certificate' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
@@ -665,40 +741,52 @@
         args["status"] = field
 
     field = data.get("not_valid_before", None)
     if field is not None:
         args["not_valid_before"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["not_valid_before"] = None
 
     field = data.get("not_valid_after", None)
     if field is not None:
         args["not_valid_after"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["not_valid_after"] = None
 
     field = data.get("lb", None)
     if field is not None:
         args["lb"] = unmarshal_Lb(field)
+    else:
+        args["lb"] = None
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("status_details", None)
     if field is not None:
         args["status_details"] = field
+    else:
+        args["status_details"] = None
 
     return Certificate(**args)
 
 
 def unmarshal_Frontend(data: Any) -> Frontend:
     if not isinstance(data, dict):
         raise TypeError(
@@ -726,76 +814,92 @@
     field = data.get("enable_http3", None)
     if field is not None:
         args["enable_http3"] = field
 
     field = data.get("backend", None)
     if field is not None:
         args["backend"] = unmarshal_Backend(field)
+    else:
+        args["backend"] = None
 
     field = data.get("lb", None)
     if field is not None:
         args["lb"] = unmarshal_Lb(field)
+    else:
+        args["lb"] = None
 
     field = data.get("timeout_client", None)
     if field is not None:
         args["timeout_client"] = field
+    else:
+        args["timeout_client"] = None
 
     field = data.get("certificate", None)
     if field is not None:
         args["certificate"] = unmarshal_Certificate(field)
+    else:
+        args["certificate"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Frontend(**args)
 
 
 def unmarshal_AclActionRedirect(data: Any) -> AclActionRedirect:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'AclActionRedirect' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("target", None)
     if field is not None:
         args["target"] = field
 
     field = data.get("code", None)
     if field is not None:
         args["code"] = field
+    else:
+        args["code"] = None
 
     return AclActionRedirect(**args)
 
 
 def unmarshal_AclAction(data: Any) -> AclAction:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'AclAction' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("redirect", None)
     if field is not None:
         args["redirect"] = unmarshal_AclActionRedirect(field)
+    else:
+        args["redirect"] = None
 
     return AclAction(**args)
 
 
 def unmarshal_AclMatch(data: Any) -> AclMatch:
     if not isinstance(data, dict):
         raise TypeError(
@@ -819,14 +923,16 @@
     field = data.get("invert", None)
     if field is not None:
         args["invert"] = field
 
     field = data.get("http_filter_option", None)
     if field is not None:
         args["http_filter_option"] = field
+    else:
+        args["http_filter_option"] = None
 
     return AclMatch(**args)
 
 
 def unmarshal_Acl(data: Any) -> Acl:
     if not isinstance(data, dict):
         raise TypeError(
@@ -850,30 +956,40 @@
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
     field = data.get("match", None)
     if field is not None:
         args["match"] = unmarshal_AclMatch(field)
+    else:
+        args["match"] = None
 
     field = data.get("action", None)
     if field is not None:
         args["action"] = unmarshal_AclAction(field)
+    else:
+        args["action"] = None
 
     field = data.get("frontend", None)
     if field is not None:
         args["frontend"] = unmarshal_Frontend(field)
+    else:
+        args["frontend"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Acl(**args)
 
 
 def unmarshal_PrivateNetworkDHCPConfig(data: Any) -> PrivateNetworkDHCPConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -881,14 +997,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("ip_id", None)
     if field is not None:
         args["ip_id"] = field
+    else:
+        args["ip_id"] = None
 
     return PrivateNetworkDHCPConfig(**args)
 
 
 def unmarshal_PrivateNetworkIpamConfig(data: Any) -> PrivateNetworkIpamConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -907,14 +1025,16 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("ip_address", None)
     if field is not None:
         args["ip_address"] = field
+    else:
+        args["ip_address"] = None
 
     return PrivateNetworkStaticConfig(**args)
 
 
 def unmarshal_PrivateNetwork(data: Any) -> PrivateNetwork:
     if not isinstance(data, dict):
         raise TypeError(
@@ -934,34 +1054,46 @@
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("lb", None)
     if field is not None:
         args["lb"] = unmarshal_Lb(field)
+    else:
+        args["lb"] = None
 
     field = data.get("static_config", None)
     if field is not None:
         args["static_config"] = unmarshal_PrivateNetworkStaticConfig(field)
+    else:
+        args["static_config"] = None
 
     field = data.get("dhcp_config", None)
     if field is not None:
         args["dhcp_config"] = unmarshal_PrivateNetworkDHCPConfig(field)
+    else:
+        args["dhcp_config"] = None
 
     field = data.get("ipam_config", None)
     if field is not None:
         args["ipam_config"] = unmarshal_PrivateNetworkIpamConfig(field)
+    else:
+        args["ipam_config"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return PrivateNetwork(**args)
 
 
 def unmarshal_RouteMatch(data: Any) -> RouteMatch:
     if not isinstance(data, dict):
         raise TypeError(
@@ -969,18 +1101,22 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("sni", None)
     if field is not None:
         args["sni"] = field
+    else:
+        args["sni"] = None
 
     field = data.get("host_header", None)
     if field is not None:
         args["host_header"] = field
+    else:
+        args["host_header"] = None
 
     return RouteMatch(**args)
 
 
 def unmarshal_Route(data: Any) -> Route:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1000,22 +1136,28 @@
     field = data.get("backend_id", None)
     if field is not None:
         args["backend_id"] = field
 
     field = data.get("match", None)
     if field is not None:
         args["match"] = unmarshal_RouteMatch(field)
+    else:
+        args["match"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Route(**args)
 
 
 def unmarshal_BackendServerStats(data: Any) -> BackendServerStats:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1045,14 +1187,16 @@
         args["last_health_check_status"] = field
 
     field = data.get("server_state_changed_at", None)
     if field is not None:
         args["server_state_changed_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["server_state_changed_at"] = None
 
     return BackendServerStats(**args)
 
 
 def unmarshal_LbStats(data: Any) -> LbStats:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1240,14 +1384,16 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
+    else:
+        args["region"] = None
 
     return LbType(**args)
 
 
 def unmarshal_ListLbTypesResponse(data: Any) -> ListLbTypesResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1794,14 +1940,17 @@
                     request.organization_id,
                     defaults.default_organization_id,
                 ),
             ]
         ),
     )
 
+    if request.is_ipv6 is not None:
+        output["is_ipv6"] = request.is_ipv6
+
     if request.reverse is not None:
         output["reverse"] = request.reverse
 
     return output
 
 
 def marshal_CreateLbRequest(
@@ -1835,14 +1984,20 @@
 
     if request.ip_id is not None:
         output["ip_id"] = request.ip_id
 
     if request.assign_flexible_ip is not None:
         output["assign_flexible_ip"] = request.assign_flexible_ip
 
+    if request.assign_flexible_ipv6 is not None:
+        output["assign_flexible_ipv6"] = request.assign_flexible_ipv6
+
+    if request.ip_ids is not None:
+        output["ip_ids"] = request.ip_ids
+
     if request.tags is not None:
         output["tags"] = request.tags
 
     if request.ssl_compatibility_level is not None:
         output["ssl_compatibility_level"] = str(request.ssl_compatibility_level)
 
     return output
@@ -2166,14 +2321,17 @@
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.reverse is not None:
         output["reverse"] = request.reverse
 
+    if request.lb_id is not None:
+        output["lb_id"] = request.lb_id
+
     return output
 
 
 def marshal_UpdateLbRequest(
     request: UpdateLbRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
@@ -2421,14 +2579,17 @@
                     request.organization_id,
                     defaults.default_organization_id,
                 ),
             ]
         ),
     )
 
+    if request.is_ipv6 is not None:
+        output["is_ipv6"] = request.is_ipv6
+
     if request.reverse is not None:
         output["reverse"] = request.reverse
 
     return output
 
 
 def marshal_ZonedApiCreateLbRequest(
@@ -2462,14 +2623,20 @@
 
     if request.ip_id is not None:
         output["ip_id"] = request.ip_id
 
     if request.assign_flexible_ip is not None:
         output["assign_flexible_ip"] = request.assign_flexible_ip
 
+    if request.assign_flexible_ipv6 is not None:
+        output["assign_flexible_ipv6"] = request.assign_flexible_ipv6
+
+    if request.ip_ids is not None:
+        output["ip_ids"] = request.ip_ids
+
     if request.tags is not None:
         output["tags"] = request.tags
 
     if request.ssl_compatibility_level is not None:
         output["ssl_compatibility_level"] = str(request.ssl_compatibility_level)
 
     return output
@@ -2788,14 +2955,17 @@
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.reverse is not None:
         output["reverse"] = request.reverse
 
+    if request.lb_id is not None:
+        output["lb_id"] = request.lb_id
+
     return output
 
 
 def marshal_ZonedApiUpdateLbRequest(
     request: ZonedApiUpdateLbRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/lb/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/lb/v1/types.py`

 * *Files 2% similar despite different names*

```diff
@@ -167,14 +167,23 @@
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
+class ListIpsRequestIpType(str, Enum, metaclass=StrEnumMeta):
+    ALL = "all"
+    IPV4 = "ipv4"
+    IPV6 = "ipv6"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 class ListLbsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
@@ -1456,14 +1465,19 @@
     """
     List of SSL/TLS certificate IDs to bind to the frontend.
     """
 
 
 @dataclass
 class CreateIpRequest:
+    is_ipv6: bool
+    """
+    If true, creates a Flexible IP with an ipv6 address.
+    """
+
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
     reverse: Optional[str]
     """
@@ -1503,14 +1517,24 @@
     """
 
     assign_flexible_ip: Optional[bool]
     """
     Defines whether to automatically assign a flexible public IP to lb. Default value is `false` (do not assign).
     """
 
+    assign_flexible_ipv6: Optional[bool]
+    """
+    Defines whether to automatically assign a flexible public IPv6 to the Load Balancer. Default value is `false` (do not assign).
+    """
+
+    ip_ids: Optional[List[str]]
+    """
+    List of IP IDs to attach to the Load Balancer.
+    """
+
     tags: Optional[List[str]]
     """
     List of tags for the Load Balancer.
     """
 
     ssl_compatibility_level: Optional[SSLCompatibilityLevel]
     """
@@ -2071,14 +2095,19 @@
     """
 
     project_id: Optional[str]
     """
     Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
     """
 
+    ip_type: Optional[ListIpsRequestIpType]
+    """
+    IP type to filter for.
+    """
+
 
 @dataclass
 class ListIpsResponse:
     ips: List[Ip]
     """
     List of IP address objects.
     """
@@ -2194,14 +2223,19 @@
     """
 
     project_id: Optional[str]
     """
     Project ID to filter for, only Load Balancers from this Project will be returned.
     """
 
+    tags: Optional[List[str]]
+    """
+    Filter by tag, only Load Balancers with one or more matching tags will be returned.
+    """
+
 
 @dataclass
 class ListLbsResponse:
     lbs: List[Lb]
     """
     List of Load Balancer objects.
     """
@@ -2697,14 +2731,19 @@
     """
 
     reverse: Optional[str]
     """
     Reverse DNS (domain name) for the IP address.
     """
 
+    lb_id: Optional[str]
+    """
+    ID of the server on which to attach the flexible IP.
+    """
+
 
 @dataclass
 class UpdateLbRequest:
     lb_id: str
     """
     Load Balancer ID.
     """
@@ -3050,14 +3089,19 @@
     """
     List of SSL/TLS certificate IDs to bind to the frontend.
     """
 
 
 @dataclass
 class ZonedApiCreateIpRequest:
+    is_ipv6: bool
+    """
+    If true, creates a Flexible IP with an ipv6 address.
+    """
+
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     reverse: Optional[str]
     """
@@ -3097,14 +3141,24 @@
     """
 
     assign_flexible_ip: Optional[bool]
     """
     Defines whether to automatically assign a flexible public IP to lb. Default value is `false` (do not assign).
     """
 
+    assign_flexible_ipv6: Optional[bool]
+    """
+    Defines whether to automatically assign a flexible public IPv6 to the Load Balancer. Default value is `false` (do not assign).
+    """
+
+    ip_ids: Optional[List[str]]
+    """
+    List of IP IDs to attach to the Load Balancer.
+    """
+
     tags: Optional[List[str]]
     """
     List of tags for the Load Balancer.
     """
 
     ssl_compatibility_level: Optional[SSLCompatibilityLevel]
     """
@@ -3592,14 +3646,19 @@
     """
 
     project_id: Optional[str]
     """
     Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
     """
 
+    ip_type: Optional[ListIpsRequestIpType]
+    """
+    IP type to filter for.
+    """
+
 
 @dataclass
 class ZonedApiListLbPrivateNetworksRequest:
     lb_id: str
     """
     Load Balancer ID.
     """
@@ -3676,14 +3735,19 @@
     """
 
     project_id: Optional[str]
     """
     Project ID to filter for, only Load Balancers from this Project will be returned.
     """
 
+    tags: Optional[List[str]]
+    """
+    Filter by tag, only Load Balancers with one or more matching tags will be returned.
+    """
+
 
 @dataclass
 class ZonedApiListRoutesRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
@@ -4145,14 +4209,19 @@
     """
 
     reverse: Optional[str]
     """
     Reverse DNS (domain name) for the IP address.
     """
 
+    lb_id: Optional[str]
+    """
+    ID of the server on which to attach the flexible IP.
+    """
+
 
 @dataclass
 class ZonedApiUpdateLbRequest:
     lb_id: str
     """
     Load Balancer ID.
     """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/marketplace/v2/marshalling.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,224 +1,238 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 from dateutil import parser
 
 from .types import (
+    Category,
+    Image,
     LocalImage,
-    Organization,
     Version,
-    Image,
-    GetImageResponse,
-    GetVersionResponse,
+    ListCategoriesResponse,
     ListImagesResponse,
+    ListLocalImagesResponse,
     ListVersionsResponse,
 )
 
 
-def unmarshal_LocalImage(data: Any) -> LocalImage:
+def unmarshal_Category(data: Any) -> Category:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'LocalImage' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Category' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("compatible_commercial_types", None)
+    field = data.get("name", None)
     if field is not None:
-        args["compatible_commercial_types"] = field
+        args["name"] = field
 
-    field = data.get("arch", None)
+    field = data.get("description", None)
     if field is not None:
-        args["arch"] = field
+        args["description"] = field
 
-    field = data.get("zone", None)
-    if field is not None:
-        args["zone"] = field
+    return Category(**args)
 
-    return LocalImage(**args)
 
-
-def unmarshal_Organization(data: Any) -> Organization:
+def unmarshal_Image(data: Any) -> Image:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Organization' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Image' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
-    return Organization(**args)
-
-
-def unmarshal_Version(data: Any) -> Version:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Version' failed as data isn't a dictionary."
-        )
+    field = data.get("description", None)
+    if field is not None:
+        args["description"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("logo", None)
+    if field is not None:
+        args["logo"] = field
 
-    field = data.get("id", None)
+    field = data.get("categories", None)
     if field is not None:
-        args["id"] = field
+        args["categories"] = field
 
-    field = data.get("name", None)
+    field = data.get("label", None)
     if field is not None:
-        args["name"] = field
+        args["label"] = field
 
-    field = data.get("local_images", None)
+    field = data.get("created_at", None)
     if field is not None:
-        args["local_images"] = (
-            [unmarshal_LocalImage(v) for v in field] if field is not None else None
-        )
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
-    field = data.get("creation_date", None)
+    field = data.get("updated_at", None)
     if field is not None:
-        args["creation_date"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
-    field = data.get("modification_date", None)
+    field = data.get("valid_until", None)
     if field is not None:
-        args["modification_date"] = (
+        args["valid_until"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["valid_until"] = None
 
-    return Version(**args)
+    return Image(**args)
 
 
-def unmarshal_Image(data: Any) -> Image:
+def unmarshal_LocalImage(data: Any) -> LocalImage:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Image' failed as data isn't a dictionary."
+            "Unmarshalling the type 'LocalImage' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
-    field = data.get("description", None)
+    field = data.get("compatible_commercial_types", None)
     if field is not None:
-        args["description"] = field
+        args["compatible_commercial_types"] = field
 
-    field = data.get("logo", None)
+    field = data.get("arch", None)
     if field is not None:
-        args["logo"] = field
+        args["arch"] = field
 
-    field = data.get("categories", None)
+    field = data.get("zone", None)
     if field is not None:
-        args["categories"] = field
+        args["zone"] = field
 
     field = data.get("label", None)
     if field is not None:
         args["label"] = field
 
-    field = data.get("versions", None)
+    field = data.get("type", None)
     if field is not None:
-        args["versions"] = (
-            [unmarshal_Version(v) for v in field] if field is not None else None
+        args["type_"] = field
+
+    return LocalImage(**args)
+
+
+def unmarshal_Version(data: Any) -> Version:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'Version' failed as data isn't a dictionary."
         )
 
-    field = data.get("current_public_version", None)
+    args: Dict[str, Any] = {}
+
+    field = data.get("id", None)
     if field is not None:
-        args["current_public_version"] = field
+        args["id"] = field
 
-    field = data.get("creation_date", None)
+    field = data.get("name", None)
     if field is not None:
-        args["creation_date"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["name"] = field
 
-    field = data.get("modification_date", None)
+    field = data.get("created_at", None)
     if field is not None:
-        args["modification_date"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
-    field = data.get("valid_until", None)
+    field = data.get("updated_at", None)
     if field is not None:
-        args["valid_until"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
-    field = data.get("organization", None)
+    field = data.get("published_at", None)
     if field is not None:
-        args["organization"] = unmarshal_Organization(field)
+        args["published_at"] = (
+            parser.isoparse(field) if isinstance(field, str) else field
+        )
+    else:
+        args["published_at"] = None
 
-    return Image(**args)
+    return Version(**args)
 
 
-def unmarshal_GetImageResponse(data: Any) -> GetImageResponse:
+def unmarshal_ListCategoriesResponse(data: Any) -> ListCategoriesResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'GetImageResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListCategoriesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("image", None)
+    field = data.get("categories", None)
     if field is not None:
-        args["image"] = unmarshal_Image(field)
+        args["categories"] = (
+            [unmarshal_Category(v) for v in field] if field is not None else None
+        )
 
-    return GetImageResponse(**args)
+    field = data.get("total_count", None)
+    if field is not None:
+        args["total_count"] = field
+
+    return ListCategoriesResponse(**args)
 
 
-def unmarshal_GetVersionResponse(data: Any) -> GetVersionResponse:
+def unmarshal_ListImagesResponse(data: Any) -> ListImagesResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'GetVersionResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("version", None)
+    field = data.get("images", None)
+    if field is not None:
+        args["images"] = (
+            [unmarshal_Image(v) for v in field] if field is not None else None
+        )
+
+    field = data.get("total_count", None)
     if field is not None:
-        args["version"] = unmarshal_Version(field)
+        args["total_count"] = field
 
-    return GetVersionResponse(**args)
+    return ListImagesResponse(**args)
 
 
-def unmarshal_ListImagesResponse(data: Any) -> ListImagesResponse:
+def unmarshal_ListLocalImagesResponse(data: Any) -> ListLocalImagesResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListLocalImagesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("images", None)
+    field = data.get("local_images", None)
     if field is not None:
-        args["images"] = (
-            [unmarshal_Image(v) for v in field] if field is not None else None
+        args["local_images"] = (
+            [unmarshal_LocalImage(v) for v in field] if field is not None else None
         )
 
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    return ListImagesResponse(**args)
+    return ListLocalImagesResponse(**args)
 
 
 def unmarshal_ListVersionsResponse(data: Any) -> ListVersionsResponse:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ListVersionsResponse' failed as data isn't a dictionary."
         )
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v2/__init__.py` & `scaleway_async-2.1.0/scaleway_async/marketplace/v2/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v2/api.py` & `scaleway_async-2.1.0/scaleway_async/marketplace/v2/api.py`

 * *Files 2% similar despite different names*

```diff
@@ -276,19 +276,22 @@
         zone: Optional[Zone] = None,
         type_: Optional[LocalImageType] = None,
     ) -> ListLocalImagesResponse:
         """
         List local images from a specific image or version.
         List information about local images in a specific Availability Zone, specified by its `image_id` (UUID format), `version_id` (UUID format) or `image_label`. Only one of these three parameters may be set.
         :param image_id:
+        One-Of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
         :param version_id:
+        One-Of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
         :param page_size:
         :param page:
         :param order_by:
         :param image_label:
+        One-Of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param type_:
         :return: :class:`ListLocalImagesResponse <ListLocalImagesResponse>`
 
         Usage:
         ::
 
@@ -329,19 +332,22 @@
         zone: Optional[Zone] = None,
         type_: Optional[LocalImageType] = None,
     ) -> List[LocalImage]:
         """
         List local images from a specific image or version.
         List information about local images in a specific Availability Zone, specified by its `image_id` (UUID format), `version_id` (UUID format) or `image_label`. Only one of these three parameters may be set.
         :param image_id:
+        One-Of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
         :param version_id:
+        One-Of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
         :param page_size:
         :param page:
         :param order_by:
         :param image_label:
+        One-Of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param type_:
         :return: :class:`List[LocalImage] <List[LocalImage]>`
 
         Usage:
         ::
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/marketplace/v2/types.py` & `scaleway_async-2.1.0/scaleway_async/marketplace/v2/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/mnq/v1beta1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/mnq/v1beta1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/mnq/v1beta1/api.py` & `scaleway_async-2.1.0/scaleway_async/mnq/v1beta1/api.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/mnq/v1beta1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/mnq/v1beta1/marshalling.py`

 * *Files 5% similar despite different names*

```diff
@@ -60,18 +60,22 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return NatsAccount(**args)
 
 
 def unmarshal_File(data: Any) -> File:
     if not isinstance(data, dict):
         raise TypeError(
@@ -114,22 +118,28 @@
     field = data.get("checksum", None)
     if field is not None:
         args["checksum"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("credentials", None)
     if field is not None:
         args["credentials"] = unmarshal_File(field)
+    else:
+        args["credentials"] = None
 
     return NatsCredentials(**args)
 
 
 def unmarshal_SnsPermissions(data: Any) -> SnsPermissions:
     if not isinstance(data, dict):
         raise TypeError(
@@ -137,22 +147,28 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("can_publish", None)
     if field is not None:
         args["can_publish"] = field
+    else:
+        args["can_publish"] = None
 
     field = data.get("can_receive", None)
     if field is not None:
         args["can_receive"] = field
+    else:
+        args["can_receive"] = None
 
     field = data.get("can_manage", None)
     if field is not None:
         args["can_manage"] = field
+    else:
+        args["can_manage"] = None
 
     return SnsPermissions(**args)
 
 
 def unmarshal_SnsCredentials(data: Any) -> SnsCredentials:
     if not isinstance(data, dict):
         raise TypeError(
@@ -188,22 +204,28 @@
     field = data.get("secret_checksum", None)
     if field is not None:
         args["secret_checksum"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("permissions", None)
     if field is not None:
         args["permissions"] = unmarshal_SnsPermissions(field)
+    else:
+        args["permissions"] = None
 
     return SnsCredentials(**args)
 
 
 def unmarshal_SqsPermissions(data: Any) -> SqsPermissions:
     if not isinstance(data, dict):
         raise TypeError(
@@ -211,22 +233,28 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("can_publish", None)
     if field is not None:
         args["can_publish"] = field
+    else:
+        args["can_publish"] = None
 
     field = data.get("can_receive", None)
     if field is not None:
         args["can_receive"] = field
+    else:
+        args["can_receive"] = None
 
     field = data.get("can_manage", None)
     if field is not None:
         args["can_manage"] = field
+    else:
+        args["can_manage"] = None
 
     return SqsPermissions(**args)
 
 
 def unmarshal_SqsCredentials(data: Any) -> SqsCredentials:
     if not isinstance(data, dict):
         raise TypeError(
@@ -262,22 +290,28 @@
     field = data.get("secret_checksum", None)
     if field is not None:
         args["secret_checksum"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("permissions", None)
     if field is not None:
         args["permissions"] = unmarshal_SqsPermissions(field)
+    else:
+        args["permissions"] = None
 
     return SqsCredentials(**args)
 
 
 def unmarshal_ListNatsAccountsResponse(data: Any) -> ListNatsAccountsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -385,18 +419,22 @@
     field = data.get("sns_endpoint_url", None)
     if field is not None:
         args["sns_endpoint_url"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return SnsInfo(**args)
 
 
 def unmarshal_SqsInfo(data: Any) -> SqsInfo:
     if not isinstance(data, dict):
         raise TypeError(
@@ -420,18 +458,22 @@
     field = data.get("sqs_endpoint_url", None)
     if field is not None:
         args["sqs_endpoint_url"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return SqsInfo(**args)
 
 
 def marshal_NatsApiCreateNatsAccountRequest(
     request: NatsApiCreateNatsAccountRequest,
     defaults: ProfileDefaults,
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/mnq/v1beta1/types.py` & `scaleway_async-2.1.0/scaleway_async/mnq/v1beta1/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/qaas/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/secret/v1alpha1/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,65 +1,93 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
-from .types import JobStatus
-from .content import JOB_TRANSIENT_STATUSES
-from .types import ListJobsRequestOrderBy
-from .types import ListPlatformsRequestOrderBy
-from .types import ListSessionsRequestOrderBy
-from .types import PlatformTechnology
-from .types import PlatformType
-from .types import SessionStatus
-from .content import SESSION_TRANSIENT_STATUSES
-from .types import JobCircuit
-from .types import Job
-from .types import Platform
-from .types import Session
-from .types import CancelJobRequest
-from .types import CreateJobRequest
-from .types import CreateSessionRequest
-from .types import DeleteSessionRequest
-from .types import GetJobCircuitRequest
-from .types import GetJobRequest
-from .types import GetPlatformRequest
-from .types import GetSessionRequest
-from .types import ListJobsRequest
-from .types import ListJobsResponse
-from .types import ListPlatformsRequest
-from .types import ListPlatformsResponse
-from .types import ListSessionsRequest
-from .types import ListSessionsResponse
-from .types import UpdateJobRequest
-from .types import UpdateSessionRequest
-from .api import QaasV1Alpha1API
+from .types import EphemeralPolicyAction
+from .types import ListFoldersRequestOrderBy
+from .types import ListSecretsRequestOrderBy
+from .types import Product
+from .types import SecretStatus
+from .types import SecretType
+from .types import SecretVersionStatus
+from .types import EphemeralProperties
+from .types import EphemeralPolicy
+from .types import PasswordGenerationParams
+from .types import Folder
+from .types import SecretVersion
+from .types import Secret
+from .types import AccessSecretVersionByNameRequest
+from .types import AccessSecretVersionRequest
+from .types import AccessSecretVersionResponse
+from .types import AddSecretOwnerRequest
+from .types import CreateFolderRequest
+from .types import CreateSecretRequest
+from .types import CreateSecretVersionRequest
+from .types import DeleteFolderRequest
+from .types import DeleteSecretRequest
+from .types import DestroySecretVersionRequest
+from .types import DisableSecretVersionRequest
+from .types import EnableSecretVersionRequest
+from .types import GeneratePasswordRequest
+from .types import GetSecretByNameRequest
+from .types import GetSecretRequest
+from .types import GetSecretVersionByNameRequest
+from .types import GetSecretVersionRequest
+from .types import ListFoldersRequest
+from .types import ListFoldersResponse
+from .types import ListSecretVersionsByNameRequest
+from .types import ListSecretVersionsRequest
+from .types import ListSecretVersionsResponse
+from .types import ListSecretsRequest
+from .types import ListSecretsResponse
+from .types import ListTagsRequest
+from .types import ListTagsResponse
+from .types import ProtectSecretRequest
+from .types import UnprotectSecretRequest
+from .types import UpdateSecretRequest
+from .types import UpdateSecretVersionRequest
+from .api import SecretV1Alpha1API
 
 __all__ = [
-    "JobStatus",
-    "JOB_TRANSIENT_STATUSES",
-    "ListJobsRequestOrderBy",
-    "ListPlatformsRequestOrderBy",
-    "ListSessionsRequestOrderBy",
-    "PlatformTechnology",
-    "PlatformType",
-    "SessionStatus",
-    "SESSION_TRANSIENT_STATUSES",
-    "JobCircuit",
-    "Job",
-    "Platform",
-    "Session",
-    "CancelJobRequest",
-    "CreateJobRequest",
-    "CreateSessionRequest",
-    "DeleteSessionRequest",
-    "GetJobCircuitRequest",
-    "GetJobRequest",
-    "GetPlatformRequest",
-    "GetSessionRequest",
-    "ListJobsRequest",
-    "ListJobsResponse",
-    "ListPlatformsRequest",
-    "ListPlatformsResponse",
-    "ListSessionsRequest",
-    "ListSessionsResponse",
-    "UpdateJobRequest",
-    "UpdateSessionRequest",
-    "QaasV1Alpha1API",
+    "EphemeralPolicyAction",
+    "ListFoldersRequestOrderBy",
+    "ListSecretsRequestOrderBy",
+    "Product",
+    "SecretStatus",
+    "SecretType",
+    "SecretVersionStatus",
+    "EphemeralProperties",
+    "EphemeralPolicy",
+    "PasswordGenerationParams",
+    "Folder",
+    "SecretVersion",
+    "Secret",
+    "AccessSecretVersionByNameRequest",
+    "AccessSecretVersionRequest",
+    "AccessSecretVersionResponse",
+    "AddSecretOwnerRequest",
+    "CreateFolderRequest",
+    "CreateSecretRequest",
+    "CreateSecretVersionRequest",
+    "DeleteFolderRequest",
+    "DeleteSecretRequest",
+    "DestroySecretVersionRequest",
+    "DisableSecretVersionRequest",
+    "EnableSecretVersionRequest",
+    "GeneratePasswordRequest",
+    "GetSecretByNameRequest",
+    "GetSecretRequest",
+    "GetSecretVersionByNameRequest",
+    "GetSecretVersionRequest",
+    "ListFoldersRequest",
+    "ListFoldersResponse",
+    "ListSecretVersionsByNameRequest",
+    "ListSecretVersionsRequest",
+    "ListSecretVersionsResponse",
+    "ListSecretsRequest",
+    "ListSecretsResponse",
+    "ListTagsRequest",
+    "ListTagsResponse",
+    "ProtectSecretRequest",
+    "UnprotectSecretRequest",
+    "UpdateSecretRequest",
+    "UpdateSecretVersionRequest",
+    "SecretV1Alpha1API",
 ]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/qaas/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/test/v1/marshalling.py`

 * *Files 27% similar despite different names*

```diff
@@ -6,366 +6,227 @@
 
 from scaleway_core.profile import ProfileDefaults
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from .types import (
-    JobCircuit,
-    Job,
-    Platform,
-    Session,
-    ListJobsResponse,
-    ListPlatformsResponse,
-    ListSessionsResponse,
-    CreateJobRequest,
-    CreateSessionRequest,
-    UpdateJobRequest,
-    UpdateSessionRequest,
+    Human,
+    ListHumansResponse,
+    RegisterResponse,
+    CreateHumanRequest,
+    RegisterRequest,
+    UpdateHumanRequest,
 )
 
 
-def unmarshal_JobCircuit(data: Any) -> JobCircuit:
+def unmarshal_Human(data: Any) -> Human:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'JobCircuit' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Human' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("perceval_circuit", None)
+    field = data.get("id", None)
     if field is not None:
-        args["perceval_circuit"] = field
-
-    return JobCircuit(**args)
-
-
-def unmarshal_Job(data: Any) -> Job:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Job' failed as data isn't a dictionary."
-        )
+        args["id"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("organization_id", None)
+    if field is not None:
+        args["organization_id"] = field
 
-    field = data.get("id", None)
+    field = data.get("height", None)
     if field is not None:
-        args["id"] = field
+        args["height"] = field
 
-    field = data.get("name", None)
+    field = data.get("shoe_size", None)
     if field is not None:
-        args["name"] = field
+        args["shoe_size"] = field
 
-    field = data.get("session_id", None)
+    field = data.get("altitude_in_meter", None)
     if field is not None:
-        args["session_id"] = field
+        args["altitude_in_meter"] = field
 
-    field = data.get("status", None)
+    field = data.get("altitude_in_millimeter", None)
     if field is not None:
-        args["status"] = field
+        args["altitude_in_millimeter"] = field
 
-    field = data.get("tags", None)
+    field = data.get("fingers_count", None)
     if field is not None:
-        args["tags"] = field
+        args["fingers_count"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("started_at", None)
-    if field is not None:
-        args["started_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
-    field = data.get("progress_message", None)
-    if field is not None:
-        args["progress_message"] = field
-
-    field = data.get("job_duration", None)
-    if field is not None:
-        args["job_duration"] = field
-
-    field = data.get("result_distribution", None)
-    if field is not None:
-        args["result_distribution"] = field
-
-    return Job(**args)
-
-
-def unmarshal_Platform(data: Any) -> Platform:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Platform' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("id", None)
-    if field is not None:
-        args["id"] = field
-
-    field = data.get("version", None)
-    if field is not None:
-        args["version"] = field
-
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
-    field = data.get("provider_name", None)
-    if field is not None:
-        args["provider_name"] = field
-
-    field = data.get("type_", None)
+    field = data.get("hair_count", None)
     if field is not None:
-        args["type_"] = field
+        args["hair_count"] = field
 
-    field = data.get("technology", None)
+    field = data.get("is_happy", None)
     if field is not None:
-        args["technology"] = field
+        args["is_happy"] = field
 
-    field = data.get("max_qubit_count", None)
+    field = data.get("eyes_color", None)
     if field is not None:
-        args["max_qubit_count"] = field
-
-    field = data.get("metadata", None)
-    if field is not None:
-        args["metadata"] = field
-
-    return Platform(**args)
-
+        args["eyes_color"] = field
 
-def unmarshal_Session(data: Any) -> Session:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Session' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("id", None)
+    field = data.get("status", None)
     if field is not None:
-        args["id"] = field
+        args["status"] = field
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
-    field = data.get("platform_id", None)
-    if field is not None:
-        args["platform_id"] = field
-
-    field = data.get("waiting_job_count", None)
-    if field is not None:
-        args["waiting_job_count"] = field
-
-    field = data.get("finished_job_count", None)
-    if field is not None:
-        args["finished_job_count"] = field
-
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
-
     field = data.get("project_id", None)
     if field is not None:
         args["project_id"] = field
 
-    field = data.get("deduplication_id", None)
-    if field is not None:
-        args["deduplication_id"] = field
-
-    field = data.get("created_at", None)
-    if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("started_at", None)
-    if field is not None:
-        args["started_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("update_at", None)
-    if field is not None:
-        args["update_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("max_idle_duration", None)
-    if field is not None:
-        args["max_idle_duration"] = field
-
-    field = data.get("max_duration", None)
-    if field is not None:
-        args["max_duration"] = field
-
-    field = data.get("tags", None)
-    if field is not None:
-        args["tags"] = field
-
-    return Session(**args)
-
-
-def unmarshal_ListJobsResponse(data: Any) -> ListJobsResponse:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'ListJobsResponse' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("total_count", None)
-    if field is not None:
-        args["total_count"] = field
-
-    field = data.get("jobs", None)
-    if field is not None:
-        args["jobs"] = [unmarshal_Job(v) for v in field] if field is not None else None
-
-    return ListJobsResponse(**args)
+    return Human(**args)
 
 
-def unmarshal_ListPlatformsResponse(data: Any) -> ListPlatformsResponse:
+def unmarshal_ListHumansResponse(data: Any) -> ListHumansResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListPlatformsResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListHumansResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    field = data.get("platforms", None)
+    field = data.get("humans", None)
     if field is not None:
-        args["platforms"] = (
-            [unmarshal_Platform(v) for v in field] if field is not None else None
+        args["humans"] = (
+            [unmarshal_Human(v) for v in field] if field is not None else None
         )
 
-    return ListPlatformsResponse(**args)
+    return ListHumansResponse(**args)
 
 
-def unmarshal_ListSessionsResponse(data: Any) -> ListSessionsResponse:
+def unmarshal_RegisterResponse(data: Any) -> RegisterResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListSessionsResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'RegisterResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count", None)
+    field = data.get("secret_key", None)
     if field is not None:
-        args["total_count"] = field
+        args["secret_key"] = field
 
-    field = data.get("sessions", None)
+    field = data.get("access_key", None)
     if field is not None:
-        args["sessions"] = (
-            [unmarshal_Session(v) for v in field] if field is not None else None
-        )
+        args["access_key"] = field
 
-    return ListSessionsResponse(**args)
+    return RegisterResponse(**args)
 
 
-def marshal_JobCircuit(
-    request: JobCircuit,
+def marshal_CreateHumanRequest(
+    request: CreateHumanRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
     output.update(
         resolve_one_of(
             [
-                OneOfPossibility("perceval_circuit", request.perceval_circuit),
+                OneOfPossibility(
+                    "project_id", request.project_id, defaults.default_project_id
+                ),
+                OneOfPossibility(
+                    "organization_id",
+                    request.organization_id,
+                    defaults.default_organization_id,
+                ),
             ]
         ),
     )
 
-    return output
+    if request.height is not None:
+        output["height"] = request.height
 
+    if request.shoe_size is not None:
+        output["shoe_size"] = request.shoe_size
 
-def marshal_CreateJobRequest(
-    request: CreateJobRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
+    if request.altitude_in_meter is not None:
+        output["altitude_in_meter"] = request.altitude_in_meter
 
-    if request.name is not None:
-        output["name"] = request.name
+    if request.altitude_in_millimeter is not None:
+        output["altitude_in_millimeter"] = request.altitude_in_millimeter
+
+    if request.fingers_count is not None:
+        output["fingers_count"] = request.fingers_count
 
-    if request.session_id is not None:
-        output["session_id"] = request.session_id
+    if request.hair_count is not None:
+        output["hair_count"] = request.hair_count
 
-    if request.circuit is not None:
-        output["circuit"] = (marshal_JobCircuit(request.circuit, defaults),)
+    if request.is_happy is not None:
+        output["is_happy"] = request.is_happy
 
-    if request.tags is not None:
-        output["tags"] = request.tags
+    if request.name is not None:
+        output["name"] = request.name
 
-    if request.max_duration is not None:
-        output["max_duration"] = request.max_duration
+    if request.eyes_color is not None:
+        output["eyes_color"] = str(request.eyes_color)
 
     return output
 
 
-def marshal_CreateSessionRequest(
-    request: CreateSessionRequest,
+def marshal_RegisterRequest(
+    request: RegisterRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.platform_id is not None:
-        output["platform_id"] = request.platform_id
-
-    if request.project_id is not None:
-        output["project_id"] = request.project_id or defaults.default_project_id
-
-    if request.name is not None:
-        output["name"] = request.name
-
-    if request.max_idle_duration is not None:
-        output["max_idle_duration"] = request.max_idle_duration
-
-    if request.max_duration is not None:
-        output["max_duration"] = request.max_duration
-
-    if request.tags is not None:
-        output["tags"] = request.tags
-
-    if request.deduplication_id is not None:
-        output["deduplication_id"] = request.deduplication_id
+    if request.username is not None:
+        output["username"] = request.username
 
     return output
 
 
-def marshal_UpdateJobRequest(
-    request: UpdateJobRequest,
+def marshal_UpdateHumanRequest(
+    request: UpdateHumanRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.name is not None:
-        output["name"] = request.name
+    if request.height is not None:
+        output["height"] = request.height
 
-    if request.tags is not None:
-        output["tags"] = request.tags
+    if request.shoe_size is not None:
+        output["shoe_size"] = request.shoe_size
 
-    return output
+    if request.altitude_in_meter is not None:
+        output["altitude_in_meter"] = request.altitude_in_meter
 
+    if request.altitude_in_millimeter is not None:
+        output["altitude_in_millimeter"] = request.altitude_in_millimeter
 
-def marshal_UpdateSessionRequest(
-    request: UpdateSessionRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    output: Dict[str, Any] = {}
+    if request.fingers_count is not None:
+        output["fingers_count"] = request.fingers_count
 
-    if request.name is not None:
-        output["name"] = request.name
+    if request.hair_count is not None:
+        output["hair_count"] = request.hair_count
 
-    if request.max_idle_duration is not None:
-        output["max_idle_duration"] = request.max_idle_duration
+    if request.is_happy is not None:
+        output["is_happy"] = request.is_happy
 
-    if request.max_duration is not None:
-        output["max_duration"] = request.max_duration
+    if request.eyes_color is not None:
+        output["eyes_color"] = str(request.eyes_color)
 
-    if request.tags is not None:
-        output["tags"] = request.tags
+    if request.name is not None:
+        output["name"] = request.name
 
     return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/qaas/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/registry/v1/types.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,569 +3,556 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
 from datetime import datetime
 from enum import Enum
 from typing import List, Optional
 
+from scaleway_core.bridge import (
+    Region,
+)
 from scaleway_core.utils import (
     StrEnumMeta,
 )
 
 
-class JobStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_STATUS = "unknown_status"
-    WAITING = "waiting"
+class ImageStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN = "unknown"
+    READY = "ready"
+    DELETING = "deleting"
     ERROR = "error"
-    RUNNING = "running"
-    COMPLETED = "completed"
-    CANCELLING = "cancelling"
-    CANCELLED = "cancelled"
+    LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListJobsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
-    CREATED_AT_DESC = "created_at_desc"
-    CREATED_AT_ASC = "created_at_asc"
-    STATUS_ASC = "status_asc"
-    STATUS_DESC = "status_desc"
-    PLATFORM_NAME_ASC = "platform_name_asc"
-    PLATFORM_NAME_DESC = "platform_name_desc"
-    NAME_ASC = "name_asc"
-    NAME_DESC = "name_desc"
-    SESSION_NAME_ASC = "session_name_asc"
-    SESSION_NAME_DESC = "session_name_desc"
+class ImageVisibility(str, Enum, metaclass=StrEnumMeta):
+    VISIBILITY_UNKNOWN = "visibility_unknown"
+    INHERIT = "inherit"
+    PUBLIC = "public"
+    PRIVATE = "private"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListPlatformsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+class ListImagesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
-    PROVIDER_NAME_ASC = "provider_name_asc"
-    PROVIDER_NAME_DESC = "provider_name_desc"
-    TYPE_ASC = "type_asc"
-    TYPE_DESC = "type_desc"
-    TECHNOLOGY_ASC = "technology_asc"
-    TECHNOLOGY_DESC = "technology_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListSessionsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+class ListNamespacesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
+    DESCRIPTION_ASC = "description_asc"
+    DESCRIPTION_DESC = "description_desc"
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
-    STARTED_AT_ASC = "started_at_asc"
-    STARTED_AT_DESC = "started_at_desc"
-    STATUS_ASC = "status_asc"
-    STATUS_DESC = "status_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class PlatformTechnology(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_TECHNOLOGY = "unknown_technology"
-    PHOTONIC = "photonic"
+class ListTagsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
+    NAME_ASC = "name_asc"
+    NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class PlatformType(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_TYPE = "unknown_type"
-    SIMULATOR = "simulator"
-    QPU = "qpu"
+class NamespaceStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN = "unknown"
+    READY = "ready"
+    DELETING = "deleting"
+    ERROR = "error"
+    LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SessionStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_STATUS = "unknown_status"
-    RUNNING = "running"
-    STOPPED = "stopped"
-    STARTING = "starting"
-    STOPPING = "stopping"
+class TagStatus(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN = "unknown"
+    READY = "ready"
+    DELETING = "deleting"
+    ERROR = "error"
+    LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
-class JobCircuit:
-    perceval_circuit: Optional[str]
-
-
-@dataclass
-class Job:
+class Image:
     id: str
     """
-    Unique ID of the job.
+    UUID of the image.
     """
 
     name: str
     """
-    Job name.
+    Name of the image, it must be unique within the namespace.
     """
 
-    session_id: str
+    namespace_id: str
     """
-    Session ID in which the job is executed.
+    UUID of the namespace the image belongs to.
     """
 
-    status: JobStatus
+    status: ImageStatus
     """
-    Job status.
+    Status of the image.
     """
 
-    tags: Optional[List[str]]
+    visibility: ImageVisibility
     """
-    Tags of the job.
+    Set to `public` to allow the image to be pulled without authentication. Else, set to  `private`. Set to `inherit` to keep the same visibility configuration as the namespace.
     """
 
-    created_at: Optional[datetime]
-    """
-    Time at which the job was created.
-    """
-
-    started_at: Optional[datetime]
+    size: int
     """
-    Time at which the job was started.
+    Image size in bytes, calculated from the size of image layers. One layer used in two tags of the same image is counted once but one layer used in two images is counted twice.
     """
 
-    updated_at: Optional[datetime]
+    tags: List[str]
     """
-    Time at which the job was updated.
+    List of docker tags of the image.
     """
 
-    progress_message: Optional[str]
+    status_message: Optional[str]
     """
-    Last progress message, if the job has started.
+    Details of the image status.
     """
 
-    job_duration: Optional[str]
+    created_at: Optional[datetime]
     """
-    Duration of the job, if the job is finished.
+    Date and time of image creation.
     """
 
-    result_distribution: Optional[str]
+    updated_at: Optional[datetime]
     """
-    Result of the job, if the job is finished.
+    Date and time of last update.
     """
 
 
 @dataclass
-class Platform:
+class Namespace:
     id: str
     """
-    Unique ID of the platform.
-    """
-
-    version: str
-    """
-    Verison of the platform.
+    UUID of the namespace.
     """
 
     name: str
     """
-    Name of the platform.
+    Name of the namespace, unique in a region accross all organizations.
     """
 
-    provider_name: str
+    description: str
     """
-    Provider name of the platform.
+    Description of the namespace.
     """
 
-    type_: PlatformType
+    organization_id: str
     """
-    Type of the platform.
+    Owner of the namespace.
     """
 
-    technology: PlatformTechnology
+    project_id: str
     """
-    Technology used by the platform.
+    Project of the namespace.
     """
 
-    max_qubit_count: int
+    status: NamespaceStatus
     """
-    Maximum number of qubits supported by the platform.
+    Namespace status.
     """
 
-    metadata: str
+    status_message: str
     """
-    Metadata provided by the platform.
+    Namespace status details.
     """
 
-
-@dataclass
-class Session:
-    id: str
+    endpoint: str
     """
-    Unique ID of the session.
+    Endpoint reachable by docker.
     """
 
-    name: str
+    is_public: bool
     """
-    Name of the session.
+    Defines whether or not namespace is public.
     """
 
-    platform_id: str
+    size: int
     """
-    Platform ID for which the session has been created.
+    Total size of the namespace, calculated as the sum of the size of all images in the namespace.
     """
 
-    waiting_job_count: int
+    image_count: int
     """
-    Number of waiting jobs linked to the session.
+    Number of images in the namespace.
     """
 
-    finished_job_count: int
+    region: Region
     """
-    Number of finished jobs linked to the session.
+    Region the namespace belongs to.
     """
 
-    status: SessionStatus
+    created_at: Optional[datetime]
     """
-    Status of the session.
+    Date and time of creation.
     """
 
-    project_id: str
+    updated_at: Optional[datetime]
     """
-    Project ID in which the session has been created.
+    Date and time of last update.
     """
 
-    deduplication_id: str
+
+@dataclass
+class Tag:
+    id: str
     """
-    Deduplication ID of the session.
+    UUID of the tag.
     """
 
-    created_at: Optional[datetime]
+    name: str
     """
-    Time at which the session has been created.
+    Tag name, unique to an image.
     """
 
-    started_at: Optional[datetime]
+    image_id: str
     """
-    Time at which the session has been started.
+    Image ID the of the image the tag belongs to.
     """
 
-    update_at: Optional[datetime]
+    status: TagStatus
     """
-    Time at which the session has been updated.
+    Tag status.
     """
 
-    max_idle_duration: Optional[str]
+    digest: str
     """
-    Maximum idle duration before the session ends.
+    Hash of the tag content. Several tags of a same image may have the same digest.
     """
 
-    max_duration: Optional[str]
+    created_at: Optional[datetime]
     """
-    Maximum duration before the session ends.
+    Date and time of creation.
     """
 
-    tags: Optional[List[str]]
+    updated_at: Optional[datetime]
     """
-    Tags of the session.
+    Date and time of last update.
     """
 
 
 @dataclass
-class CancelJobRequest:
-    job_id: str
+class CreateNamespaceRequest:
+    description: str
     """
-    Unique ID of the job.
+    Description of the namespace.
     """
 
-
-@dataclass
-class CreateJobRequest:
-    name: str
+    is_public: bool
     """
-    Name of the job.
+    Defines whether or not namespace is public.
     """
 
-    session_id: str
+    region: Optional[Region]
     """
-    Session in which the job is executed.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    circuit: JobCircuit
+    name: Optional[str]
     """
-    Quantum circuit that should be executed.
+    Name of the namespace.
     """
 
-    tags: Optional[List[str]]
+    project_id: Optional[str]
+
+    organization_id: Optional[str]
+
+
+@dataclass
+class DeleteImageRequest:
+    image_id: str
     """
-    Tags of the job.
+    UUID of the image.
     """
 
-    max_duration: Optional[str]
+    region: Optional[Region]
     """
-    Maximum duration of the job.
+    Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
-class CreateSessionRequest:
-    platform_id: str
+class DeleteNamespaceRequest:
+    namespace_id: str
     """
-    ID of the Platform for which the session was created.
+    UUID of the namespace.
     """
 
-    project_id: Optional[str]
+    region: Optional[Region]
     """
-    ID of the Project in which the session was created.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+
+@dataclass
+class DeleteTagRequest:
+    tag_id: str
     """
-    Name of the session.
+    UUID of the tag.
     """
 
-    max_idle_duration: Optional[str]
+    region: Optional[Region]
     """
-    Maximum idle duration before the session ends.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    max_duration: Optional[str]
+    force: Optional[bool]
     """
-    Maximum duration before the session ends.
+    If two tags share the same digest the deletion will fail unless this parameter is set to true (deprecated).
     """
 
-    tags: Optional[List[str]]
+
+@dataclass
+class GetImageRequest:
+    image_id: str
     """
-    Tags of the session.
+    UUID of the image.
     """
 
-    deduplication_id: Optional[str]
+    region: Optional[Region]
     """
-    Deduplication ID of the session.
+    Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
-class DeleteSessionRequest:
-    session_id: str
+class GetNamespaceRequest:
+    namespace_id: str
     """
-    Unique ID of the session.
+    UUID of the namespace.
     """
 
-
-@dataclass
-class GetJobCircuitRequest:
-    job_id: str
+    region: Optional[Region]
     """
-    Unique ID of the job.
+    Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
-class GetJobRequest:
-    job_id: str
+class GetTagRequest:
+    tag_id: str
     """
-    Unique ID of the job you want to get.
+    UUID of the tag.
     """
 
-
-@dataclass
-class GetPlatformRequest:
-    platform_id: str
+    region: Optional[Region]
     """
-    Unique ID of the platform.
+    Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
-class GetSessionRequest:
-    session_id: str
+class ListImagesRequest:
+    region: Optional[Region]
     """
-    Unique ID of the session.
+    Region to target. If none is passed will use default region from the config.
     """
 
+    page: Optional[int]
+    """
+    A positive integer to choose the page to display.
+    """
 
-@dataclass
-class ListJobsRequest:
-    tags: Optional[List[str]]
+    page_size: Optional[int]
     """
-    List jobs with these tags.
+    A positive integer lower or equal to 100 to select the number of items to display.
     """
 
-    page: Optional[int]
+    order_by: Optional[ListImagesRequestOrderBy]
     """
-    Page number.
+    Criteria to use when ordering image listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
     """
 
-    page_size: Optional[int]
+    namespace_id: Optional[str]
     """
-    Maximum number of jobs to return per page.
+    Filter by the namespace ID.
     """
 
-    order_by: Optional[ListJobsRequestOrderBy]
+    name: Optional[str]
     """
-    Sort order of the returned jobs.
+    Filter by the image name (exact match).
     """
 
-    session_id: Optional[str]
+    organization_id: Optional[str]
+    """
+    Filter by Organization ID.
+    """
 
     project_id: Optional[str]
+    """
+    Filter by Project ID.
+    """
 
 
 @dataclass
-class ListJobsResponse:
-    total_count: int
+class ListImagesResponse:
+    images: List[Image]
     """
-    Total number of jobs.
+    Paginated list of images that match the selected filters.
     """
 
-    jobs: List[Job]
+    total_count: int
     """
-    List of jobs.
+    Total number of images that match the selected filters.
     """
 
 
 @dataclass
-class ListPlatformsRequest:
-    provider_name: Optional[str]
+class ListNamespacesRequest:
+    region: Optional[Region]
     """
-    List platforms with this provider name.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+    page: Optional[int]
     """
-    List platforms with this name.
+    A positive integer to choose the page to display.
     """
 
-    platform_type: Optional[PlatformType]
+    page_size: Optional[int]
     """
-    List platforms with this type.
+    A positive integer lower or equal to 100 to select the number of items to display.
     """
 
-    platform_technology: Optional[PlatformTechnology]
+    order_by: Optional[ListNamespacesRequestOrderBy]
     """
-    List platforms with this technology.
+    Criteria to use when ordering namespace listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
     """
 
-    page: Optional[int]
+    organization_id: Optional[str]
     """
-    Page number.
+    Filter by Organization ID.
     """
 
-    page_size: Optional[int]
+    project_id: Optional[str]
     """
-    Maximum number of platforms to return per page.
+    Filter by Project ID.
     """
 
-    order_by: Optional[ListPlatformsRequestOrderBy]
+    name: Optional[str]
     """
-    Sort order of the returned platforms.
+    Filter by the namespace name (exact match).
     """
 
 
 @dataclass
-class ListPlatformsResponse:
-    total_count: int
+class ListNamespacesResponse:
+    namespaces: List[Namespace]
     """
-    Total number of platforms.
+    Paginated list of namespaces that match the selected filters.
     """
 
-    platforms: List[Platform]
+    total_count: int
     """
-    List of platforms.
+    Total number of namespaces that match the selected filters.
     """
 
 
 @dataclass
-class ListSessionsRequest:
-    platform_id: Optional[str]
+class ListTagsRequest:
+    image_id: str
     """
-    List sessions that have been created for this platform.
+    UUID of the image.
     """
 
-    tags: Optional[List[str]]
+    region: Optional[Region]
     """
-    List sessions with these tags.
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    Page number.
+    A positive integer to choose the page to display.
     """
 
     page_size: Optional[int]
     """
-    Maximum number of sessions to return per page.
+    A positive integer lower or equal to 100 to select the number of items to display.
     """
 
-    order_by: Optional[ListSessionsRequestOrderBy]
+    order_by: Optional[ListTagsRequestOrderBy]
     """
-    Sort order of the returned sessions.
+    Criteria to use when ordering tag listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
     """
 
-    project_id: Optional[str]
+    name: Optional[str]
     """
-    List sessions belonging to this project ID.
+    Filter by the tag name (exact match).
     """
 
 
 @dataclass
-class ListSessionsResponse:
-    total_count: int
+class ListTagsResponse:
+    tags: List[Tag]
     """
-    Total number of sessions.
+    Paginated list of tags that match the selected filters.
     """
 
-    sessions: List[Session]
+    total_count: int
     """
-    List of sessions.
+    Total number of tags that match the selected filters.
     """
 
 
 @dataclass
-class UpdateJobRequest:
-    job_id: str
+class UpdateImageRequest:
+    image_id: str
     """
-    Unique ID of the job.
+    ID of the image to update.
     """
 
-    name: Optional[str]
+    region: Optional[Region]
     """
-    Name of the job.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    tags: Optional[List[str]]
+    visibility: Optional[ImageVisibility]
     """
-    Tags of the job.
+    Set to `public` to allow the image to be pulled without authentication. Else, set to  `private`. Set to `inherit` to keep the same visibility configuration as the namespace.
     """
 
 
 @dataclass
-class UpdateSessionRequest:
-    session_id: str
-    """
-    Unique ID of the session.
-    """
-
-    name: Optional[str]
+class UpdateNamespaceRequest:
+    namespace_id: str
     """
-    Name of the session.
+    ID of the namespace to update.
     """
 
-    max_idle_duration: Optional[str]
+    region: Optional[Region]
     """
-    Maximum idle duration before the session ends.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    max_duration: Optional[str]
+    description: Optional[str]
     """
-    Maximum duration before the session ends.
+    Namespace description.
     """
 
-    tags: Optional[List[str]]
+    is_public: Optional[bool]
     """
-    Tags of the session.
+    Defines whether or not the namespace is public.
     """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/rdb/v1/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import ACLRuleAction
 from .types import ACLRuleDirection
 from .types import ACLRuleProtocol
 from .types import DatabaseBackupStatus
-from .content import DATABASEBACKUP_TRANSIENT_STATUSES
+from .content import DATABASE_BACKUP_TRANSIENT_STATUSES
+from .types import EndpointPrivateNetworkDetailsProvisioningMode
 from .types import EngineSettingPropertyType
 from .types import InstanceLogStatus
-from .content import INSTANCELOG_TRANSIENT_STATUSES
+from .content import INSTANCE_LOG_TRANSIENT_STATUSES
 from .types import InstanceStatus
 from .content import INSTANCE_TRANSIENT_STATUSES
 from .types import ListDatabaseBackupsRequestOrderBy
 from .types import ListDatabasesRequestOrderBy
 from .types import ListInstanceLogsRequestOrderBy
 from .types import ListInstancesRequestOrderBy
 from .types import ListPrivilegesRequestOrderBy
@@ -19,15 +20,15 @@
 from .types import ListUsersRequestOrderBy
 from .types import MaintenanceStatus
 from .content import MAINTENANCE_TRANSIENT_STATUSES
 from .types import NodeTypeGeneration
 from .types import NodeTypeStock
 from .types import Permission
 from .types import ReadReplicaStatus
-from .content import READREPLICA_TRANSIENT_STATUSES
+from .content import READ_REPLICA_TRANSIENT_STATUSES
 from .types import SnapshotStatus
 from .content import SNAPSHOT_TRANSIENT_STATUSES
 from .types import StorageClass
 from .types import VolumeType
 from .types import EndpointDirectAccessDetails
 from .types import EndpointLoadBalancerDetails
 from .types import EndpointPrivateNetworkDetails
@@ -45,14 +46,15 @@
 from .types import LogsPolicy
 from .types import Maintenance
 from .types import ReadReplica
 from .types import UpgradableVersion
 from .types import Volume
 from .types import NodeTypeVolumeConstraintSizes
 from .types import NodeTypeVolumeType
+from .types import SnapshotVolumeType
 from .types import ACLRuleRequest
 from .types import ACLRule
 from .types import EndpointSpec
 from .types import ReadReplicaEndpointSpec
 from .types import DatabaseBackup
 from .types import DatabaseEngine
 from .types import Database
@@ -64,14 +66,15 @@
 from .types import Snapshot
 from .types import User
 from .types import UpgradeInstanceRequestMajorUpgradeWorkflow
 from .types import AddInstanceACLRulesRequest
 from .types import AddInstanceACLRulesResponse
 from .types import AddInstanceSettingsRequest
 from .types import AddInstanceSettingsResponse
+from .types import ApplyInstanceMaintenanceRequest
 from .types import CloneInstanceRequest
 from .types import CreateDatabaseBackupRequest
 from .types import CreateDatabaseRequest
 from .types import CreateEndpointRequest
 from .types import CreateInstanceFromSnapshotRequest
 from .types import CreateInstanceRequest
 from .types import CreateReadReplicaEndpointRequest
@@ -143,18 +146,19 @@
 from .api import RdbV1API
 
 __all__ = [
     "ACLRuleAction",
     "ACLRuleDirection",
     "ACLRuleProtocol",
     "DatabaseBackupStatus",
-    "DATABASEBACKUP_TRANSIENT_STATUSES",
+    "DATABASE_BACKUP_TRANSIENT_STATUSES",
+    "EndpointPrivateNetworkDetailsProvisioningMode",
     "EngineSettingPropertyType",
     "InstanceLogStatus",
-    "INSTANCELOG_TRANSIENT_STATUSES",
+    "INSTANCE_LOG_TRANSIENT_STATUSES",
     "InstanceStatus",
     "INSTANCE_TRANSIENT_STATUSES",
     "ListDatabaseBackupsRequestOrderBy",
     "ListDatabasesRequestOrderBy",
     "ListInstanceLogsRequestOrderBy",
     "ListInstancesRequestOrderBy",
     "ListPrivilegesRequestOrderBy",
@@ -162,15 +166,15 @@
     "ListUsersRequestOrderBy",
     "MaintenanceStatus",
     "MAINTENANCE_TRANSIENT_STATUSES",
     "NodeTypeGeneration",
     "NodeTypeStock",
     "Permission",
     "ReadReplicaStatus",
-    "READREPLICA_TRANSIENT_STATUSES",
+    "READ_REPLICA_TRANSIENT_STATUSES",
     "SnapshotStatus",
     "SNAPSHOT_TRANSIENT_STATUSES",
     "StorageClass",
     "VolumeType",
     "EndpointDirectAccessDetails",
     "EndpointLoadBalancerDetails",
     "EndpointPrivateNetworkDetails",
@@ -188,14 +192,15 @@
     "LogsPolicy",
     "Maintenance",
     "ReadReplica",
     "UpgradableVersion",
     "Volume",
     "NodeTypeVolumeConstraintSizes",
     "NodeTypeVolumeType",
+    "SnapshotVolumeType",
     "ACLRuleRequest",
     "ACLRule",
     "EndpointSpec",
     "ReadReplicaEndpointSpec",
     "DatabaseBackup",
     "DatabaseEngine",
     "Database",
@@ -207,14 +212,15 @@
     "Snapshot",
     "User",
     "UpgradeInstanceRequestMajorUpgradeWorkflow",
     "AddInstanceACLRulesRequest",
     "AddInstanceACLRulesResponse",
     "AddInstanceSettingsRequest",
     "AddInstanceSettingsResponse",
+    "ApplyInstanceMaintenanceRequest",
     "CloneInstanceRequest",
     "CreateDatabaseBackupRequest",
     "CreateDatabaseRequest",
     "CreateEndpointRequest",
     "CreateInstanceFromSnapshotRequest",
     "CreateInstanceRequest",
     "CreateReadReplicaEndpointRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/rdb/v1/api.py`

 * *Files 1% similar despite different names*

```diff
@@ -64,14 +64,15 @@
     ListInstanceLogsResponse,
     ListInstancesResponse,
     ListNodeTypesResponse,
     ListPrivilegesResponse,
     ListSnapshotsResponse,
     ListUsersResponse,
     LogsPolicy,
+    Maintenance,
     MigrateEndpointRequest,
     NodeType,
     PrepareInstanceLogsRequest,
     PrepareInstanceLogsResponse,
     Privilege,
     PurgeInstanceLogsRequest,
     ReadReplica,
@@ -88,22 +89,23 @@
     UpdateSnapshotRequest,
     UpdateUserRequest,
     UpgradeInstanceRequest,
     UpgradeInstanceRequestMajorUpgradeWorkflow,
     User,
 )
 from .content import (
-    DATABASEBACKUP_TRANSIENT_STATUSES,
-    INSTANCELOG_TRANSIENT_STATUSES,
+    DATABASE_BACKUP_TRANSIENT_STATUSES,
+    INSTANCE_LOG_TRANSIENT_STATUSES,
     INSTANCE_TRANSIENT_STATUSES,
-    READREPLICA_TRANSIENT_STATUSES,
+    READ_REPLICA_TRANSIENT_STATUSES,
     SNAPSHOT_TRANSIENT_STATUSES,
 )
 from .marshalling import (
     unmarshal_Endpoint,
+    unmarshal_Maintenance,
     unmarshal_ReadReplica,
     unmarshal_DatabaseBackup,
     unmarshal_Database,
     unmarshal_InstanceLog,
     unmarshal_Instance,
     unmarshal_Privilege,
     unmarshal_Snapshot,
@@ -530,15 +532,15 @@
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
             options.stop = (
-                lambda res: res.status not in DATABASEBACKUP_TRANSIENT_STATUSES
+                lambda res: res.status not in DATABASE_BACKUP_TRANSIENT_STATUSES
             )
 
         return await wait_for_resource_async(
             fetcher=self.get_database_backup,
             options=options,
             args={
                 "database_backup_id": database_backup_id,
@@ -734,19 +736,25 @@
     ) -> Instance:
         """
         Upgrade a Database Instance.
         Upgrade your current Database Instance specifications like node type, high availability, volume, or the database engine version. Note that upon upgrade the `enable_ha` parameter can only be set to `true`.
         :param instance_id: UUID of the Database Instance you want to upgrade.
         :param region: Region to target. If none is passed will use default region from the config.
         :param node_type: Node type of the Database Instance you want to upgrade to.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :param enable_ha: Defines whether or not high availability should be enabled on the Database Instance.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :param volume_size: Increase your block storage volume size.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :param volume_type: Change your Database Instance storage type.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :param upgradable_version_id: This will create a new Database Instance with same specifications as the current one and perform a Database Engine upgrade.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :param major_upgrade_workflow: Upgrade your database engine to a new major version including instance endpoints.
+        One-Of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id', 'major_upgrade_workflow' could be set.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = await api.upgrade_instance(
                 instance_id="example",
@@ -977,15 +985,17 @@
         Create a new Database Instance. You must set the `engine`, `user_name`, `password` and `node_type` parameters. Optionally, you can specify the volume type and size.
         :param engine: Database engine of the Database Instance (PostgreSQL, MySQL, ...).
         :param user_name: Username created when the Database Instance is created.
         :param password: Password of the user.
         :param node_type: Type of node to use for the Database Instance.
         :param region: Region to target. If none is passed will use default region from the config.
         :param organization_id: Please use project_id instead.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: The Project ID on which the Database Instance will be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param name: Name of the Database Instance.
         :param is_ha_cluster: Defines whether or not High-Availability is enabled.
         :param disable_backup: Defines whether or not backups are disabled.
         :param volume_size: Volume size when volume_type is not lssd.
         :param backup_same_region: Defines whether to or not to store logical backups in the same region as the Database Instance.
         :param tags: Tags to apply to the Database Instance.
         :param init_settings: List of engine settings to be set upon Database Instance initialization.
@@ -1439,15 +1449,15 @@
             )
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
-            options.stop = lambda res: res.status not in READREPLICA_TRANSIENT_STATUSES
+            options.stop = lambda res: res.status not in READ_REPLICA_TRANSIENT_STATUSES
 
         return await wait_for_resource_async(
             fetcher=self.get_read_replica,
             options=options,
             args={
                 "read_replica_id": read_replica_id,
                 "region": region,
@@ -1748,15 +1758,15 @@
             )
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
-            options.stop = lambda res: res.status not in INSTANCELOG_TRANSIENT_STATUSES
+            options.stop = lambda res: res.status not in INSTANCE_LOG_TRANSIENT_STATUSES
 
         return await wait_for_resource_async(
             fetcher=self.get_instance_log,
             options=options,
             args={
                 "instance_log_id": instance_log_id,
                 "region": region,
@@ -3220,15 +3230,14 @@
         *,
         endpoint_id: str,
         instance_id: str,
         region: Optional[Region] = None,
     ) -> Endpoint:
         """
         Migrate an existing instance endpoint to another instance.
-        Migrate an existing instance endpoint to another instance.
         :param endpoint_id: UUID of the endpoint you want to migrate.
         :param instance_id: UUID of the instance you want to attach the endpoint to.
         :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`Endpoint <Endpoint>`
 
         Usage:
         ::
@@ -3255,7 +3264,42 @@
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Endpoint(res.json())
+
+    async def apply_instance_maintenance(
+        self,
+        *,
+        instance_id: str,
+        region: Optional[Region] = None,
+    ) -> Maintenance:
+        """
+        Apply Database Instance maintenance.
+        Apply maintenance tasks to your Database Instance. This will trigger pending maintenance tasks to start in your Database Instance and can generate service interruption. Maintenance tasks can be applied between `starts_at` and `stops_at` times, and are run directly by Scaleway at `forced_at` timestamp.
+        :param instance_id: UUID of the Database Instance you want to apply maintenance.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :return: :class:`Maintenance <Maintenance>`
+
+        Usage:
+        ::
+
+            result = await api.apply_instance_maintenance(
+                instance_id="example",
+            )
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_instance_id = validate_path_param("instance_id", instance_id)
+
+        res = self._request(
+            "POST",
+            f"/rdb/v1/regions/{param_region}/instances/{param_instance_id}/apply-maintenance",
+            body={},
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Maintenance(res.json())
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/content.py` & `scaleway_async-2.1.0/scaleway_async/rdb/v1/content.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,24 +7,24 @@
     InstanceLogStatus,
     InstanceStatus,
     MaintenanceStatus,
     ReadReplicaStatus,
     SnapshotStatus,
 )
 
-DATABASEBACKUP_TRANSIENT_STATUSES: List[DatabaseBackupStatus] = [
+DATABASE_BACKUP_TRANSIENT_STATUSES: List[DatabaseBackupStatus] = [
     DatabaseBackupStatus.CREATING,
     DatabaseBackupStatus.RESTORING,
     DatabaseBackupStatus.DELETING,
     DatabaseBackupStatus.EXPORTING,
 ]
 """
 Lists transient statutes of the enum :class:`DatabaseBackupStatus <DatabaseBackupStatus>`.
 """
-INSTANCELOG_TRANSIENT_STATUSES: List[InstanceLogStatus] = [
+INSTANCE_LOG_TRANSIENT_STATUSES: List[InstanceLogStatus] = [
     InstanceLogStatus.CREATING,
 ]
 """
 Lists transient statutes of the enum :class:`InstanceLogStatus <InstanceLogStatus>`.
 """
 INSTANCE_TRANSIENT_STATUSES: List[InstanceStatus] = [
     InstanceStatus.PROVISIONING,
@@ -36,20 +36,20 @@
     InstanceStatus.SNAPSHOTTING,
     InstanceStatus.RESTARTING,
 ]
 """
 Lists transient statutes of the enum :class:`InstanceStatus <InstanceStatus>`.
 """
 MAINTENANCE_TRANSIENT_STATUSES: List[MaintenanceStatus] = [
-    MaintenanceStatus.PENDING,
+    MaintenanceStatus.ONGOING,
 ]
 """
 Lists transient statutes of the enum :class:`MaintenanceStatus <MaintenanceStatus>`.
 """
-READREPLICA_TRANSIENT_STATUSES: List[ReadReplicaStatus] = [
+READ_REPLICA_TRANSIENT_STATUSES: List[ReadReplicaStatus] = [
     ReadReplicaStatus.PROVISIONING,
     ReadReplicaStatus.INITIALIZING,
     ReadReplicaStatus.DELETING,
     ReadReplicaStatus.CONFIGURING,
     ReadReplicaStatus.PROMOTING,
 ]
 """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/rdb/v1/marshalling.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,26 +13,27 @@
     resolve_one_of,
 )
 from .types import (
     EndpointDirectAccessDetails,
     EndpointLoadBalancerDetails,
     EndpointPrivateNetworkDetails,
     Endpoint,
+    Maintenance,
     ReadReplica,
     DatabaseBackup,
     Database,
     InstanceLog,
     BackupSchedule,
     InstanceSetting,
     LogsPolicy,
-    Maintenance,
     UpgradableVersion,
     Volume,
     Instance,
     Privilege,
+    SnapshotVolumeType,
     Snapshot,
     User,
     ACLRule,
     AddInstanceACLRulesResponse,
     AddInstanceSettingsResponse,
     DeleteInstanceACLRulesResponse,
     DeleteInstanceSettingsResponse,
@@ -135,14 +136,18 @@
     if field is not None:
         args["service_ip"] = field
 
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
+    field = data.get("provisioning_mode", None)
+    if field is not None:
+        args["provisioning_mode"] = field
+
     return EndpointPrivateNetworkDetails(**args)
 
 
 def unmarshal_Endpoint(data: Any) -> Endpoint:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Endpoint' failed as data isn't a dictionary."
@@ -157,38 +162,93 @@
     field = data.get("port", None)
     if field is not None:
         args["port"] = field
 
     field = data.get("ip", None)
     if field is not None:
         args["ip"] = field
+    else:
+        args["ip"] = None
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
+    else:
+        args["name"] = None
 
     field = data.get("private_network", None)
     if field is not None:
         args["private_network"] = unmarshal_EndpointPrivateNetworkDetails(field)
+    else:
+        args["private_network"] = None
 
     field = data.get("load_balancer", None)
     if field is not None:
         args["load_balancer"] = unmarshal_EndpointLoadBalancerDetails(field)
+    else:
+        args["load_balancer"] = None
 
     field = data.get("direct_access", None)
     if field is not None:
         args["direct_access"] = unmarshal_EndpointDirectAccessDetails(field)
+    else:
+        args["direct_access"] = None
 
     field = data.get("hostname", None)
     if field is not None:
         args["hostname"] = field
+    else:
+        args["hostname"] = None
 
     return Endpoint(**args)
 
 
+def unmarshal_Maintenance(data: Any) -> Maintenance:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'Maintenance' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("reason", None)
+    if field is not None:
+        args["reason"] = field
+
+    field = data.get("status", None)
+    if field is not None:
+        args["status"] = field
+
+    field = data.get("starts_at", None)
+    if field is not None:
+        args["starts_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["starts_at"] = None
+
+    field = data.get("stops_at", None)
+    if field is not None:
+        args["stops_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["stops_at"] = None
+
+    field = data.get("closed_at", None)
+    if field is not None:
+        args["closed_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["closed_at"] = None
+
+    field = data.get("forced_at", None)
+    if field is not None:
+        args["forced_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["forced_at"] = None
+
+    return Maintenance(**args)
+
+
 def unmarshal_ReadReplica(data: Any) -> ReadReplica:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'ReadReplica' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -211,14 +271,18 @@
     if field is not None:
         args["region"] = field
 
     field = data.get("same_zone", None)
     if field is not None:
         args["same_zone"] = field
 
+    field = data.get("instance_id", None)
+    if field is not None:
+        args["instance_id"] = field
+
     return ReadReplica(**args)
 
 
 def unmarshal_DatabaseBackup(data: Any) -> DatabaseBackup:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'DatabaseBackup' failed as data isn't a dictionary."
@@ -245,26 +309,34 @@
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("size", None)
     if field is not None:
         args["size"] = field
+    else:
+        args["size"] = None
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("instance_name", None)
     if field is not None:
         args["instance_name"] = field
 
     field = data.get("region", None)
     if field is not None:
@@ -273,20 +345,24 @@
     field = data.get("same_region", None)
     if field is not None:
         args["same_region"] = field
 
     field = data.get("download_url", None)
     if field is not None:
         args["download_url"] = field
+    else:
+        args["download_url"] = None
 
     field = data.get("download_url_expires_at", None)
     if field is not None:
         args["download_url_expires_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["download_url_expires_at"] = None
 
     return DatabaseBackup(**args)
 
 
 def unmarshal_Database(data: Any) -> Database:
     if not isinstance(data, dict):
         raise TypeError(
@@ -337,22 +413,28 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("download_url", None)
     if field is not None:
         args["download_url"] = field
+    else:
+        args["download_url"] = None
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return InstanceLog(**args)
 
 
 def unmarshal_BackupSchedule(data: Any) -> BackupSchedule:
     if not isinstance(data, dict):
         raise TypeError(
@@ -374,14 +456,16 @@
         args["disabled"] = field
 
     field = data.get("next_run_at", None)
     if field is not None:
         args["next_run_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["next_run_at"] = None
 
     return BackupSchedule(**args)
 
 
 def unmarshal_InstanceSetting(data: Any) -> InstanceSetting:
     if not isinstance(data, dict):
         raise TypeError(
@@ -408,53 +492,26 @@
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("max_age_retention", None)
     if field is not None:
         args["max_age_retention"] = field
+    else:
+        args["max_age_retention"] = None
 
     field = data.get("total_disk_retention", None)
     if field is not None:
         args["total_disk_retention"] = field
+    else:
+        args["total_disk_retention"] = None
 
     return LogsPolicy(**args)
 
 
-def unmarshal_Maintenance(data: Any) -> Maintenance:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'Maintenance' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("reason", None)
-    if field is not None:
-        args["reason"] = field
-
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
-
-    field = data.get("starts_at", None)
-    if field is not None:
-        args["starts_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("stops_at", None)
-    if field is not None:
-        args["stops_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("closed_at", None)
-    if field is not None:
-        args["closed_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    return Maintenance(**args)
-
-
 def unmarshal_UpgradableVersion(data: Any) -> UpgradableVersion:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'UpgradableVersion' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -482,23 +539,23 @@
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Volume' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("size", None)
     if field is not None:
         args["size"] = field
 
-    field = data.get("class_", None)
+    field = data.get("class", None)
     if field is not None:
         args["class_"] = field
 
     return Volume(**args)
 
 
 def unmarshal_Instance(data: Any) -> Instance:
@@ -524,18 +581,22 @@
     field = data.get("organization_id", None)
     if field is not None:
         args["organization_id"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("volume", None)
     if field is not None:
         args["volume"] = unmarshal_Volume(field)
+    else:
+        args["volume"] = None
 
     field = data.get("project_id", None)
     if field is not None:
         args["project_id"] = field
 
     field = data.get("status", None)
     if field is not None:
@@ -566,18 +627,22 @@
     field = data.get("is_ha_cluster", None)
     if field is not None:
         args["is_ha_cluster"] = field
 
     field = data.get("endpoint", None)
     if field is not None:
         args["endpoint"] = unmarshal_Endpoint(field)
+    else:
+        args["endpoint"] = None
 
     field = data.get("backup_schedule", None)
     if field is not None:
         args["backup_schedule"] = unmarshal_BackupSchedule(field)
+    else:
+        args["backup_schedule"] = None
 
     field = data.get("read_replicas", None)
     if field is not None:
         args["read_replicas"] = (
             [unmarshal_ReadReplica(v) for v in field] if field is not None else None
         )
 
@@ -606,14 +671,16 @@
         args["maintenances"] = (
             [unmarshal_Maintenance(v) for v in field] if field is not None else None
         )
 
     field = data.get("logs_policy", None)
     if field is not None:
         args["logs_policy"] = unmarshal_LogsPolicy(field)
+    else:
+        args["logs_policy"] = None
 
     return Instance(**args)
 
 
 def unmarshal_Privilege(data: Any) -> Privilege:
     if not isinstance(data, dict):
         raise TypeError(
@@ -633,14 +700,33 @@
     field = data.get("user_name", None)
     if field is not None:
         args["user_name"] = field
 
     return Privilege(**args)
 
 
+def unmarshal_SnapshotVolumeType(data: Any) -> SnapshotVolumeType:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'SnapshotVolumeType' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("type", None)
+    if field is not None:
+        args["type_"] = field
+
+    field = data.get("class", None)
+    if field is not None:
+        args["class_"] = field
+
+    return SnapshotVolumeType(**args)
+
+
 def unmarshal_Snapshot(data: Any) -> Snapshot:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Snapshot' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -672,26 +758,40 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("size", None)
     if field is not None:
         args["size"] = field
+    else:
+        args["size"] = None
 
     field = data.get("expires_at", None)
     if field is not None:
         args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
+
+    field = data.get("volume_type", None)
+    if field is not None:
+        args["volume_type"] = unmarshal_SnapshotVolumeType(field)
+    else:
+        args["volume_type"] = None
 
     return Snapshot(**args)
 
 
 def unmarshal_User(data: Any) -> User:
     if not isinstance(data, dict):
         raise TypeError(
@@ -738,14 +838,16 @@
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
     field = data.get("port", None)
     if field is not None:
         args["port"] = field
+    else:
+        args["port"] = None
 
     return ACLRule(**args)
 
 
 def unmarshal_AddInstanceACLRulesResponse(data: Any) -> AddInstanceACLRulesResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -883,34 +985,46 @@
     field = data.get("property_type", None)
     if field is not None:
         args["property_type"] = field
 
     field = data.get("unit", None)
     if field is not None:
         args["unit"] = field
+    else:
+        args["unit"] = None
 
     field = data.get("string_constraint", None)
     if field is not None:
         args["string_constraint"] = field
+    else:
+        args["string_constraint"] = None
 
     field = data.get("int_min", None)
     if field is not None:
         args["int_min"] = field
+    else:
+        args["int_min"] = None
 
     field = data.get("int_max", None)
     if field is not None:
         args["int_max"] = field
+    else:
+        args["int_max"] = None
 
     field = data.get("float_min", None)
     if field is not None:
         args["float_min"] = field
+    else:
+        args["float_min"] = None
 
     field = data.get("float_max", None)
     if field is not None:
         args["float_max"] = field
+    else:
+        args["float_max"] = None
 
     return EngineSetting(**args)
 
 
 def unmarshal_EngineVersion(data: Any) -> EngineVersion:
     if not isinstance(data, dict):
         raise TypeError(
@@ -948,14 +1062,16 @@
         )
 
     field = data.get("end_of_life", None)
     if field is not None:
         args["end_of_life"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["end_of_life"] = None
 
     return EngineVersion(**args)
 
 
 def unmarshal_DatabaseEngine(data: Any) -> DatabaseEngine:
     if not isinstance(data, dict):
         raise TypeError(
@@ -1154,15 +1270,15 @@
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'NodeTypeVolumeType' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
@@ -1174,15 +1290,15 @@
     if field is not None:
         args["max_size"] = field
 
     field = data.get("chunk_size", None)
     if field is not None:
         args["chunk_size"] = field
 
-    field = data.get("class_", None)
+    field = data.get("class", None)
     if field is not None:
         args["class_"] = field
 
     return NodeTypeVolumeType(**args)
 
 
 def unmarshal_NodeType(data: Any) -> NodeType:
@@ -1220,18 +1336,22 @@
     field = data.get("beta", None)
     if field is not None:
         args["beta"] = field
 
     field = data.get("volume_constraint", None)
     if field is not None:
         args["volume_constraint"] = unmarshal_NodeTypeVolumeConstraintSizes(field)
+    else:
+        args["volume_constraint"] = None
 
     field = data.get("is_bssd_compatible", None)
     if field is not None:
         args["is_bssd_compatible"] = field
+    else:
+        args["is_bssd_compatible"] = None
 
     field = data.get("available_volume_types", None)
     if field is not None:
         args["available_volume_types"] = (
             [unmarshal_NodeTypeVolumeType(v) for v in field]
             if field is not None
             else None
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/rdb/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/rdb/v1/types.py`

 * *Files 0% similar despite different names*

```diff
@@ -52,14 +52,22 @@
     EXPORTING = "exporting"
     LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
+class EndpointPrivateNetworkDetailsProvisioningMode(str, Enum, metaclass=StrEnumMeta):
+    STATIC = "static"
+    IPAM = "ipam"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 class EngineSettingPropertyType(str, Enum, metaclass=StrEnumMeta):
     BOOLEAN = "boolean"
     INT = "int"
     STRING = "string"
     FLOAT = "float"
 
     def __str__(self) -> str:
@@ -171,14 +179,15 @@
 
 
 class MaintenanceStatus(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN = "unknown"
     PENDING = "pending"
     DONE = "done"
     CANCELED = "canceled"
+    ONGOING = "ongoing"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class NodeTypeGeneration(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN_GENERATION = "unknown_generation"
@@ -281,14 +290,19 @@
     """
 
     zone: Zone
     """
     Private network zone.
     """
 
+    provisioning_mode: EndpointPrivateNetworkDetailsProvisioningMode
+    """
+    How endpoint ips are provisioned.
+    """
+
 
 @dataclass
 class EndpointSpecPrivateNetworkIpamConfig:
     pass
 
 
 @dataclass
@@ -520,14 +534,19 @@
     """
 
     closed_at: Optional[datetime]
     """
     Closed maintenance date.
     """
 
+    forced_at: Optional[datetime]
+    """
+    Time when Scaleway-side maintenance will be applied.
+    """
+
 
 @dataclass
 class ReadReplica:
     id: str
     """
     UUID of the Read Replica.
     """
@@ -548,14 +567,19 @@
     """
 
     same_zone: bool
     """
     Whether the replica is in the same availability zone as the main instance nodes or not.
     """
 
+    instance_id: str
+    """
+    UUID of the Database Instance.
+    """
+
 
 @dataclass
 class UpgradableVersion:
     id: str
 
     name: str
 
@@ -616,14 +640,21 @@
     class_: StorageClass
     """
     The storage class of the volume.
     """
 
 
 @dataclass
+class SnapshotVolumeType:
+    type_: VolumeType
+
+    class_: StorageClass
+
+
+@dataclass
 class ACLRuleRequest:
     ip: str
 
     description: str
 
 
 @dataclass
@@ -1076,14 +1107,19 @@
     """
 
     updated_at: Optional[datetime]
     """
     Updated date (must follow the ISO 8601 format).
     """
 
+    volume_type: Optional[SnapshotVolumeType]
+    """
+    Type of volume where data is stored (lssd, bssd or sbs).
+    """
+
 
 @dataclass
 class User:
     name: str
     """
     Name of the user (Length must be between 1 and 63 characters for PostgreSQL and between 1 and 32 characters for MySQL. First character must be an alphabet character (a-zA-Z). Your username cannot start with '_rdb' or in PostgreSQL, 'pg_'. Only a-zA-Z0-9_$- characters are accepted).
     """
@@ -1156,14 +1192,27 @@
     settings: List[InstanceSetting]
     """
     Settings available on the Database Instance.
     """
 
 
 @dataclass
+class ApplyInstanceMaintenanceRequest:
+    instance_id: str
+    """
+    UUID of the Database Instance you want to apply maintenance.
+    """
+
+    region: Optional[Region]
+    """
+    Region to target. If none is passed will use default region from the config.
+    """
+
+
+@dataclass
 class CloneInstanceRequest:
     instance_id: str
     """
     UUID of the Database Instance you want to clone.
     """
 
     name: str
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/redis/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/redis/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/redis/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/redis/v1/api.py`

 * *Files 1% similar despite different names*

```diff
@@ -387,20 +387,23 @@
         zone: Optional[Zone] = None,
         version: Optional[str] = None,
         node_type: Optional[str] = None,
         cluster_size: Optional[int] = None,
     ) -> Cluster:
         """
         Scale up a Redis™ Database Instance.
-        Upgrade your standalone Redis™ Database Instance node, either by upgrading to a bigger node type (vertical scaling) or by adding more nodes to your Database Instance to increase your number of endpoints and distribute cache (horizontal scaling). Note that scaling horizontally your Redis™ Database Instance will not renew its TLS certificate. In order to refresh the TLS certificate, you must use the Renew TLS certificate endpoint.
+        Upgrade your Redis™ Database Instance, either by upgrading to a bigger node type (vertical scaling) or by adding more nodes to your Database Instance to increase your number of endpoints and distribute cache (horizontal scaling, available for clusters only). Note that scaling horizontally your Redis™ Database Instance will not renew its TLS certificate. In order to refresh the TLS certificate, you must use the Renew TLS certificate endpoint.
         :param cluster_id: UUID of the Database Instance to update.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param version: Redis™ engine version of the Database Instance.
+        One-Of ('action'): at most one of 'version', 'node_type', 'cluster_size' could be set.
         :param node_type: Type of node to use for the Database Instance.
+        One-Of ('action'): at most one of 'version', 'node_type', 'cluster_size' could be set.
         :param cluster_size: Number of nodes for the Database Instance.
+        One-Of ('action'): at most one of 'version', 'node_type', 'cluster_size' could be set.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.migrate_cluster(
                 cluster_id="example",
@@ -1176,15 +1179,17 @@
     ) -> Endpoint:
         """
         Update an endpoint.
         Update information about a Redis™ Database Instance (Redis™ cluster) endpoint. Full details about the endpoint, like `ips`, `port`, `private_network` and `public_network` specifications are returned in the response.
         :param endpoint_id: UUID of the endpoint you want to get.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param private_network: Private Network details.
+        One-Of ('endpoint_type'): at most one of 'private_network', 'public_network' could be set.
         :param public_network: Public network details.
+        One-Of ('endpoint_type'): at most one of 'private_network', 'public_network' could be set.
         :return: :class:`Endpoint <Endpoint>`
 
         Usage:
         ::
 
             result = await api.update_endpoint(
                 endpoint_id="example",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/redis/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/redis/v1/marshalling.py`

 * *Files 6% similar despite different names*

```diff
@@ -60,18 +60,22 @@
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
     field = data.get("ip_cidr", None)
     if field is not None:
         args["ip_cidr"] = field
+    else:
+        args["ip_cidr"] = None
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
+    else:
+        args["description"] = None
 
     return ACLRule(**args)
 
 
 def unmarshal_PrivateNetwork(data: Any) -> PrivateNetwork:
     if not isinstance(data, dict):
         raise TypeError(
@@ -129,18 +133,22 @@
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
     field = data.get("private_network", None)
     if field is not None:
         args["private_network"] = unmarshal_PrivateNetwork(field)
+    else:
+        args["private_network"] = None
 
     field = data.get("public_network", None)
     if field is not None:
         args["public_network"] = unmarshal_PublicNetwork(field)
+    else:
+        args["public_network"] = None
 
     return Endpoint(**args)
 
 
 def unmarshal_ClusterSetting(data: Any) -> ClusterSetting:
     if not isinstance(data, dict):
         raise TypeError(
@@ -211,18 +219,22 @@
         args["cluster_settings"] = (
             [unmarshal_ClusterSetting(v) for v in field] if field is not None else None
         )
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("acl_rules", None)
     if field is not None:
         args["acl_rules"] = (
             [unmarshal_ACLRule(v) for v in field] if field is not None else None
         )
 
@@ -329,41 +341,49 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
 
     field = data.get("deprecated", None)
     if field is not None:
         args["deprecated"] = field
 
     field = data.get("default_value", None)
     if field is not None:
         args["default_value"] = field
+    else:
+        args["default_value"] = None
 
     field = data.get("max_value", None)
     if field is not None:
         args["max_value"] = field
+    else:
+        args["max_value"] = None
 
     field = data.get("min_value", None)
     if field is not None:
         args["min_value"] = field
+    else:
+        args["min_value"] = None
 
     field = data.get("regex", None)
     if field is not None:
         args["regex"] = field
+    else:
+        args["regex"] = None
 
     return AvailableClusterSetting(**args)
 
 
 def unmarshal_ClusterVersion(data: Any) -> ClusterVersion:
     if not isinstance(data, dict):
         raise TypeError(
@@ -393,14 +413,16 @@
         args["zone"] = field
 
     field = data.get("end_of_life_at", None)
     if field is not None:
         args["end_of_life_at"] = (
             parser.isoparse(field) if isinstance(field, str) else field
         )
+    else:
+        args["end_of_life_at"] = None
 
     return ClusterVersion(**args)
 
 
 def unmarshal_ListClusterVersionsResponse(data: Any) -> ListClusterVersionsResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/redis/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/redis/v1/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/registry/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/registry/v1/api.py`

 * *Files 2% similar despite different names*

```diff
@@ -233,15 +233,17 @@
         Create a namespace.
         Create a new Container Registry namespace. You must specify the namespace name and region in which you want it to be created. Optionally, you can specify the `project_id` and `is_public` in the request payload.
         :param description: Description of the namespace.
         :param is_public: Defines whether or not namespace is public.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the namespace.
         :param organization_id: Namespace owner (deprecated).
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id: Project ID on which the namespace will be created.
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.create_namespace(
                 description="example",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/content.py` & `scaleway_async-2.1.0/scaleway_async/registry/v1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/registry/v1/marshalling.py`

 * *Files 6% similar despite different names*

```diff
@@ -57,22 +57,28 @@
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("status_message", None)
     if field is not None:
         args["status_message"] = field
+    else:
+        args["status_message"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Image(**args)
 
 
 def unmarshal_Namespace(data: Any) -> Namespace:
     if not isinstance(data, dict):
         raise TypeError(
@@ -128,18 +134,22 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Namespace(**args)
 
 
 def unmarshal_Tag(data: Any) -> Tag:
     if not isinstance(data, dict):
         raise TypeError(
@@ -167,18 +177,22 @@
     field = data.get("digest", None)
     if field is not None:
         args["digest"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Tag(**args)
 
 
 def unmarshal_ListImagesResponse(data: Any) -> ListImagesResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/registry/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/vpc/v2/types.py`

 * *Files 17% similar despite different names*

```diff
@@ -11,548 +11,557 @@
     Region,
 )
 from scaleway_core.utils import (
     StrEnumMeta,
 )
 
 
-class ImageStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN = "unknown"
-    READY = "ready"
-    DELETING = "deleting"
-    ERROR = "error"
-    LOCKED = "locked"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class ImageVisibility(str, Enum, metaclass=StrEnumMeta):
-    VISIBILITY_UNKNOWN = "visibility_unknown"
-    INHERIT = "inherit"
-    PUBLIC = "public"
-    PRIVATE = "private"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class ListImagesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
-    NAME_ASC = "name_asc"
-    NAME_DESC = "name_desc"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class ListNamespacesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+class ListPrivateNetworksRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
-    DESCRIPTION_ASC = "description_asc"
-    DESCRIPTION_DESC = "description_desc"
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListTagsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+class ListVPCsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class NamespaceStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN = "unknown"
-    READY = "ready"
-    DELETING = "deleting"
-    ERROR = "error"
-    LOCKED = "locked"
-
-    def __str__(self) -> str:
-        return str(self.value)
+@dataclass
+class Subnet:
+    id: str
+    """
+    ID of the subnet.
+    """
 
+    subnet: str
+    """
+    Subnet CIDR.
+    """
 
-class TagStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN = "unknown"
-    READY = "ready"
-    DELETING = "deleting"
-    ERROR = "error"
-    LOCKED = "locked"
+    created_at: Optional[datetime]
+    """
+    Subnet creation date.
+    """
 
-    def __str__(self) -> str:
-        return str(self.value)
+    updated_at: Optional[datetime]
+    """
+    Subnet last modification date.
+    """
 
 
 @dataclass
-class Image:
+class PrivateNetwork:
     id: str
     """
-    UUID of the image.
+    Private Network ID.
     """
 
     name: str
     """
-    Name of the image, it must be unique within the namespace.
+    Private Network name.
     """
 
-    namespace_id: str
+    organization_id: str
     """
-    UUID of the namespace the image belongs to.
+    Scaleway Organization the Private Network belongs to.
     """
 
-    status: ImageStatus
+    project_id: str
     """
-    Status of the image.
+    Scaleway Project the Private Network belongs to.
     """
 
-    visibility: ImageVisibility
+    region: Region
     """
-    Set to `public` to allow the image to be pulled without authentication. Else, set to  `private`. Set to `inherit` to keep the same visibility configuration as the namespace.
+    Region in which the Private Network is available.
     """
 
-    size: int
+    tags: List[str]
     """
-    Image size in bytes, calculated from the size of image layers. One layer used in two tags of the same image is counted once but one layer used in two images is counted twice.
+    Tags of the Private Network.
     """
 
-    tags: List[str]
+    subnets: List[Subnet]
+    """
+    Private Network subnets.
+    """
+
+    vpc_id: str
     """
-    List of docker tags of the image.
+    VPC the Private Network belongs to.
     """
 
-    status_message: Optional[str]
+    dhcp_enabled: bool
     """
-    Details of the image status.
+    Defines whether managed DHCP is enabled for this Private Network.
     """
 
     created_at: Optional[datetime]
     """
-    Date and time of image creation.
+    Date the Private Network was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Date and time of last update.
+    Date the Private Network was last modified.
     """
 
 
 @dataclass
-class Namespace:
+class VPC:
     id: str
     """
-    UUID of the namespace.
+    VPC ID.
     """
 
     name: str
     """
-    Name of the namespace, unique in a region accross all organizations.
+    VPC name.
     """
 
-    description: str
+    organization_id: str
     """
-    Description of the namespace.
+    Scaleway Organization the VPC belongs to.
     """
 
-    organization_id: str
+    project_id: str
     """
-    Owner of the namespace.
+    Scaleway Project the VPC belongs to.
     """
 
-    project_id: str
+    region: Region
     """
-    Project of the namespace.
+    Region of the VPC.
     """
 
-    status: NamespaceStatus
+    tags: List[str]
     """
-    Namespace status.
+    Tags for the VPC.
     """
 
-    status_message: str
+    is_default: bool
     """
-    Namespace status details.
+    Defines whether the VPC is the default one for its Project.
     """
 
-    endpoint: str
+    private_network_count: int
     """
-    Endpoint reachable by docker.
+    Number of Private Networks within this VPC.
     """
 
-    is_public: bool
+    routing_enabled: bool
     """
-    Defines whether or not namespace is public.
+    Defines whether the VPC routes traffic between its Private Networks.
     """
 
-    size: int
+    created_at: Optional[datetime]
     """
-    Total size of the namespace, calculated as the sum of the size of all images in the namespace.
+    Date the VPC was created.
     """
 
-    image_count: int
+    updated_at: Optional[datetime]
     """
-    Number of images in the namespace.
+    Date the VPC was last modified.
     """
 
-    region: Region
+
+@dataclass
+class AddSubnetsRequest:
+    private_network_id: str
     """
-    Region the namespace belongs to.
+    Private Network ID.
     """
 
-    created_at: Optional[datetime]
+    region: Optional[Region]
     """
-    Date and time of creation.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    updated_at: Optional[datetime]
+    subnets: Optional[List[str]]
     """
-    Date and time of last update.
+    Private Network subnets CIDR.
     """
 
 
 @dataclass
-class Tag:
-    id: str
-    """
-    UUID of the tag.
-    """
+class AddSubnetsResponse:
+    subnets: List[str]
 
-    name: str
+
+@dataclass
+class CreatePrivateNetworkRequest:
+    region: Optional[Region]
     """
-    Tag name, unique to an image.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    image_id: str
+    name: Optional[str]
     """
-    Image ID the of the image the tag belongs to.
+    Name for the Private Network.
     """
 
-    status: TagStatus
+    project_id: Optional[str]
     """
-    Tag status.
+    Scaleway Project in which to create the Private Network.
     """
 
-    digest: str
+    tags: Optional[List[str]]
     """
-    Hash of the tag content. Several tags of a same image may have the same digest.
+    Tags for the Private Network.
     """
 
-    created_at: Optional[datetime]
+    subnets: Optional[List[str]]
     """
-    Date and time of creation.
+    Private Network subnets CIDR.
     """
 
-    updated_at: Optional[datetime]
+    vpc_id: Optional[str]
     """
-    Date and time of last update.
+    VPC in which to create the Private Network.
     """
 
 
 @dataclass
-class CreateNamespaceRequest:
-    description: str
+class CreateVPCRequest:
+    enable_routing: bool
     """
-    Description of the namespace.
-    """
-
-    is_public: bool
-    """
-    Defines whether or not namespace is public.
+    Enable routing between Private Networks in the VPC.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Name of the namespace.
+    Name for the VPC.
     """
 
     project_id: Optional[str]
+    """
+    Scaleway Project in which to create the VPC.
+    """
 
-    organization_id: Optional[str]
+    tags: Optional[List[str]]
+    """
+    Tags for the VPC.
+    """
 
 
 @dataclass
-class DeleteImageRequest:
-    image_id: str
+class DeletePrivateNetworkRequest:
+    private_network_id: str
     """
-    UUID of the image.
+    Private Network ID.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
-class DeleteNamespaceRequest:
-    namespace_id: str
+class DeleteSubnetsRequest:
+    private_network_id: str
     """
-    UUID of the namespace.
+    Private Network ID.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
+    subnets: Optional[List[str]]
+    """
+    Private Network subnets CIDR.
+    """
+
+
+@dataclass
+class DeleteSubnetsResponse:
+    subnets: List[str]
+
 
 @dataclass
-class DeleteTagRequest:
-    tag_id: str
+class DeleteVPCRequest:
+    vpc_id: str
     """
-    UUID of the tag.
+    VPC ID.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    force: Optional[bool]
+
+@dataclass
+class EnableDHCPRequest:
+    private_network_id: str
     """
-    If two tags share the same digest the deletion will fail unless this parameter is set to true (deprecated).
+    Private Network ID.
     """
 
-
-@dataclass
-class GetImageRequest:
-    image_id: str
+    region: Optional[Region]
     """
-    UUID of the image.
+    Region to target. If none is passed will use default region from the config.
     """
 
+
+@dataclass
+class EnableRoutingRequest:
+    vpc_id: str
+
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
-class GetNamespaceRequest:
-    namespace_id: str
+class GetPrivateNetworkRequest:
+    private_network_id: str
     """
-    UUID of the namespace.
+    Private Network ID.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
-class GetTagRequest:
-    tag_id: str
+class GetVPCRequest:
+    vpc_id: str
     """
-    UUID of the tag.
+    VPC ID.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
-class ListImagesRequest:
+class ListPrivateNetworksRequest:
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    page: Optional[int]
+    order_by: Optional[ListPrivateNetworksRequestOrderBy]
     """
-    A positive integer to choose the page to display.
+    Sort order of the returned Private Networks.
     """
 
-    page_size: Optional[int]
+    page: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to display.
+    Page number to return, from the paginated results.
     """
 
-    order_by: Optional[ListImagesRequestOrderBy]
+    page_size: Optional[int]
     """
-    Criteria to use when ordering image listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
+    Maximum number of Private Networks to return per page.
     """
 
-    namespace_id: Optional[str]
+    name: Optional[str]
     """
-    Filter by the namespace ID.
+    Name to filter for. Only Private Networks with names containing this string will be returned.
     """
 
-    name: Optional[str]
+    tags: Optional[List[str]]
     """
-    Filter by the image name (exact match).
+    Tags to filter for. Only Private Networks with one or more matching tags will be returned.
     """
 
     organization_id: Optional[str]
     """
-    Filter by Organization ID.
+    Organization ID to filter for. Only Private Networks belonging to this Organization will be returned.
     """
 
     project_id: Optional[str]
     """
-    Filter by Project ID.
+    Project ID to filter for. Only Private Networks belonging to this Project will be returned.
     """
 
+    private_network_ids: Optional[List[str]]
+    """
+    Private Network IDs to filter for. Only Private Networks with one of these IDs will be returned.
+    """
 
-@dataclass
-class ListImagesResponse:
-    images: List[Image]
+    vpc_id: Optional[str]
     """
-    Paginated list of images that match the selected filters.
+    VPC ID to filter for. Only Private Networks belonging to this VPC will be returned.
     """
 
-    total_count: int
+    dhcp_enabled: Optional[bool]
     """
-    Total number of images that match the selected filters.
+    DHCP status to filter for. When true, only Private Networks with managed DHCP enabled will be returned.
     """
 
 
 @dataclass
-class ListNamespacesRequest:
+class ListPrivateNetworksResponse:
+    private_networks: List[PrivateNetwork]
+
+    total_count: int
+
+
+@dataclass
+class ListVPCsRequest:
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
+    order_by: Optional[ListVPCsRequestOrderBy]
+    """
+    Sort order of the returned VPCs.
+    """
+
     page: Optional[int]
     """
-    A positive integer to choose the page to display.
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to display.
+    Maximum number of VPCs to return per page.
     """
 
-    order_by: Optional[ListNamespacesRequestOrderBy]
+    name: Optional[str]
     """
-    Criteria to use when ordering namespace listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
+    Name to filter for. Only VPCs with names containing this string will be returned.
     """
 
-    organization_id: Optional[str]
+    tags: Optional[List[str]]
     """
-    Filter by Organization ID.
+    Tags to filter for. Only VPCs with one more more matching tags will be returned.
     """
 
-    project_id: Optional[str]
+    organization_id: Optional[str]
     """
-    Filter by Project ID.
+    Organization ID to filter for. Only VPCs belonging to this Organization will be returned.
     """
 
-    name: Optional[str]
+    project_id: Optional[str]
     """
-    Filter by the namespace name (exact match).
+    Project ID to filter for. Only VPCs belonging to this Project will be returned.
     """
 
-
-@dataclass
-class ListNamespacesResponse:
-    namespaces: List[Namespace]
+    is_default: Optional[bool]
     """
-    Paginated list of namespaces that match the selected filters.
+    Defines whether to filter only for VPCs which are the default one for their Project.
     """
 
-    total_count: int
+    routing_enabled: Optional[bool]
     """
-    Total number of namespaces that match the selected filters.
+    Defines whether to filter only for VPCs which route traffic between their Private Networks.
     """
 
 
 @dataclass
-class ListTagsRequest:
-    image_id: str
-    """
-    UUID of the image.
-    """
+class ListVPCsResponse:
+    vpcs: List[VPC]
+
+    total_count: int
 
+
+@dataclass
+class MigrateZonalPrivateNetworksRequest:
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    page: Optional[int]
+    private_network_ids: Optional[List[str]]
     """
-    A positive integer to choose the page to display.
+    IDs of the Private Networks to migrate.
     """
 
-    page_size: Optional[int]
+    organization_id: Optional[str]
+
+    project_id: Optional[str]
+
+
+@dataclass
+class SetSubnetsRequest:
+    private_network_id: str
     """
-    A positive integer lower or equal to 100 to select the number of items to display.
+    Private Network ID.
     """
 
-    order_by: Optional[ListTagsRequestOrderBy]
+    region: Optional[Region]
     """
-    Criteria to use when ordering tag listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+    subnets: Optional[List[str]]
     """
-    Filter by the tag name (exact match).
+    Private Network subnets CIDR.
     """
 
 
 @dataclass
-class ListTagsResponse:
-    tags: List[Tag]
-    """
-    Paginated list of tags that match the selected filters.
-    """
-
-    total_count: int
-    """
-    Total number of tags that match the selected filters.
-    """
+class SetSubnetsResponse:
+    subnets: List[str]
 
 
 @dataclass
-class UpdateImageRequest:
-    image_id: str
+class UpdatePrivateNetworkRequest:
+    private_network_id: str
     """
-    ID of the image to update.
+    Private Network ID.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    visibility: Optional[ImageVisibility]
+    name: Optional[str]
     """
-    Set to `public` to allow the image to be pulled without authentication. Else, set to  `private`. Set to `inherit` to keep the same visibility configuration as the namespace.
+    Name for the Private Network.
+    """
+
+    tags: Optional[List[str]]
+    """
+    Tags for the Private Network.
     """
 
 
 @dataclass
-class UpdateNamespaceRequest:
-    namespace_id: str
+class UpdateVPCRequest:
+    vpc_id: str
     """
-    ID of the namespace to update.
+    VPC ID.
     """
 
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
-    description: Optional[str]
+    name: Optional[str]
     """
-    Namespace description.
+    Name for the VPC.
     """
 
-    is_public: Optional[bool]
+    tags: Optional[List[str]]
     """
-    Defines whether or not the namespace is public.
+    Tags for the VPC.
     """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/secret/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/secret/v1beta1/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,89 +1,89 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
-from .types import ListFoldersRequestOrderBy
+from .types import BrowseSecretsRequestOrderBy
+from .types import EphemeralPolicyAction
 from .types import ListSecretsRequestOrderBy
 from .types import Product
-from .types import SecretEphemeralAction
 from .types import SecretStatus
 from .types import SecretType
 from .types import SecretVersionStatus
-from .types import PasswordGenerationParams
-from .types import Folder
+from .types import EphemeralPolicy
+from .types import BrowseSecretsResponseItemFolderDetails
+from .types import BrowseSecretsResponseItemSecretDetails
+from .types import EphemeralProperties
+from .types import BrowseSecretsResponseItem
 from .types import SecretVersion
 from .types import Secret
-from .types import AccessSecretVersionByNameRequest
+from .types import AccessSecretVersionByPathRequest
 from .types import AccessSecretVersionRequest
 from .types import AccessSecretVersionResponse
 from .types import AddSecretOwnerRequest
-from .types import CreateFolderRequest
+from .types import BasicCredentials
+from .types import BrowseSecretsRequest
+from .types import BrowseSecretsResponse
 from .types import CreateSecretRequest
 from .types import CreateSecretVersionRequest
-from .types import DeleteFolderRequest
+from .types import DatabaseCredentials
 from .types import DeleteSecretRequest
-from .types import DestroySecretVersionRequest
+from .types import DeleteSecretVersionRequest
 from .types import DisableSecretVersionRequest
 from .types import EnableSecretVersionRequest
-from .types import GeneratePasswordRequest
-from .types import GetSecretByNameRequest
 from .types import GetSecretRequest
-from .types import GetSecretVersionByNameRequest
 from .types import GetSecretVersionRequest
-from .types import ListFoldersRequest
-from .types import ListFoldersResponse
-from .types import ListSecretVersionsByNameRequest
 from .types import ListSecretVersionsRequest
 from .types import ListSecretVersionsResponse
 from .types import ListSecretsRequest
 from .types import ListSecretsResponse
 from .types import ListTagsRequest
 from .types import ListTagsResponse
 from .types import ProtectSecretRequest
+from .types import SSHKey
 from .types import UnprotectSecretRequest
 from .types import UpdateSecretRequest
 from .types import UpdateSecretVersionRequest
-from .api import SecretV1Alpha1API
+from .api import SecretV1Beta1API
 
 __all__ = [
-    "ListFoldersRequestOrderBy",
+    "BrowseSecretsRequestOrderBy",
+    "EphemeralPolicyAction",
     "ListSecretsRequestOrderBy",
     "Product",
-    "SecretEphemeralAction",
     "SecretStatus",
     "SecretType",
     "SecretVersionStatus",
-    "PasswordGenerationParams",
-    "Folder",
+    "EphemeralPolicy",
+    "BrowseSecretsResponseItemFolderDetails",
+    "BrowseSecretsResponseItemSecretDetails",
+    "EphemeralProperties",
+    "BrowseSecretsResponseItem",
     "SecretVersion",
     "Secret",
-    "AccessSecretVersionByNameRequest",
+    "AccessSecretVersionByPathRequest",
     "AccessSecretVersionRequest",
     "AccessSecretVersionResponse",
     "AddSecretOwnerRequest",
-    "CreateFolderRequest",
+    "BasicCredentials",
+    "BrowseSecretsRequest",
+    "BrowseSecretsResponse",
     "CreateSecretRequest",
     "CreateSecretVersionRequest",
-    "DeleteFolderRequest",
+    "DatabaseCredentials",
     "DeleteSecretRequest",
-    "DestroySecretVersionRequest",
+    "DeleteSecretVersionRequest",
     "DisableSecretVersionRequest",
     "EnableSecretVersionRequest",
-    "GeneratePasswordRequest",
-    "GetSecretByNameRequest",
     "GetSecretRequest",
-    "GetSecretVersionByNameRequest",
     "GetSecretVersionRequest",
-    "ListFoldersRequest",
-    "ListFoldersResponse",
-    "ListSecretVersionsByNameRequest",
     "ListSecretVersionsRequest",
     "ListSecretVersionsResponse",
     "ListSecretsRequest",
     "ListSecretsResponse",
     "ListTagsRequest",
     "ListTagsResponse",
     "ProtectSecretRequest",
+    "SSHKey",
     "UnprotectSecretRequest",
     "UpdateSecretRequest",
     "UpdateSecretVersionRequest",
-    "SecretV1Alpha1API",
+    "SecretV1Beta1API",
 ]
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/secret/v1alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/secret/v1alpha1/api.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,33 +1,33 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
-from datetime import datetime
 from typing import List, Optional
 
 from scaleway_core.api import API
 from scaleway_core.bridge import (
     Region,
 )
 from scaleway_core.utils import (
     validate_path_param,
     fetch_all_pages_async,
 )
 from .types import (
     ListFoldersRequestOrderBy,
     ListSecretsRequestOrderBy,
     Product,
-    SecretEphemeralAction,
     SecretType,
     SecretVersionStatus,
     AccessSecretVersionResponse,
     AddSecretOwnerRequest,
     CreateFolderRequest,
     CreateSecretRequest,
     CreateSecretVersionRequest,
+    EphemeralPolicy,
+    EphemeralProperties,
     Folder,
     GeneratePasswordRequest,
     ListFoldersResponse,
     ListSecretVersionsResponse,
     ListSecretsResponse,
     ListTagsResponse,
     PasswordGenerationParams,
@@ -60,63 +60,64 @@
     This API allows you to conveniently store, access and share sensitive data.
     """
 
     async def create_secret(
         self,
         *,
         name: str,
+        is_protected: bool,
         region: Optional[Region] = None,
         project_id: Optional[str] = None,
         tags: Optional[List[str]] = None,
         description: Optional[str] = None,
         type_: Optional[SecretType] = None,
         path: Optional[str] = None,
-        expires_at: Optional[datetime] = None,
-        ephemeral_action: Optional[SecretEphemeralAction] = None,
+        ephemeral_policy: Optional[EphemeralPolicy] = None,
     ) -> Secret:
         """
         Create a secret.
         You must specify the `region` to create a secret.
         :param name: Name of the secret.
+        :param is_protected: A protected secret cannot be deleted.
         :param region: Region to target. If none is passed will use default region from the config.
         :param project_id: ID of the Project containing the secret.
         :param tags: List of the secret's tags.
         :param description: Description of the secret.
         :param type_: (Optional.) See `Secret.Type` enum for description of values. If not specified, the type is `Opaque`.
         :param path: (Optional.) Location of the secret in the directory structure. If not specified, the path is `/`.
-        :param expires_at: (Optional.) Date on which the secret will be deleted or deactivated.
-        :param ephemeral_action: Action to be taken when the secret expires.
+        :param ephemeral_policy: (Optional.) Policy that defines whether/when a secret's versions expire. By default, the policy is applied to all the secret's versions.
         :return: :class:`Secret <Secret>`
 
         Usage:
         ::
 
             result = await api.create_secret(
                 name="example",
+                is_protected=False,
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
             f"/secret-manager/v1alpha1/regions/{param_region}/secrets",
             body=marshal_CreateSecretRequest(
                 CreateSecretRequest(
                     name=name,
+                    is_protected=is_protected,
                     region=region,
                     project_id=project_id,
                     tags=tags,
                     description=description,
                     type_=type_,
                     path=path,
-                    expires_at=expires_at,
-                    ephemeral_action=ephemeral_action,
+                    ephemeral_policy=ephemeral_policy,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Secret(res.json())
@@ -127,15 +128,14 @@
         name: str,
         region: Optional[Region] = None,
         project_id: Optional[str] = None,
         path: Optional[str] = None,
     ) -> Folder:
         """
         Create folder.
-        Create folder.
         :param name: Name of the folder.
         :param region: Region to target. If none is passed will use default region from the config.
         :param project_id: ID of the Project containing the folder.
         :param path: (Optional.) Location of the folder in the directory structure. If not specified, the path is `/`.
         :return: :class:`Folder <Folder>`
 
         Usage:
@@ -250,24 +250,26 @@
         *,
         secret_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         description: Optional[str] = None,
         path: Optional[str] = None,
+        ephemeral_policy: Optional[EphemeralPolicy] = None,
     ) -> Secret:
         """
         Update metadata of a secret.
-        Edit a secret's metadata such as name, tag(s) and description. The secret to update is specified by the `secret_id` and `region` parameters.
+        Edit a secret's metadata such as name, tag(s), description and ephemeral policy. The secret to update is specified by the `secret_id` and `region` parameters.
         :param secret_id: ID of the secret.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Secret's updated name (optional).
         :param tags: Secret's updated list of tags (optional).
         :param description: Description of the secret.
         :param path: (Optional.) Location of the folder in the directory structure. If not specified, the path is `/`.
+        :param ephemeral_policy: (Optional.) Policy that defines whether/when a secret's versions expire.
         :return: :class:`Secret <Secret>`
 
         Usage:
         ::
 
             result = await api.update_secret(
                 secret_id="example",
@@ -286,14 +288,15 @@
                 UpdateSecretRequest(
                     secret_id=secret_id,
                     region=region,
                     name=name,
                     tags=tags,
                     description=description,
                     path=path,
+                    ephemeral_policy=ephemeral_policy,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Secret(res.json())
@@ -539,15 +542,14 @@
         self,
         *,
         folder_id: str,
         region: Optional[Region] = None,
     ) -> None:
         """
         Delete a given folder specified by the `region` and `folder_id` parameters.
-        Delete a given folder specified by the `region` and `folder_id` parameters.
         :param folder_id: ID of the folder.
         :param region: Region to target. If none is passed will use default region from the config.
 
         Usage:
         ::
 
             result = await api.delete_folder(
@@ -643,15 +645,14 @@
         secret_id: str,
         region: Optional[Region] = None,
         product_name: Optional[str] = None,
         product: Optional[Product] = None,
     ) -> None:
         """
         Allow a product to use the secret.
-        Allow a product to use the secret.
         :param secret_id: ID of the secret.
         :param region: Region to target. If none is passed will use default region from the config.
         :param product_name: (Deprecated: use `product` field) Name of the product to add.
         :param product: See `Product` enum for description of values.
 
         Usage:
         ::
@@ -897,25 +898,27 @@
     async def update_secret_version(
         self,
         *,
         secret_id: str,
         revision: str,
         region: Optional[Region] = None,
         description: Optional[str] = None,
+        ephemeral_properties: Optional[EphemeralProperties] = None,
     ) -> SecretVersion:
         """
         Update metadata of a version.
         Edit the metadata of a secret's given version, specified by the `region`, `secret_id` and `revision` parameters.
         :param secret_id: ID of the secret.
         :param revision: The first version of the secret is numbered 1, and all subsequent revisions augment by 1. Value can be either:
         - a number (the revision number)
         - "latest" (the latest revision)
         - "latest_enabled" (the latest enabled revision).
         :param region: Region to target. If none is passed will use default region from the config.
         :param description: Description of the version.
+        :param ephemeral_properties: (Optional.) Properties that defines the version's expiration date, whether it expires after being accessed once, and the action to perform (disable or delete) once the version expires.
         :return: :class:`SecretVersion <SecretVersion>`
 
         Usage:
         ::
 
             result = await api.update_secret_version(
                 secret_id="example",
@@ -934,14 +937,15 @@
             f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}/versions/{param_revision}",
             body=marshal_UpdateSecretVersionRequest(
                 UpdateSecretVersionRequest(
                     secret_id=secret_id,
                     revision=revision,
                     region=region,
                     description=description,
+                    ephemeral_properties=ephemeral_properties,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_SecretVersion(res.json())
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/secret/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/secret/v1alpha1/marshalling.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,15 +3,17 @@
 
 from typing import Any, Dict
 from dateutil import parser
 
 from scaleway_core.profile import ProfileDefaults
 from .types import (
     Folder,
+    EphemeralProperties,
     SecretVersion,
+    EphemeralPolicy,
     Secret,
     AccessSecretVersionResponse,
     ListFoldersResponse,
     ListSecretVersionsResponse,
     ListSecretsResponse,
     ListTagsResponse,
     AddSecretOwnerRequest,
@@ -52,18 +54,47 @@
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     return Folder(**args)
 
 
+def unmarshal_EphemeralProperties(data: Any) -> EphemeralProperties:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'EphemeralProperties' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("action", None)
+    if field is not None:
+        args["action"] = field
+
+    field = data.get("expires_at", None)
+    if field is not None:
+        args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
+
+    field = data.get("expires_once_accessed", None)
+    if field is not None:
+        args["expires_once_accessed"] = field
+    else:
+        args["expires_once_accessed"] = None
+
+    return EphemeralProperties(**args)
+
+
 def unmarshal_SecretVersion(data: Any) -> SecretVersion:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'SecretVersion' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -83,26 +114,65 @@
     field = data.get("is_latest", None)
     if field is not None:
         args["is_latest"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
+    else:
+        args["description"] = None
+
+    field = data.get("ephemeral_properties", None)
+    if field is not None:
+        args["ephemeral_properties"] = unmarshal_EphemeralProperties(field)
+    else:
+        args["ephemeral_properties"] = None
 
     return SecretVersion(**args)
 
 
+def unmarshal_EphemeralPolicy(data: Any) -> EphemeralPolicy:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'EphemeralPolicy' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("action", None)
+    if field is not None:
+        args["action"] = field
+
+    field = data.get("time_to_live", None)
+    if field is not None:
+        args["time_to_live"] = field
+    else:
+        args["time_to_live"] = None
+
+    field = data.get("expires_once_accessed", None)
+    if field is not None:
+        args["expires_once_accessed"] = field
+    else:
+        args["expires_once_accessed"] = None
+
+    return EphemeralPolicy(**args)
+
+
 def unmarshal_Secret(data: Any) -> Secret:
     if not isinstance(data, dict):
         raise TypeError(
             "Unmarshalling the type 'Secret' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
@@ -119,14 +189,26 @@
     if field is not None:
         args["name"] = field
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
+    field = data.get("created_at", None)
+    if field is not None:
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
+
+    field = data.get("updated_at", None)
+    if field is not None:
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
+
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("version_count", None)
     if field is not None:
         args["version_count"] = field
@@ -135,45 +217,37 @@
     if field is not None:
         args["is_managed"] = field
 
     field = data.get("is_protected", None)
     if field is not None:
         args["is_protected"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("path", None)
     if field is not None:
         args["path"] = field
 
-    field = data.get("ephemeral_action", None)
-    if field is not None:
-        args["ephemeral_action"] = field
-
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
-    field = data.get("created_at", None)
-    if field is not None:
-        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    field = data.get("updated_at", None)
-    if field is not None:
-        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
     field = data.get("description", None)
     if field is not None:
         args["description"] = field
+    else:
+        args["description"] = None
 
-    field = data.get("expires_at", None)
+    field = data.get("ephemeral_policy", None)
     if field is not None:
-        args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["ephemeral_policy"] = unmarshal_EphemeralPolicy(field)
+    else:
+        args["ephemeral_policy"] = None
 
     return Secret(**args)
 
 
 def unmarshal_AccessSecretVersionResponse(data: Any) -> AccessSecretVersionResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -193,14 +267,16 @@
     field = data.get("data", None)
     if field is not None:
         args["data"] = field
 
     field = data.get("data_crc32", None)
     if field is not None:
         args["data_crc32"] = field
+    else:
+        args["data_crc32"] = None
 
     return AccessSecretVersionResponse(**args)
 
 
 def unmarshal_ListFoldersResponse(data: Any) -> ListFoldersResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -312,23 +388,44 @@
 
     if request.path is not None:
         output["path"] = request.path
 
     return output
 
 
+def marshal_EphemeralPolicy(
+    request: EphemeralPolicy,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.action is not None:
+        output["action"] = str(request.action)
+
+    if request.time_to_live is not None:
+        output["time_to_live"] = request.time_to_live
+
+    if request.expires_once_accessed is not None:
+        output["expires_once_accessed"] = request.expires_once_accessed
+
+    return output
+
+
 def marshal_CreateSecretRequest(
     request: CreateSecretRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.name is not None:
         output["name"] = request.name
 
+    if request.is_protected is not None:
+        output["is_protected"] = request.is_protected
+
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
     if request.tags is not None:
         output["tags"] = request.tags
 
     if request.description is not None:
@@ -336,19 +433,18 @@
 
     if request.type_ is not None:
         output["type"] = str(request.type_)
 
     if request.path is not None:
         output["path"] = request.path
 
-    if request.expires_at is not None:
-        output["expires_at"] = request.expires_at
-
-    if request.ephemeral_action is not None:
-        output["ephemeral_action"] = str(request.ephemeral_action)
+    if request.ephemeral_policy is not None:
+        output["ephemeral_policy"] = (
+            marshal_EphemeralPolicy(request.ephemeral_policy, defaults),
+        )
 
     return output
 
 
 def marshal_PasswordGenerationParams(
     request: PasswordGenerationParams,
     defaults: ProfileDefaults,
@@ -443,20 +539,48 @@
 
     if request.description is not None:
         output["description"] = request.description
 
     if request.path is not None:
         output["path"] = request.path
 
+    if request.ephemeral_policy is not None:
+        output["ephemeral_policy"] = (
+            marshal_EphemeralPolicy(request.ephemeral_policy, defaults),
+        )
+
+    return output
+
+
+def marshal_EphemeralProperties(
+    request: EphemeralProperties,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.action is not None:
+        output["action"] = str(request.action)
+
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
+
+    if request.expires_once_accessed is not None:
+        output["expires_once_accessed"] = request.expires_once_accessed
+
     return output
 
 
 def marshal_UpdateSecretVersionRequest(
     request: UpdateSecretVersionRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.description is not None:
         output["description"] = request.description
 
+    if request.ephemeral_properties is not None:
+        output["ephemeral_properties"] = (
+            marshal_EphemeralProperties(request.ephemeral_properties, defaults),
+        )
+
     return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/secret/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/secret/v1alpha1/types.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,14 +11,23 @@
     Region,
 )
 from scaleway_core.utils import (
     StrEnumMeta,
 )
 
 
+class EphemeralPolicyAction(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_ACTION = "unknown_action"
+    DELETE = "delete"
+    DISABLE = "disable"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 class ListFoldersRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
@@ -41,23 +50,14 @@
     UNKNOWN = "unknown"
     EDGE_SERVICES = "edge_services"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SecretEphemeralAction(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_EPHEMERAL_ACTION = "unknown_ephemeral_action"
-    DELETE_SECRET = "delete_secret"
-    DISABLE_SECRET = "disable_secret"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
 class SecretStatus(str, Enum, metaclass=StrEnumMeta):
     READY = "ready"
     LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
@@ -79,14 +79,50 @@
     DESTROYED = "destroyed"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
+class EphemeralProperties:
+    action: EphemeralPolicyAction
+    """
+    See `EphemeralPolicy.Action` enum for a description of values.
+    """
+
+    expires_at: Optional[datetime]
+    """
+    (Optional.) If not specified, the version does not have an expiration date.
+    """
+
+    expires_once_accessed: Optional[bool]
+    """
+    (Optional.) If not specified, the version can be accessed an unlimited amount of times.
+    """
+
+
+@dataclass
+class EphemeralPolicy:
+    action: EphemeralPolicyAction
+    """
+    See the `EphemeralPolicy.Action` enum for a description of values.
+    """
+
+    time_to_live: Optional[str]
+    """
+    Time frame, from one second and up to one year, during which the secret's versions are valid.
+    """
+
+    expires_once_accessed: Optional[bool]
+    """
+    Returns `true` if the version expires after a single user access.
+    """
+
+
+@dataclass
 class PasswordGenerationParams:
     length: int
     """
     Length of the password to generate (between 1 and 1024).
     """
 
     no_lowercase_letters: bool
@@ -179,14 +215,19 @@
     """
 
     description: Optional[str]
     """
     Description of the version.
     """
 
+    ephemeral_properties: Optional[EphemeralProperties]
+    """
+    Returns the version's expiration date, whether it expires after being accessed once, and the action to perform (disable or delete) once the version expires.
+    """
+
 
 @dataclass
 class Secret:
     id: str
     """
     ID of the secret.
     """
@@ -203,14 +244,24 @@
 
     status: SecretStatus
     """
     * `ready`: the secret can be read, modified and deleted.
 * `locked`: no action can be performed on the secret. This status can only be applied and removed by Scaleway.
     """
 
+    created_at: Optional[datetime]
+    """
+    Date and time of the secret's creation.
+    """
+
+    updated_at: Optional[datetime]
+    """
+    Last update of the secret.
+    """
+
     tags: List[str]
     """
     List of the secret's tags.
     """
 
     version_count: int
     """
@@ -233,42 +284,27 @@
     """
 
     path: str
     """
     Location of the secret in the directory structure.
     """
 
-    ephemeral_action: SecretEphemeralAction
-    """
-    See `Secret.EphemeralAction` enum for description of values.
-    """
-
     region: Region
     """
     Region of the secret.
     """
 
-    created_at: Optional[datetime]
-    """
-    Date and time of the secret's creation.
-    """
-
-    updated_at: Optional[datetime]
-    """
-    Last update of the secret.
-    """
-
     description: Optional[str]
     """
     Updated description of the secret.
     """
 
-    expires_at: Optional[datetime]
+    ephemeral_policy: Optional[EphemeralPolicy]
     """
-    (Optional.) Date on which the secret will be deleted or deactivated.
+    (Optional.) Policy that defines whether/when a secret's versions expire. By default, the policy is applied to all the secret's versions.
     """
 
 
 @dataclass
 class AccessSecretVersionByNameRequest:
     secret_name: str
     """
@@ -387,14 +423,19 @@
 @dataclass
 class CreateSecretRequest:
     name: str
     """
     Name of the secret.
     """
 
+    is_protected: bool
+    """
+    A protected secret cannot be deleted.
+    """
+
     region: Optional[Region]
     """
     Region to target. If none is passed will use default region from the config.
     """
 
     project_id: Optional[str]
     """
@@ -417,22 +458,17 @@
     """
 
     path: Optional[str]
     """
     (Optional.) Location of the secret in the directory structure. If not specified, the path is `/`.
     """
 
-    expires_at: Optional[datetime]
-    """
-    (Optional.) Date on which the secret will be deleted or deactivated.
-    """
-
-    ephemeral_action: Optional[SecretEphemeralAction]
+    ephemeral_policy: Optional[EphemeralPolicy]
     """
-    Action to be taken when the secret expires.
+    (Optional.) Policy that defines whether/when a secret's versions expire. By default, the policy is applied to all the secret's versions.
     """
 
 
 @dataclass
 class CreateSecretVersionRequest:
     secret_id: str
     """
@@ -930,14 +966,19 @@
     """
 
     path: Optional[str]
     """
     (Optional.) Location of the folder in the directory structure. If not specified, the path is `/`.
     """
 
+    ephemeral_policy: Optional[EphemeralPolicy]
+    """
+    (Optional.) Policy that defines whether/when a secret's versions expire.
+    """
+
 
 @dataclass
 class UpdateSecretVersionRequest:
     secret_id: str
     """
     ID of the secret.
     """
@@ -955,7 +996,12 @@
     Region to target. If none is passed will use default region from the config.
     """
 
     description: Optional[str]
     """
     Description of the version.
     """
+
+    ephemeral_properties: Optional[EphemeralProperties]
+    """
+    (Optional.) Properties that defines the version's expiration date, whether it expires after being accessed once, and the action to perform (disable or delete) once the version expires.
+    """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/tem/v1alpha1/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,21 +5,25 @@
 from .types import DomainStatus
 from .content import DOMAIN_TRANSIENT_STATUSES
 from .types import EmailFlag
 from .types import EmailRcptType
 from .types import EmailStatus
 from .content import EMAIL_TRANSIENT_STATUSES
 from .types import ListEmailsRequestOrderBy
+from .types import DomainRecordsDMARC
 from .types import EmailTry
+from .types import DomainRecords
 from .types import DomainReputation
 from .types import DomainStatistics
 from .types import CreateEmailRequestAddress
 from .types import CreateEmailRequestAttachment
+from .types import CreateEmailRequestHeader
 from .types import Email
 from .types import DomainLastStatusDkimRecord
+from .types import DomainLastStatusDmarcRecord
 from .types import DomainLastStatusSpfRecord
 from .types import Domain
 from .types import CancelEmailRequest
 from .types import CheckDomainRequest
 from .types import CreateDomainRequest
 from .types import CreateEmailRequest
 from .types import CreateEmailResponse
@@ -42,21 +46,25 @@
     "DomainStatus",
     "DOMAIN_TRANSIENT_STATUSES",
     "EmailFlag",
     "EmailRcptType",
     "EmailStatus",
     "EMAIL_TRANSIENT_STATUSES",
     "ListEmailsRequestOrderBy",
+    "DomainRecordsDMARC",
     "EmailTry",
+    "DomainRecords",
     "DomainReputation",
     "DomainStatistics",
     "CreateEmailRequestAddress",
     "CreateEmailRequestAttachment",
+    "CreateEmailRequestHeader",
     "Email",
     "DomainLastStatusDkimRecord",
+    "DomainLastStatusDmarcRecord",
     "DomainLastStatusSpfRecord",
     "Domain",
     "CancelEmailRequest",
     "CheckDomainRequest",
     "CreateDomainRequest",
     "CreateEmailRequest",
     "CreateEmailResponse",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/tem/v1alpha1/api.py`

 * *Files 1% similar despite different names*

```diff
@@ -19,14 +19,15 @@
     EmailFlag,
     EmailStatus,
     ListEmailsRequestOrderBy,
     CreateDomainRequest,
     CreateEmailRequest,
     CreateEmailRequestAddress,
     CreateEmailRequestAttachment,
+    CreateEmailRequestHeader,
     CreateEmailResponse,
     Domain,
     DomainLastStatus,
     Email,
     ListDomainsResponse,
     ListEmailsResponse,
     Statistics,
@@ -61,14 +62,15 @@
         from_: Optional[CreateEmailRequestAddress] = None,
         to: Optional[List[CreateEmailRequestAddress]] = None,
         cc: Optional[List[CreateEmailRequestAddress]] = None,
         bcc: Optional[List[CreateEmailRequestAddress]] = None,
         project_id: Optional[str] = None,
         attachments: Optional[List[CreateEmailRequestAttachment]] = None,
         send_before: Optional[datetime] = None,
+        additional_headers: Optional[List[CreateEmailRequestHeader]] = None,
     ) -> CreateEmailResponse:
         """
         Send an email.
         You must specify the `region`, the sender and the recipient's information and the `project_id` to send an email from a checked domain. The subject of the email must contain at least 6 characters.
         :param subject: Subject of the email.
         :param text: Text content.
         :param html: HTML content.
@@ -76,14 +78,15 @@
         :param from_: Sender information. Must be from a checked domain declared in the Project.
         :param to: An array of the primary recipient's information.
         :param cc: An array of the carbon copy recipient's information.
         :param bcc: An array of the blind carbon copy recipient's information.
         :param project_id: ID of the Project in which to create the email.
         :param attachments: Array of attachments.
         :param send_before: Maximum date to deliver the email.
+        :param additional_headers: Array of additional headers as key-value.
         :return: :class:`CreateEmailResponse <CreateEmailResponse>`
 
         Usage:
         ::
 
             result = await api.create_email(
                 subject="example",
@@ -108,14 +111,15 @@
                     from_=from_,
                     to=to,
                     cc=cc,
                     bcc=bcc,
                     project_id=project_id,
                     attachments=attachments,
                     send_before=send_before,
+                    additional_headers=additional_headers,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_CreateEmailResponse(res.json())
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/content.py` & `scaleway_async-2.1.0/scaleway_async/tem/v1alpha1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/secret/v1beta1/marshalling.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,210 +2,151 @@
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 from dateutil import parser
 
 from scaleway_core.profile import ProfileDefaults
 from .types import (
-    EmailFlag,
-    EmailTry,
-    Email,
-    DomainReputation,
-    DomainStatistics,
-    Domain,
-    CreateEmailResponse,
-    DomainLastStatusDkimRecord,
-    DomainLastStatusSpfRecord,
-    DomainLastStatus,
-    ListDomainsResponse,
-    ListEmailsResponse,
-    Statistics,
-    CreateDomainRequest,
-    CreateEmailRequestAddress,
-    CreateEmailRequestAttachment,
-    CreateEmailRequest,
+    EphemeralProperties,
+    SecretVersion,
+    EphemeralPolicy,
+    Secret,
+    AccessSecretVersionResponse,
+    BrowseSecretsResponseItemFolderDetails,
+    BrowseSecretsResponseItemSecretDetails,
+    BrowseSecretsResponseItem,
+    BrowseSecretsResponse,
+    ListSecretVersionsResponse,
+    ListSecretsResponse,
+    ListTagsResponse,
+    AddSecretOwnerRequest,
+    CreateSecretRequest,
+    CreateSecretVersionRequest,
+    UpdateSecretRequest,
+    UpdateSecretVersionRequest,
 )
 
 
-def unmarshal_EmailTry(data: Any) -> EmailTry:
+def unmarshal_EphemeralProperties(data: Any) -> EphemeralProperties:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'EmailTry' failed as data isn't a dictionary."
+            "Unmarshalling the type 'EphemeralProperties' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("rank", None)
+    field = data.get("action", None)
     if field is not None:
-        args["rank"] = field
+        args["action"] = field
 
-    field = data.get("code", None)
+    field = data.get("expires_at", None)
     if field is not None:
-        args["code"] = field
+        args["expires_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["expires_at"] = None
 
-    field = data.get("message", None)
+    field = data.get("expires_once_accessed", None)
     if field is not None:
-        args["message"] = field
+        args["expires_once_accessed"] = field
+    else:
+        args["expires_once_accessed"] = None
 
-    field = data.get("tried_at", None)
-    if field is not None:
-        args["tried_at"] = parser.isoparse(field) if isinstance(field, str) else field
-
-    return EmailTry(**args)
+    return EphemeralProperties(**args)
 
 
-def unmarshal_Email(data: Any) -> Email:
+def unmarshal_SecretVersion(data: Any) -> SecretVersion:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Email' failed as data isn't a dictionary."
+            "Unmarshalling the type 'SecretVersion' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id", None)
-    if field is not None:
-        args["id"] = field
-
-    field = data.get("message_id", None)
-    if field is not None:
-        args["message_id"] = field
-
-    field = data.get("project_id", None)
-    if field is not None:
-        args["project_id"] = field
-
-    field = data.get("mail_from", None)
-    if field is not None:
-        args["mail_from"] = field
-
-    field = data.get("mail_rcpt", None)
-    if field is not None:
-        args["mail_rcpt"] = field
-
-    field = data.get("rcpt_to", None)
-    if field is not None:
-        args["rcpt_to"] = field
-
-    field = data.get("rcpt_type", None)
+    field = data.get("revision", None)
     if field is not None:
-        args["rcpt_type"] = field
+        args["revision"] = field
 
-    field = data.get("subject", None)
+    field = data.get("secret_id", None)
     if field is not None:
-        args["subject"] = field
+        args["secret_id"] = field
 
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
-    field = data.get("try_count", None)
-    if field is not None:
-        args["try_count"] = field
-
-    field = data.get("last_tries", None)
+    field = data.get("latest", None)
     if field is not None:
-        args["last_tries"] = (
-            [unmarshal_EmailTry(v) for v in field] if field is not None else None
-        )
-
-    field = data.get("flags", None)
-    if field is not None:
-        args["flags"] = [EmailFlag(v) for v in field] if field is not None else None
+        args["latest"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
-    field = data.get("status_details", None)
-    if field is not None:
-        args["status_details"] = field
-
-    return Email(**args)
-
-
-def unmarshal_DomainReputation(data: Any) -> DomainReputation:
-    if not isinstance(data, dict):
-        raise TypeError(
-            "Unmarshalling the type 'DomainReputation' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
-
-    field = data.get("score", None)
+    field = data.get("description", None)
     if field is not None:
-        args["score"] = field
+        args["description"] = field
+    else:
+        args["description"] = None
 
-    field = data.get("scored_at", None)
+    field = data.get("ephemeral_properties", None)
     if field is not None:
-        args["scored_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["ephemeral_properties"] = unmarshal_EphemeralProperties(field)
+    else:
+        args["ephemeral_properties"] = None
 
-    field = data.get("previous_score", None)
-    if field is not None:
-        args["previous_score"] = field
+    return SecretVersion(**args)
 
-    field = data.get("previous_scored_at", None)
-    if field is not None:
-        args["previous_scored_at"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
 
-    return DomainReputation(**args)
-
-
-def unmarshal_DomainStatistics(data: Any) -> DomainStatistics:
+def unmarshal_EphemeralPolicy(data: Any) -> EphemeralPolicy:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'DomainStatistics' failed as data isn't a dictionary."
+            "Unmarshalling the type 'EphemeralPolicy' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count", None)
-    if field is not None:
-        args["total_count"] = field
-
-    field = data.get("sent_count", None)
+    field = data.get("action", None)
     if field is not None:
-        args["sent_count"] = field
+        args["action"] = field
 
-    field = data.get("failed_count", None)
+    field = data.get("time_to_live", None)
     if field is not None:
-        args["failed_count"] = field
+        args["time_to_live"] = field
+    else:
+        args["time_to_live"] = None
 
-    field = data.get("canceled_count", None)
+    field = data.get("expires_once_accessed", None)
     if field is not None:
-        args["canceled_count"] = field
+        args["expires_once_accessed"] = field
+    else:
+        args["expires_once_accessed"] = None
 
-    return DomainStatistics(**args)
+    return EphemeralPolicy(**args)
 
 
-def unmarshal_Domain(data: Any) -> Domain:
+def unmarshal_Secret(data: Any) -> Secret:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Domain' failed as data isn't a dictionary."
+            "Unmarshalling the type 'Secret' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
     field = data.get("id", None)
     if field is not None:
         args["id"] = field
 
-    field = data.get("organization_id", None)
-    if field is not None:
-        args["organization_id"] = field
-
     field = data.get("project_id", None)
     if field is not None:
         args["project_id"] = field
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
@@ -213,319 +154,412 @@
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
+
+    field = data.get("updated_at", None)
+    if field is not None:
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
-    field = data.get("spf_config", None)
+    field = data.get("tags", None)
     if field is not None:
-        args["spf_config"] = field
+        args["tags"] = field
 
-    field = data.get("dkim_config", None)
+    field = data.get("version_count", None)
     if field is not None:
-        args["dkim_config"] = field
+        args["version_count"] = field
 
-    field = data.get("region", None)
+    field = data.get("managed", None)
     if field is not None:
-        args["region"] = field
+        args["managed"] = field
 
-    field = data.get("next_check_at", None)
+    field = data.get("protected", None)
     if field is not None:
-        args["next_check_at"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["protected"] = field
 
-    field = data.get("last_valid_at", None)
+    field = data.get("type", None)
     if field is not None:
-        args["last_valid_at"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["type_"] = field
 
-    field = data.get("revoked_at", None)
+    field = data.get("path", None)
     if field is not None:
-        args["revoked_at"] = parser.isoparse(field) if isinstance(field, str) else field
+        args["path"] = field
 
-    field = data.get("last_error", None)
+    field = data.get("region", None)
     if field is not None:
-        args["last_error"] = field
+        args["region"] = field
 
-    field = data.get("statistics", None)
+    field = data.get("description", None)
     if field is not None:
-        args["statistics"] = unmarshal_DomainStatistics(field)
+        args["description"] = field
+    else:
+        args["description"] = None
 
-    field = data.get("reputation", None)
+    field = data.get("ephemeral_policy", None)
     if field is not None:
-        args["reputation"] = unmarshal_DomainReputation(field)
+        args["ephemeral_policy"] = unmarshal_EphemeralPolicy(field)
+    else:
+        args["ephemeral_policy"] = None
 
-    return Domain(**args)
+    return Secret(**args)
 
 
-def unmarshal_CreateEmailResponse(data: Any) -> CreateEmailResponse:
+def unmarshal_AccessSecretVersionResponse(data: Any) -> AccessSecretVersionResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'CreateEmailResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'AccessSecretVersionResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("emails", None)
+    field = data.get("secret_id", None)
+    if field is not None:
+        args["secret_id"] = field
+
+    field = data.get("revision", None)
     if field is not None:
-        args["emails"] = (
-            [unmarshal_Email(v) for v in field] if field is not None else None
+        args["revision"] = field
+
+    field = data.get("data", None)
+    if field is not None:
+        args["data"] = field
+
+    field = data.get("type", None)
+    if field is not None:
+        args["type_"] = field
+
+    field = data.get("data_crc32", None)
+    if field is not None:
+        args["data_crc32"] = field
+    else:
+        args["data_crc32"] = None
+
+    return AccessSecretVersionResponse(**args)
+
+
+def unmarshal_BrowseSecretsResponseItemFolderDetails(
+    data: Any,
+) -> BrowseSecretsResponseItemFolderDetails:
+    if not isinstance(data, dict):
+        raise TypeError(
+            "Unmarshalling the type 'BrowseSecretsResponseItemFolderDetails' failed as data isn't a dictionary."
         )
 
-    return CreateEmailResponse(**args)
+    args: Dict[str, Any] = {}
+
+    return BrowseSecretsResponseItemFolderDetails(**args)
 
 
-def unmarshal_DomainLastStatusDkimRecord(data: Any) -> DomainLastStatusDkimRecord:
+def unmarshal_BrowseSecretsResponseItemSecretDetails(
+    data: Any,
+) -> BrowseSecretsResponseItemSecretDetails:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'DomainLastStatusDkimRecord' failed as data isn't a dictionary."
+            "Unmarshalling the type 'BrowseSecretsResponseItemSecretDetails' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("status", None)
+    field = data.get("id", None)
     if field is not None:
-        args["status"] = field
+        args["id"] = field
 
-    field = data.get("last_valid_at", None)
+    field = data.get("tags", None)
     if field is not None:
-        args["last_valid_at"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["tags"] = field
 
-    field = data.get("error", None)
+    field = data.get("version_count", None)
     if field is not None:
-        args["error"] = field
+        args["version_count"] = field
 
-    return DomainLastStatusDkimRecord(**args)
+    field = data.get("protected", None)
+    if field is not None:
+        args["protected"] = field
+
+    field = data.get("ephemeral_policy", None)
+    if field is not None:
+        args["ephemeral_policy"] = unmarshal_EphemeralPolicy(field)
+    else:
+        args["ephemeral_policy"] = None
+
+    return BrowseSecretsResponseItemSecretDetails(**args)
 
 
-def unmarshal_DomainLastStatusSpfRecord(data: Any) -> DomainLastStatusSpfRecord:
+def unmarshal_BrowseSecretsResponseItem(data: Any) -> BrowseSecretsResponseItem:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'DomainLastStatusSpfRecord' failed as data isn't a dictionary."
+            "Unmarshalling the type 'BrowseSecretsResponseItem' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("status", None)
+    field = data.get("name", None)
     if field is not None:
-        args["status"] = field
+        args["name"] = field
 
-    field = data.get("last_valid_at", None)
+    field = data.get("created_at", None)
     if field is not None:
-        args["last_valid_at"] = (
-            parser.isoparse(field) if isinstance(field, str) else field
-        )
+        args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
-    field = data.get("error", None)
+    field = data.get("updated_at", None)
+    if field is not None:
+        args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
+
+    field = data.get("secret", None)
+    if field is not None:
+        args["secret"] = unmarshal_BrowseSecretsResponseItemSecretDetails(field)
+    else:
+        args["secret"] = None
+
+    field = data.get("folder", None)
     if field is not None:
-        args["error"] = field
+        args["folder"] = unmarshal_BrowseSecretsResponseItemFolderDetails(field)
+    else:
+        args["folder"] = None
 
-    return DomainLastStatusSpfRecord(**args)
+    return BrowseSecretsResponseItem(**args)
 
 
-def unmarshal_DomainLastStatus(data: Any) -> DomainLastStatus:
+def unmarshal_BrowseSecretsResponse(data: Any) -> BrowseSecretsResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'DomainLastStatus' failed as data isn't a dictionary."
+            "Unmarshalling the type 'BrowseSecretsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domain_id", None)
-    if field is not None:
-        args["domain_id"] = field
-
-    field = data.get("domain_name", None)
+    field = data.get("items", None)
     if field is not None:
-        args["domain_name"] = field
+        args["items"] = (
+            [unmarshal_BrowseSecretsResponseItem(v) for v in field]
+            if field is not None
+            else None
+        )
 
-    field = data.get("spf_record", None)
+    field = data.get("current_path", None)
     if field is not None:
-        args["spf_record"] = unmarshal_DomainLastStatusSpfRecord(field)
+        args["current_path"] = field
 
-    field = data.get("dkim_record", None)
+    field = data.get("total_count", None)
     if field is not None:
-        args["dkim_record"] = unmarshal_DomainLastStatusDkimRecord(field)
+        args["total_count"] = field
 
-    return DomainLastStatus(**args)
+    return BrowseSecretsResponse(**args)
 
 
-def unmarshal_ListDomainsResponse(data: Any) -> ListDomainsResponse:
+def unmarshal_ListSecretVersionsResponse(data: Any) -> ListSecretVersionsResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListSecretVersionsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count", None)
+    field = data.get("versions", None)
     if field is not None:
-        args["total_count"] = field
+        args["versions"] = (
+            [unmarshal_SecretVersion(v) for v in field] if field is not None else None
+        )
 
-    field = data.get("domains", None)
+    field = data.get("total_count", None)
     if field is not None:
-        args["domains"] = (
-            [unmarshal_Domain(v) for v in field] if field is not None else None
-        )
+        args["total_count"] = field
 
-    return ListDomainsResponse(**args)
+    return ListSecretVersionsResponse(**args)
 
 
-def unmarshal_ListEmailsResponse(data: Any) -> ListEmailsResponse:
+def unmarshal_ListSecretsResponse(data: Any) -> ListSecretsResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'ListEmailsResponse' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListSecretsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count", None)
+    field = data.get("secrets", None)
     if field is not None:
-        args["total_count"] = field
+        args["secrets"] = (
+            [unmarshal_Secret(v) for v in field] if field is not None else None
+        )
 
-    field = data.get("emails", None)
+    field = data.get("total_count", None)
     if field is not None:
-        args["emails"] = (
-            [unmarshal_Email(v) for v in field] if field is not None else None
-        )
+        args["total_count"] = field
 
-    return ListEmailsResponse(**args)
+    return ListSecretsResponse(**args)
 
 
-def unmarshal_Statistics(data: Any) -> Statistics:
+def unmarshal_ListTagsResponse(data: Any) -> ListTagsResponse:
     if not isinstance(data, dict):
         raise TypeError(
-            "Unmarshalling the type 'Statistics' failed as data isn't a dictionary."
+            "Unmarshalling the type 'ListTagsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
+    field = data.get("tags", None)
+    if field is not None:
+        args["tags"] = field
+
     field = data.get("total_count", None)
     if field is not None:
         args["total_count"] = field
 
-    field = data.get("new_count", None)
-    if field is not None:
-        args["new_count"] = field
+    return ListTagsResponse(**args)
 
-    field = data.get("sending_count", None)
-    if field is not None:
-        args["sending_count"] = field
 
-    field = data.get("sent_count", None)
-    if field is not None:
-        args["sent_count"] = field
+def marshal_AddSecretOwnerRequest(
+    request: AddSecretOwnerRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("failed_count", None)
-    if field is not None:
-        args["failed_count"] = field
+    if request.product is not None:
+        output["product"] = str(request.product)
 
-    field = data.get("canceled_count", None)
-    if field is not None:
-        args["canceled_count"] = field
+    return output
+
+
+def marshal_EphemeralPolicy(
+    request: EphemeralPolicy,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return Statistics(**args)
+    if request.action is not None:
+        output["action"] = str(request.action)
 
+    if request.time_to_live is not None:
+        output["time_to_live"] = request.time_to_live
 
-def marshal_CreateDomainRequest(
-    request: CreateDomainRequest,
+    if request.expires_once_accessed is not None:
+        output["expires_once_accessed"] = request.expires_once_accessed
+
+    return output
+
+
+def marshal_CreateSecretRequest(
+    request: CreateSecretRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.domain_name is not None:
-        output["domain_name"] = request.domain_name
+    if request.name is not None:
+        output["name"] = request.name
 
-    if request.accept_tos is not None:
-        output["accept_tos"] = request.accept_tos
+    if request.protected is not None:
+        output["protected"] = request.protected
 
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.type_ is not None:
+        output["type"] = str(request.type_)
+
+    if request.path is not None:
+        output["path"] = request.path
+
+    if request.ephemeral_policy is not None:
+        output["ephemeral_policy"] = (
+            marshal_EphemeralPolicy(request.ephemeral_policy, defaults),
+        )
+
     return output
 
 
-def marshal_CreateEmailRequestAddress(
-    request: CreateEmailRequestAddress,
+def marshal_CreateSecretVersionRequest(
+    request: CreateSecretVersionRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.email is not None:
-        output["email"] = request.email
+    if request.data is not None:
+        output["data"] = request.data
 
-    if request.name is not None:
-        output["name"] = request.name
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.disable_previous is not None:
+        output["disable_previous"] = request.disable_previous
+
+    if request.data_crc32 is not None:
+        output["data_crc32"] = request.data_crc32
 
     return output
 
 
-def marshal_CreateEmailRequestAttachment(
-    request: CreateEmailRequestAttachment,
+def marshal_UpdateSecretRequest(
+    request: UpdateSecretRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.name is not None:
         output["name"] = request.name
 
-    if request.type_ is not None:
-        output["type"] = request.type_
+    if request.tags is not None:
+        output["tags"] = request.tags
 
-    if request.content is not None:
-        output["content"] = request.content
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.path is not None:
+        output["path"] = request.path
+
+    if request.ephemeral_policy is not None:
+        output["ephemeral_policy"] = (
+            marshal_EphemeralPolicy(request.ephemeral_policy, defaults),
+        )
 
     return output
 
 
-def marshal_CreateEmailRequest(
-    request: CreateEmailRequest,
+def marshal_EphemeralProperties(
+    request: EphemeralProperties,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
-    if request.subject is not None:
-        output["subject"] = request.subject
+    if request.action is not None:
+        output["action"] = str(request.action)
 
-    if request.text is not None:
-        output["text"] = request.text
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
 
-    if request.html is not None:
-        output["html"] = request.html
+    if request.expires_once_accessed is not None:
+        output["expires_once_accessed"] = request.expires_once_accessed
 
-    if request.from_ is not None:
-        output["from"] = (marshal_CreateEmailRequestAddress(request.from_, defaults),)
-
-    if request.to is not None:
-        output["to"] = [
-            marshal_CreateEmailRequestAddress(item, defaults) for item in request.to
-        ]
-
-    if request.cc is not None:
-        output["cc"] = [
-            marshal_CreateEmailRequestAddress(item, defaults) for item in request.cc
-        ]
-
-    if request.bcc is not None:
-        output["bcc"] = [
-            marshal_CreateEmailRequestAddress(item, defaults) for item in request.bcc
-        ]
+    return output
 
-    if request.project_id is not None:
-        output["project_id"] = request.project_id or defaults.default_project_id
 
-    if request.attachments is not None:
-        output["attachments"] = [
-            marshal_CreateEmailRequestAttachment(item, defaults)
-            for item in request.attachments
-        ]
+def marshal_UpdateSecretVersionRequest(
+    request: UpdateSecretVersionRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    if request.send_before is not None:
-        output["send_before"] = request.send_before
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.ephemeral_properties is not None:
+        output["ephemeral_properties"] = (
+            marshal_EphemeralProperties(request.ephemeral_properties, defaults),
+        )
 
     return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/tem/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/tem/v1alpha1/types.py`

 * *Files 3% similar despite different names*

```diff
@@ -100,14 +100,27 @@
     SUBJECT_ASC = "subject_asc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
+class DomainRecordsDMARC:
+    name: str
+    """
+    Name of the DMARC TXT record.
+    """
+
+    value: str
+    """
+    Value of the DMARC TXT record.
+    """
+
+
+@dataclass
 class EmailTry:
     rank: int
     """
     Rank number of this attempt to send the email.
     """
 
     code: int
@@ -123,14 +136,22 @@
     tried_at: Optional[datetime]
     """
     Date of the attempt to send the email.
     """
 
 
 @dataclass
+class DomainRecords:
+    dmarc: Optional[DomainRecordsDMARC]
+    """
+    DMARC TXT record specification.
+    """
+
+
+@dataclass
 class DomainReputation:
     status: DomainReputationStatus
     """
     Status of your domain's reputation.
     """
 
     score: int
@@ -193,14 +214,27 @@
     content: str
     """
     Content of the attachment encoded in base64.
     """
 
 
 @dataclass
+class CreateEmailRequestHeader:
+    key: str
+    """
+    Email header key.
+    """
+
+    value: str
+    """
+    Email header value.
+    """
+
+
+@dataclass
 class Email:
     id: str
     """
     Technical ID of the email.
     """
 
     message_id: str
@@ -289,14 +323,32 @@
     error: Optional[str]
     """
     An error text displays in case the record is not valid.
     """
 
 
 @dataclass
+class DomainLastStatusDmarcRecord:
+    status: DomainLastStatusRecordStatus
+    """
+    Status of the DMARC record's configuration.
+    """
+
+    last_valid_at: Optional[datetime]
+    """
+    Time and date the DMARC record was last valid.
+    """
+
+    error: Optional[str]
+    """
+    An error text displays in case the record is not valid.
+    """
+
+
+@dataclass
 class DomainLastStatusSpfRecord:
     status: DomainLastStatusRecordStatus
     """
     Status of the SPF record's configuration.
     """
 
     last_valid_at: Optional[datetime]
@@ -333,44 +385,44 @@
     """
 
     status: DomainStatus
     """
     Status of the domain.
     """
 
-    created_at: Optional[datetime]
-    """
-    Date and time of domain creation.
-    """
-
     spf_config: str
     """
     Snippet of the SPF record to register in the DNS zone.
     """
 
-    dkim_config: str
-    """
-    DKIM public key to record in the DNS zone.
-    """
-
-    region: Region
+    created_at: Optional[datetime]
     """
-    Region to target. If none is passed will use default region from the config.
+    Date and time of domain creation.
     """
 
     next_check_at: Optional[datetime]
     """
     Date and time of the next scheduled check.
     """
 
     last_valid_at: Optional[datetime]
     """
     Date and time the domain was last valid.
     """
 
+    dkim_config: str
+    """
+    DKIM public key to record in the DNS zone.
+    """
+
+    region: Region
+    """
+    Region to target. If none is passed will use default region from the config.
+    """
+
     revoked_at: Optional[datetime]
     """
     Date and time of the domain's deletion.
     """
 
     last_error: Optional[str]
     """
@@ -383,14 +435,19 @@
     """
 
     reputation: Optional[DomainReputation]
     """
     The domain's reputation is available when your domain is checked and has sent enough emails.
     """
 
+    records: Optional[DomainRecords]
+    """
+    List of records to configure to validate a domain.
+    """
+
 
 @dataclass
 class CancelEmailRequest:
     email_id: str
     """
     ID of the email to cancel.
     """
@@ -490,14 +547,19 @@
     """
 
     send_before: Optional[datetime]
     """
     Maximum date to deliver the email.
     """
 
+    additional_headers: Optional[List[CreateEmailRequestHeader]]
+    """
+    Array of additional headers as key-value.
+    """
+
 
 @dataclass
 class CreateEmailResponse:
     emails: List[Email]
     """
     Single page of emails matching the requested criteria.
     """
@@ -521,14 +583,19 @@
     """
 
     dkim_record: Optional[DomainLastStatusDkimRecord]
     """
     The DKIM record verification data.
     """
 
+    dmarc_record: Optional[DomainLastStatusDmarcRecord]
+    """
+    The DMARC record verification data.
+    """
+
 
 @dataclass
 class GetDomainLastStatusRequest:
     domain_id: str
     """
     ID of the domain to delete.
     """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/test/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/test/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/test/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/test/v1/api.py`

 * *Files 4% similar despite different names*

```diff
@@ -80,15 +80,14 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListHumansRequestOrderBy] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListHumansResponse:
         """
         List all your humans.
-        List all your humans.
         :param page:
         :param page_size:
         :param order_by:
         :param organization_id:
         :param project_id:
         :return: :class:`ListHumansResponse <ListHumansResponse>`
 
@@ -121,15 +120,14 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListHumansRequestOrderBy] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Human]:
         """
         List all your humans.
-        List all your humans.
         :param page:
         :param page_size:
         :param order_by:
         :param organization_id:
         :param project_id:
         :return: :class:`List[Human] <List[Human]>`
 
@@ -228,26 +226,27 @@
         name: str,
         eyes_color: Optional[EyeColors] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> Human:
         """
         Create a new human.
-        Create a new human.
         :param height:
         :param shoe_size:
         :param altitude_in_meter:
         :param altitude_in_millimeter:
         :param fingers_count:
         :param hair_count:
         :param is_happy:
         :param name:
         :param eyes_color:
         :param organization_id:
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :param project_id:
+        One-Of ('project_identifier'): at most one of 'project_id', 'organization_id' could be set.
         :return: :class:`Human <Human>`
 
         Usage:
         ::
 
             result = await api.create_human(
                 height=3.14,
@@ -409,15 +408,14 @@
     async def smoke_human(
         self,
         *,
         human_id: str,
     ) -> Human:
         """
         Make a human smoke.
-        Make a human smoke.
         :param human_id: UUID of the human you want to make smoking.
         :return: :class:`Human <Human>`
         :deprecated
 
         Usage:
         ::
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/test/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/test/v1/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpc/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/vpc/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpc/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/vpc/v1/api.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpc/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/vpc/v1/marshalling.py`

 * *Files 8% similar despite different names*

```diff
@@ -48,18 +48,22 @@
     field = data.get("subnets", None)
     if field is not None:
         args["subnets"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return PrivateNetwork(**args)
 
 
 def unmarshal_ListPrivateNetworksResponse(data: Any) -> ListPrivateNetworksResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpc/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/vpc/v1/types.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpc/v2/__init__.py` & `scaleway_async-2.1.0/scaleway_async/vpc/v2/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 from .types import CreatePrivateNetworkRequest
 from .types import CreateVPCRequest
 from .types import DeletePrivateNetworkRequest
 from .types import DeleteSubnetsRequest
 from .types import DeleteSubnetsResponse
 from .types import DeleteVPCRequest
 from .types import EnableDHCPRequest
+from .types import EnableRoutingRequest
 from .types import GetPrivateNetworkRequest
 from .types import GetVPCRequest
 from .types import ListPrivateNetworksRequest
 from .types import ListPrivateNetworksResponse
 from .types import ListVPCsRequest
 from .types import ListVPCsResponse
 from .types import MigrateZonalPrivateNetworksRequest
@@ -38,14 +39,15 @@
     "CreatePrivateNetworkRequest",
     "CreateVPCRequest",
     "DeletePrivateNetworkRequest",
     "DeleteSubnetsRequest",
     "DeleteSubnetsResponse",
     "DeleteVPCRequest",
     "EnableDHCPRequest",
+    "EnableRoutingRequest",
     "GetPrivateNetworkRequest",
     "GetVPCRequest",
     "ListPrivateNetworksRequest",
     "ListPrivateNetworksResponse",
     "ListVPCsRequest",
     "ListVPCsResponse",
     "MigrateZonalPrivateNetworksRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpc/v2/api.py` & `scaleway_async-2.1.0/scaleway_async/vpc/v2/api.py`

 * *Files 4% similar despite different names*

```diff
@@ -63,27 +63,29 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         is_default: Optional[bool] = None,
+        routing_enabled: Optional[bool] = None,
     ) -> ListVPCsResponse:
         """
         List VPCs.
         List existing VPCs in the specified region.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of the returned VPCs.
         :param page: Page number to return, from the paginated results.
         :param page_size: Maximum number of VPCs to return per page.
         :param name: Name to filter for. Only VPCs with names containing this string will be returned.
         :param tags: Tags to filter for. Only VPCs with one more more matching tags will be returned.
         :param organization_id: Organization ID to filter for. Only VPCs belonging to this Organization will be returned.
         :param project_id: Project ID to filter for. Only VPCs belonging to this Project will be returned.
         :param is_default: Defines whether to filter only for VPCs which are the default one for their Project.
+        :param routing_enabled: Defines whether to filter only for VPCs which route traffic between their Private Networks.
         :return: :class:`ListVPCsResponse <ListVPCsResponse>`
 
         Usage:
         ::
 
             result = await api.list_vp_cs()
         """
@@ -100,14 +102,15 @@
                 "name": name,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
+                "routing_enabled": routing_enabled,
                 "tags": tags,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListVPCsResponse(res.json())
 
@@ -119,27 +122,29 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         is_default: Optional[bool] = None,
+        routing_enabled: Optional[bool] = None,
     ) -> List[VPC]:
         """
         List VPCs.
         List existing VPCs in the specified region.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of the returned VPCs.
         :param page: Page number to return, from the paginated results.
         :param page_size: Maximum number of VPCs to return per page.
         :param name: Name to filter for. Only VPCs with names containing this string will be returned.
         :param tags: Tags to filter for. Only VPCs with one more more matching tags will be returned.
         :param organization_id: Organization ID to filter for. Only VPCs belonging to this Organization will be returned.
         :param project_id: Project ID to filter for. Only VPCs belonging to this Project will be returned.
         :param is_default: Defines whether to filter only for VPCs which are the default one for their Project.
+        :param routing_enabled: Defines whether to filter only for VPCs which route traffic between their Private Networks.
         :return: :class:`List[VPC] <List[VPC]>`
 
         Usage:
         ::
 
             result = await api.list_vp_cs_all()
         """
@@ -154,49 +159,55 @@
                 "page": page,
                 "page_size": page_size,
                 "name": name,
                 "tags": tags,
                 "organization_id": organization_id,
                 "project_id": project_id,
                 "is_default": is_default,
+                "routing_enabled": routing_enabled,
             },
         )
 
     async def create_vpc(
         self,
         *,
+        enable_routing: bool,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         project_id: Optional[str] = None,
         tags: Optional[List[str]] = None,
     ) -> VPC:
         """
         Create a VPC.
         Create a new VPC in the specified region.
+        :param enable_routing: Enable routing between Private Networks in the VPC.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name for the VPC.
         :param project_id: Scaleway Project in which to create the VPC.
         :param tags: Tags for the VPC.
         :return: :class:`VPC <VPC>`
 
         Usage:
         ::
 
-            result = await api.create_vpc()
+            result = await api.create_vpc(
+                enable_routing=False,
+            )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
             f"/vpc/v2/regions/{param_region}/vpcs",
             body=marshal_CreateVPCRequest(
                 CreateVPCRequest(
+                    enable_routing=enable_routing,
                     region=region,
                     name=name or random_name(prefix="vpc"),
                     project_id=project_id,
                     tags=tags,
                 ),
                 self.client,
             ),
@@ -614,15 +625,17 @@
         private_network_ids: Optional[List[str]] = None,
     ) -> None:
         """
         Migrate Private Networks from zoned to regional.
         Transform multiple existing zoned Private Networks (scoped to a single Availability Zone) into regional Private Networks, scoped to an entire region. You can transform one or many Private Networks (specified by their Private Network IDs) within a single Scaleway Organization or Project, with the same call.
         :param region: Region to target. If none is passed will use default region from the config.
         :param organization_id: Organization ID to target. The specified zoned Private Networks within this Organization will be migrated to regional.
+        One-Of ('scope'): at most one of 'organization_id', 'project_id' could be set.
         :param project_id: Project to target. The specified zoned Private Networks within this Project will be migrated to regional.
+        One-Of ('scope'): at most one of 'organization_id', 'project_id' could be set.
         :param private_network_ids: IDs of the Private Networks to migrate.
 
         Usage:
         ::
 
             result = await api.migrate_zonal_private_networks()
         """
@@ -680,14 +693,49 @@
             f"/vpc/v2/regions/{param_region}/private-networks/{param_private_network_id}/enable-dhcp",
             body={},
         )
 
         self._throw_on_error(res)
         return unmarshal_PrivateNetwork(res.json())
 
+    async def enable_routing(
+        self,
+        *,
+        vpc_id: str,
+        region: Optional[Region] = None,
+    ) -> VPC:
+        """
+        Enable routing on a VPC.
+        Enable routing on an existing VPC. Note that you will not be able to deactivate it afterwards.
+        :param vpc_id:
+        :param region: Region to target. If none is passed will use default region from the config.
+        :return: :class:`VPC <VPC>`
+
+        Usage:
+        ::
+
+            result = await api.enable_routing(
+                vpc_id="example",
+            )
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_vpc_id = validate_path_param("vpc_id", vpc_id)
+
+        res = self._request(
+            "POST",
+            f"/vpc/v2/regions/{param_region}/vpcs/{param_vpc_id}/enable-routing",
+            body={},
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_VPC(res.json())
+
     async def set_subnets(
         self,
         *,
         private_network_id: str,
         region: Optional[Region] = None,
         subnets: Optional[List[str]] = None,
     ) -> SetSubnetsResponse:
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpc/v2/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/vpc/v2/marshalling.py`

 * *Files 3% similar despite different names*

```diff
@@ -44,18 +44,22 @@
     field = data.get("subnet", None)
     if field is not None:
         args["subnet"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return Subnet(**args)
 
 
 def unmarshal_PrivateNetwork(data: Any) -> PrivateNetwork:
     if not isinstance(data, dict):
         raise TypeError(
@@ -101,18 +105,22 @@
     field = data.get("dhcp_enabled", None)
     if field is not None:
         args["dhcp_enabled"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return PrivateNetwork(**args)
 
 
 def unmarshal_VPC(data: Any) -> VPC:
     if not isinstance(data, dict):
         raise TypeError(
@@ -149,21 +157,29 @@
     if field is not None:
         args["is_default"] = field
 
     field = data.get("private_network_count", None)
     if field is not None:
         args["private_network_count"] = field
 
+    field = data.get("routing_enabled", None)
+    if field is not None:
+        args["routing_enabled"] = field
+
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return VPC(**args)
 
 
 def unmarshal_AddSubnetsResponse(data: Any) -> AddSubnetsResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -287,14 +303,17 @@
 
 def marshal_CreateVPCRequest(
     request: CreateVPCRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
+    if request.enable_routing is not None:
+        output["enable_routing"] = request.enable_routing
+
     if request.name is not None:
         output["name"] = request.name
 
     if request.project_id is not None:
         output["project_id"] = request.project_id or defaults.default_project_id
 
     if request.tags is not None:
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/vpcgw/v1/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import DHCPEntryType
 from .types import GatewayNetworkStatus
-from .content import GATEWAYNETWORK_TRANSIENT_STATUSES
+from .content import GATEWAY_NETWORK_TRANSIENT_STATUSES
 from .types import GatewayStatus
 from .content import GATEWAY_TRANSIENT_STATUSES
 from .types import ListDHCPEntriesRequestOrderBy
 from .types import ListDHCPsRequestOrderBy
 from .types import ListGatewayNetworksRequestOrderBy
 from .types import ListGatewaysRequestOrderBy
 from .types import ListIPsRequestOrderBy
@@ -32,14 +32,15 @@
 from .types import CreatePATRuleRequest
 from .types import DeleteDHCPEntryRequest
 from .types import DeleteDHCPRequest
 from .types import DeleteGatewayNetworkRequest
 from .types import DeleteGatewayRequest
 from .types import DeleteIPRequest
 from .types import DeletePATRuleRequest
+from .types import EnableIPMobilityRequest
 from .types import GetDHCPEntryRequest
 from .types import GetDHCPRequest
 from .types import GetGatewayNetworkRequest
 from .types import GetGatewayRequest
 from .types import GetIPRequest
 from .types import GetPATRuleRequest
 from .types import ListDHCPEntriesRequest
@@ -69,15 +70,15 @@
 from .types import UpdatePATRuleRequest
 from .types import UpgradeGatewayRequest
 from .api import VpcgwV1API
 
 __all__ = [
     "DHCPEntryType",
     "GatewayNetworkStatus",
-    "GATEWAYNETWORK_TRANSIENT_STATUSES",
+    "GATEWAY_NETWORK_TRANSIENT_STATUSES",
     "GatewayStatus",
     "GATEWAY_TRANSIENT_STATUSES",
     "ListDHCPEntriesRequestOrderBy",
     "ListDHCPsRequestOrderBy",
     "ListGatewayNetworksRequestOrderBy",
     "ListGatewaysRequestOrderBy",
     "ListIPsRequestOrderBy",
@@ -103,14 +104,15 @@
     "CreatePATRuleRequest",
     "DeleteDHCPEntryRequest",
     "DeleteDHCPRequest",
     "DeleteGatewayNetworkRequest",
     "DeleteGatewayRequest",
     "DeleteIPRequest",
     "DeletePATRuleRequest",
+    "EnableIPMobilityRequest",
     "GetDHCPEntryRequest",
     "GetDHCPRequest",
     "GetGatewayNetworkRequest",
     "GetGatewayRequest",
     "GetIPRequest",
     "GetPATRuleRequest",
     "ListDHCPEntriesRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/api.py` & `scaleway_async-2.1.0/scaleway_async/vpcgw/v1/api.py`

 * *Files 1% similar despite different names*

```diff
@@ -56,15 +56,15 @@
     UpdateGatewayNetworkRequest,
     UpdateGatewayNetworkRequestIpamConfig,
     UpdateGatewayRequest,
     UpdateIPRequest,
     UpdatePATRuleRequest,
 )
 from .content import (
-    GATEWAYNETWORK_TRANSIENT_STATUSES,
+    GATEWAY_NETWORK_TRANSIENT_STATUSES,
     GATEWAY_TRANSIENT_STATUSES,
 )
 from .marshalling import (
     unmarshal_DHCP,
     unmarshal_GatewayNetwork,
     unmarshal_IP,
     unmarshal_DHCPEntry,
@@ -472,14 +472,45 @@
             f"/vpc-gw/v1/zones/{param_zone}/gateways/{param_gateway_id}/upgrade",
             body={},
         )
 
         self._throw_on_error(res)
         return unmarshal_Gateway(res.json())
 
+    async def enable_ip_mobility(
+        self,
+        *,
+        gateway_id: str,
+        zone: Optional[Zone] = None,
+    ) -> None:
+        """
+        Upgrade a Public Gateway to IP mobility.
+        Upgrade a Public Gateway to IP mobility (move from NAT IP to routed IP). This is idempotent: repeated calls after the first will return no error but have no effect.
+        :param gateway_id: ID of the gateway to upgrade to IP mobility.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+
+        Usage:
+        ::
+
+            result = await api.enable_ip_mobility(
+                gateway_id="example",
+            )
+        """
+
+        param_zone = validate_path_param("zone", zone or self.client.default_zone)
+        param_gateway_id = validate_path_param("gateway_id", gateway_id)
+
+        res = self._request(
+            "POST",
+            f"/vpc-gw/v1/zones/{param_zone}/gateways/{param_gateway_id}/enable-ip-mobility",
+            body={},
+        )
+
+        self._throw_on_error(res)
+
     async def list_gateway_networks(
         self,
         *,
         zone: Optional[Zone] = None,
         order_by: Optional[ListGatewayNetworksRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
@@ -638,15 +669,15 @@
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
             options.stop = (
-                lambda res: res.status not in GATEWAYNETWORK_TRANSIENT_STATUSES
+                lambda res: res.status not in GATEWAY_NETWORK_TRANSIENT_STATUSES
             )
 
         return await wait_for_resource_async(
             fetcher=self.get_gateway_network,
             options=options,
             args={
                 "gateway_network_id": gateway_network_id,
@@ -673,17 +704,21 @@
         :param gateway_id: Public Gateway to connect.
         :param private_network_id: Private Network to connect.
         :param enable_masquerade: Note: this setting is ignored when passing `ipam_config`.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param enable_dhcp: Defaults to `true` if either `dhcp_id` or `dhcp` are present. If set to `true`, either `dhcp_id` or `dhcp` must be present.
         Note: this setting is ignored when passing `ipam_config`.
         :param dhcp_id: ID of an existing DHCP configuration object to use for this GatewayNetwork.
+        One-Of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address', 'ipam_config' could be set.
         :param dhcp: New DHCP configuration object to use for this GatewayNetwork.
+        One-Of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address', 'ipam_config' could be set.
         :param address: Static IP address in CIDR format to to use without DHCP.
+        One-Of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address', 'ipam_config' could be set.
         :param ipam_config: Note: all or none of the GatewayNetworks for a single gateway can use the IPAM. DHCP and IPAM configurations cannot be mixed. Some products may require that the Public Gateway uses the IPAM, to ensure correct functionality.
+        One-Of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address', 'ipam_config' could be set.
         :return: :class:`GatewayNetwork <GatewayNetwork>`
 
         Usage:
         ::
 
             result = await api.create_gateway_network(
                 gateway_id="example",
@@ -732,16 +767,19 @@
         Update the configuration parameters of a connection between a given Public Gateway and Private Network (the connection = a GatewayNetwork). Updatable parameters include DHCP settings and whether to enable traffic masquerade (dynamic NAT).
         :param gateway_network_id: ID of the GatewayNetwork to update.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param enable_masquerade: Note: this setting is ignored when passing `ipam_config`.
         :param enable_dhcp: Defaults to `true` if `dhcp_id` is present. If set to `true`, `dhcp_id` must be present.
         Note: this setting is ignored when passing `ipam_config`.
         :param dhcp_id: ID of the new DHCP configuration object to use with this GatewayNetwork.
+        One-Of ('ip_config'): at most one of 'dhcp_id', 'address', 'ipam_config' could be set.
         :param address: New static IP address.
+        One-Of ('ip_config'): at most one of 'dhcp_id', 'address', 'ipam_config' could be set.
         :param ipam_config: Note: all or none of the GatewayNetworks for a single gateway can use the IPAM. DHCP and IPAM configurations cannot be mixed. Some products may require that the Public Gateway uses the IPAM, to ensure correct functionality.
+        One-Of ('ip_config'): at most one of 'dhcp_id', 'address', 'ipam_config' could be set.
         :return: :class:`GatewayNetwork <GatewayNetwork>`
 
         Usage:
         ::
 
             result = await api.update_gateway_network(
                 gateway_network_id="example",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/content.py` & `scaleway_async-2.1.0/scaleway_async/vpcgw/v1/content.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 from typing import List
 
 from .types import (
     GatewayNetworkStatus,
     GatewayStatus,
 )
 
-GATEWAYNETWORK_TRANSIENT_STATUSES: List[GatewayNetworkStatus] = [
+GATEWAY_NETWORK_TRANSIENT_STATUSES: List[GatewayNetworkStatus] = [
     GatewayNetworkStatus.ATTACHING,
     GatewayNetworkStatus.CONFIGURING,
     GatewayNetworkStatus.DETACHING,
 ]
 """
 Lists transient statutes of the enum :class:`GatewayNetworkStatus <GatewayNetworkStatus>`.
 """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/vpcgw/v1/marshalling.py`

 * *Files 3% similar despite different names*

```diff
@@ -79,18 +79,22 @@
     field = data.get("pool_low", None)
     if field is not None:
         args["pool_low"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("pool_high", None)
     if field is not None:
         args["pool_high"] = field
 
     field = data.get("enable_dynamic", None)
     if field is not None:
@@ -119,22 +123,28 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("valid_lifetime", None)
     if field is not None:
         args["valid_lifetime"] = field
+    else:
+        args["valid_lifetime"] = None
 
     field = data.get("renew_timer", None)
     if field is not None:
         args["renew_timer"] = field
+    else:
+        args["renew_timer"] = None
 
     field = data.get("rebind_timer", None)
     if field is not None:
         args["rebind_timer"] = field
+    else:
+        args["rebind_timer"] = None
 
     return DHCP(**args)
 
 
 def unmarshal_IpamConfig(data: Any) -> IpamConfig:
     if not isinstance(data, dict):
         raise TypeError(
@@ -173,22 +183,28 @@
     field = data.get("private_network_id", None)
     if field is not None:
         args["private_network_id"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("mac_address", None)
     if field is not None:
         args["mac_address"] = field
+    else:
+        args["mac_address"] = None
 
     field = data.get("enable_masquerade", None)
     if field is not None:
         args["enable_masquerade"] = field
 
     field = data.get("status", None)
     if field is not None:
@@ -201,22 +217,28 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("dhcp", None)
     if field is not None:
         args["dhcp"] = unmarshal_DHCP(field)
+    else:
+        args["dhcp"] = None
 
     field = data.get("address", None)
     if field is not None:
         args["address"] = field
+    else:
+        args["address"] = None
 
     field = data.get("ipam_config", None)
     if field is not None:
         args["ipam_config"] = unmarshal_IpamConfig(field)
+    else:
+        args["ipam_config"] = None
 
     return GatewayNetwork(**args)
 
 
 def unmarshal_IP(data: Any) -> IP:
     if not isinstance(data, dict):
         raise TypeError(
@@ -248,26 +270,34 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("reverse", None)
     if field is not None:
         args["reverse"] = field
+    else:
+        args["reverse"] = None
 
     field = data.get("gateway_id", None)
     if field is not None:
         args["gateway_id"] = field
+    else:
+        args["gateway_id"] = None
 
     return IP(**args)
 
 
 def unmarshal_DHCPEntry(data: Any) -> DHCPEntry:
     if not isinstance(data, dict):
         raise TypeError(
@@ -292,29 +322,33 @@
     if field is not None:
         args["ip_address"] = field
 
     field = data.get("hostname", None)
     if field is not None:
         args["hostname"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return DHCPEntry(**args)
 
 
 def unmarshal_GatewayType(data: Any) -> GatewayType:
     if not isinstance(data, dict):
         raise TypeError(
@@ -354,33 +388,39 @@
     if field is not None:
         args["organization_id"] = field
 
     field = data.get("project_id", None)
     if field is not None:
         args["project_id"] = field
 
-    field = data.get("status", None)
-    if field is not None:
-        args["status"] = field
-
-    field = data.get("name", None)
-    if field is not None:
-        args["name"] = field
-
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = unmarshal_GatewayType(field)
+    else:
+        args["type_"] = None
+
+    field = data.get("status", None)
+    if field is not None:
+        args["status"] = field
+
+    field = data.get("name", None)
+    if field is not None:
+        args["name"] = field
 
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("gateway_networks", None)
     if field is not None:
@@ -392,41 +432,51 @@
     if field is not None:
         args["upstream_dns_servers"] = field
 
     field = data.get("bastion_enabled", None)
     if field is not None:
         args["bastion_enabled"] = field
 
+    field = data.get("ip", None)
+    if field is not None:
+        args["ip"] = unmarshal_IP(field)
+    else:
+        args["ip"] = None
+
+    field = data.get("version", None)
+    if field is not None:
+        args["version"] = field
+    else:
+        args["version"] = None
+
+    field = data.get("can_upgrade_to", None)
+    if field is not None:
+        args["can_upgrade_to"] = field
+    else:
+        args["can_upgrade_to"] = None
+
     field = data.get("bastion_port", None)
     if field is not None:
         args["bastion_port"] = field
 
     field = data.get("smtp_enabled", None)
     if field is not None:
         args["smtp_enabled"] = field
 
     field = data.get("is_legacy", None)
     if field is not None:
         args["is_legacy"] = field
 
-    field = data.get("zone", None)
+    field = data.get("ip_mobility_enabled", None)
     if field is not None:
-        args["zone"] = field
+        args["ip_mobility_enabled"] = field
 
-    field = data.get("ip", None)
-    if field is not None:
-        args["ip"] = unmarshal_IP(field)
-
-    field = data.get("version", None)
-    if field is not None:
-        args["version"] = field
-
-    field = data.get("can_upgrade_to", None)
+    field = data.get("zone", None)
     if field is not None:
-        args["can_upgrade_to"] = field
+        args["zone"] = field
 
     return Gateway(**args)
 
 
 def unmarshal_PATRule(data: Any) -> PATRule:
     if not isinstance(data, dict):
         raise TypeError(
@@ -462,18 +512,22 @@
     field = data.get("zone", None)
     if field is not None:
         args["zone"] = field
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     return PATRule(**args)
 
 
 def unmarshal_ListDHCPEntriesResponse(data: Any) -> ListDHCPEntriesResponse:
     if not isinstance(data, dict):
         raise TypeError(
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/vpcgw/v1/types.py` & `scaleway_async-2.1.0/scaleway_async/vpcgw/v1/types.py`

 * *Files 0% similar despite different names*

```diff
@@ -533,24 +533,14 @@
     """
 
     project_id: str
     """
     Owning Project.
     """
 
-    status: GatewayStatus
-    """
-    Current status of the gateway.
-    """
-
-    name: str
-    """
-    Name of the gateway.
-    """
-
     created_at: Optional[datetime]
     """
     Gateway creation date.
     """
 
     updated_at: Optional[datetime]
     """
@@ -558,14 +548,24 @@
     """
 
     type_: Optional[GatewayType]
     """
     Gateway type (commercial offer).
     """
 
+    status: GatewayStatus
+    """
+    Current status of the gateway.
+    """
+
+    name: str
+    """
+    Name of the gateway.
+    """
+
     tags: List[str]
     """
     Tags associated with the gateway.
     """
 
     gateway_networks: List[GatewayNetwork]
     """
@@ -578,47 +578,52 @@
     """
 
     bastion_enabled: bool
     """
     Defines whether SSH bastion is enabled on the gateway.
     """
 
-    bastion_port: int
+    ip: Optional[IP]
     """
-    Port of the SSH bastion.
+    Public IP address of the gateway.
     """
 
-    smtp_enabled: bool
+    version: Optional[str]
     """
-    Defines whether SMTP traffic is allowed to pass through the gateway.
+    Version of the running gateway software.
     """
 
-    is_legacy: bool
+    can_upgrade_to: Optional[str]
     """
-    Whether this uses non-IPAM IP configurations.
+    Newly available gateway software version that can be updated to.
     """
 
-    zone: Zone
+    bastion_port: int
     """
-    Zone of the gateway.
+    Port of the SSH bastion.
     """
 
-    ip: Optional[IP]
+    smtp_enabled: bool
     """
-    Public IP address of the gateway.
+    Defines whether SMTP traffic is allowed to pass through the gateway.
     """
 
-    version: Optional[str]
+    is_legacy: bool
     """
-    Version of the running gateway software.
+    Defines whether the gateway uses non-IPAM IP configurations.
     """
 
-    can_upgrade_to: Optional[str]
+    ip_mobility_enabled: bool
     """
-    Newly available gateway software version that can be updated to.
+    Defines whether the gateway uses routed IPs (IP mobility) instead of NAT IPs.
+    """
+
+    zone: Zone
+    """
+    Zone of the gateway.
     """
 
 
 @dataclass
 class PATRule:
     id: str
     """
@@ -962,14 +967,27 @@
     """
 
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
+
+@dataclass
+class EnableIPMobilityRequest:
+    gateway_id: str
+    """
+    ID of the gateway to upgrade to IP mobility.
+    """
+
+    zone: Optional[Zone]
+    """
+    Zone to target. If none is passed will use default zone from the config.
+    """
+
 
 @dataclass
 class GetDHCPEntryRequest:
     dhcp_entry_id: str
     """
     ID of the DHCP entry to fetch.
     """
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/webhosting/v1alpha1/__init__.py` & `scaleway_async-2.1.0/scaleway_async/webhosting/v1alpha1/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 from .types import ListHostingsRequestOrderBy
 from .types import ListOffersRequestOrderBy
 from .types import NameserverStatus
 from .types import OfferQuotaWarning
 from .types import HostingCpanelUrls
 from .types import HostingOption
 from .types import OfferProduct
+from .types import CreateHostingRequestDomainConfiguration
 from .types import DnsRecord
 from .types import Nameserver
 from .types import ControlPanel
 from .types import Hosting
 from .types import Offer
 from .types import CreateHostingRequest
 from .types import DeleteHostingRequest
@@ -43,14 +44,15 @@
     "ListHostingsRequestOrderBy",
     "ListOffersRequestOrderBy",
     "NameserverStatus",
     "OfferQuotaWarning",
     "HostingCpanelUrls",
     "HostingOption",
     "OfferProduct",
+    "CreateHostingRequestDomainConfiguration",
     "DnsRecord",
     "Nameserver",
     "ControlPanel",
     "Hosting",
     "Offer",
     "CreateHostingRequest",
     "DeleteHostingRequest",
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/webhosting/v1alpha1/api.py` & `scaleway_async-2.1.0/scaleway_async/webhosting/v1alpha1/api.py`

 * *Files 4% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 )
 from .types import (
     HostingStatus,
     ListHostingsRequestOrderBy,
     ListOffersRequestOrderBy,
     ControlPanel,
     CreateHostingRequest,
+    CreateHostingRequestDomainConfiguration,
     DnsRecords,
     Hosting,
     ListControlPanelsResponse,
     ListHostingsResponse,
     ListOffersResponse,
     UpdateHostingRequest,
 )
@@ -34,14 +35,17 @@
     unmarshal_DnsRecords,
     unmarshal_ListControlPanelsResponse,
     unmarshal_ListHostingsResponse,
     unmarshal_ListOffersResponse,
     marshal_CreateHostingRequest,
     marshal_UpdateHostingRequest,
 )
+from ...std.types import (
+    LanguageCode as StdLanguageCode,
+)
 
 
 class WebhostingV1Alpha1API(API):
     """
     Web Hosting API.
     """
 
@@ -51,25 +55,29 @@
         offer_id: str,
         domain: str,
         region: Optional[Region] = None,
         project_id: Optional[str] = None,
         email: Optional[str] = None,
         tags: Optional[List[str]] = None,
         option_ids: Optional[List[str]] = None,
+        language: Optional[StdLanguageCode] = None,
+        domain_configuration: Optional[CreateHostingRequestDomainConfiguration] = None,
     ) -> Hosting:
         """
         Order a Web Hosting plan.
         Order a Web Hosting plan, specifying the offer type required via the `offer_id` parameter.
         :param offer_id: ID of the selected offer for the Web Hosting plan.
         :param domain: Domain name to link to the Web Hosting plan. You must already own this domain name, and have completed the DNS validation process beforehand.
         :param region: Region to target. If none is passed will use default region from the config.
         :param project_id: ID of the Scaleway Project in which to create the Web Hosting plan.
         :param email: Contact email for the Web Hosting client.
         :param tags: List of tags for the Web Hosting plan.
         :param option_ids: IDs of any selected additional options for the Web Hosting plan.
+        :param language: Default language for the control panel interface.
+        :param domain_configuration: Indicates whether to update hosting domain name servers and DNS records for domains managed by Scaleway Elements.
         :return: :class:`Hosting <Hosting>`
 
         Usage:
         ::
 
             result = await api.create_hosting(
                 offer_id="example",
@@ -89,14 +97,16 @@
                     offer_id=offer_id,
                     domain=domain,
                     region=region,
                     project_id=project_id,
                     email=email,
                     tags=tags,
                     option_ids=option_ids,
+                    language=language,
+                    domain_configuration=domain_configuration,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Hosting(res.json())
@@ -289,24 +299,26 @@
         *,
         hosting_id: str,
         region: Optional[Region] = None,
         email: Optional[str] = None,
         tags: Optional[List[str]] = None,
         option_ids: Optional[List[str]] = None,
         offer_id: Optional[str] = None,
+        protected: Optional[bool] = None,
     ) -> Hosting:
         """
         Update a Web Hosting plan.
         Update the details of one of your existing Web Hosting plans, specified by its `hosting_id`. You can update parameters including the contact email address, tags, options and offer.
         :param hosting_id: Hosting ID.
         :param region: Region to target. If none is passed will use default region from the config.
         :param email: New contact email for the Web Hosting plan.
         :param tags: New tags for the Web Hosting plan.
         :param option_ids: IDs of the new options for the Web Hosting plan.
         :param offer_id: ID of the new offer for the Web Hosting plan.
+        :param protected: Whether the hosting is protected or not.
         :return: :class:`Hosting <Hosting>`
 
         Usage:
         ::
 
             result = await api.update_hosting(
                 hosting_id="example",
@@ -325,14 +337,15 @@
                 UpdateHostingRequest(
                     hosting_id=hosting_id,
                     region=region,
                     email=email,
                     tags=tags,
                     option_ids=option_ids,
                     offer_id=offer_id,
+                    protected=protected,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Hosting(res.json())
@@ -444,23 +457,25 @@
         self,
         *,
         without_options: bool,
         only_options: bool,
         region: Optional[Region] = None,
         order_by: Optional[ListOffersRequestOrderBy] = None,
         hosting_id: Optional[str] = None,
+        control_panels: Optional[List[str]] = None,
     ) -> ListOffersResponse:
         """
         List all offers.
         List the different Web Hosting offers, and their options, available to order from Scaleway.
         :param without_options: Defines whether the response should consist of offers only, without options.
         :param only_options: Defines whether the response should consist of options only, without offers.
         :param region: Region to target. If none is passed will use default region from the config.
         :param order_by: Sort order of offers in the response.
         :param hosting_id: ID of a Web Hosting plan, to check compatibility with returned offers (in case of wanting to update the plan).
+        :param control_panels: Name of the control panel to filter for.
         :return: :class:`ListOffersResponse <ListOffersResponse>`
 
         Usage:
         ::
 
             result = await api.list_offers(
                 without_options=False,
@@ -472,14 +487,15 @@
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
             f"/webhosting/v1alpha1/regions/{param_region}/offers",
             params={
+                "control_panels": control_panels,
                 "hosting_id": hosting_id,
                 "only_options": only_options,
                 "order_by": order_by,
                 "without_options": without_options,
             },
         )
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/webhosting/v1alpha1/marshalling.py` & `scaleway_async-2.1.0/scaleway_async/webhosting/v1alpha1/marshalling.py`

 * *Files 6% similar despite different names*

```diff
@@ -18,14 +18,15 @@
     DnsRecords,
     ControlPanel,
     ListControlPanelsResponse,
     ListHostingsResponse,
     OfferProduct,
     Offer,
     ListOffersResponse,
+    CreateHostingRequestDomainConfiguration,
     CreateHostingRequest,
     UpdateHostingRequest,
 )
 
 
 def unmarshal_HostingCpanelUrls(data: Any) -> HostingCpanelUrls:
     if not isinstance(data, dict):
@@ -108,22 +109,28 @@
     field = data.get("tags", None)
     if field is not None:
         args["tags"] = field
 
     field = data.get("updated_at", None)
     if field is not None:
         args["updated_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["updated_at"] = None
 
     field = data.get("created_at", None)
     if field is not None:
         args["created_at"] = parser.isoparse(field) if isinstance(field, str) else field
+    else:
+        args["created_at"] = None
 
     field = data.get("platform_number", None)
     if field is not None:
         args["platform_number"] = field
+    else:
+        args["platform_number"] = None
 
     field = data.get("options", None)
     if field is not None:
         args["options"] = (
             [unmarshal_HostingOption(v) for v in field] if field is not None else None
         )
 
@@ -139,21 +146,43 @@
     if field is not None:
         args["offer_end_of_life"] = field
 
     field = data.get("control_panel_name", None)
     if field is not None:
         args["control_panel_name"] = field
 
+    field = data.get("platform_group", None)
+    if field is not None:
+        args["platform_group"] = field
+
+    field = data.get("ipv4", None)
+    if field is not None:
+        args["ipv4"] = field
+
+    field = data.get("ipv6", None)
+    if field is not None:
+        args["ipv6"] = field
+
+    field = data.get("protected", None)
+    if field is not None:
+        args["protected"] = field
+
+    field = data.get("one_time_password", None)
+    if field is not None:
+        args["one_time_password"] = field
+
     field = data.get("region", None)
     if field is not None:
         args["region"] = field
 
     field = data.get("cpanel_urls", None)
     if field is not None:
         args["cpanel_urls"] = unmarshal_HostingCpanelUrls(field)
+    else:
+        args["cpanel_urls"] = None
 
     return Hosting(**args)
 
 
 def unmarshal_DnsRecord(data: Any) -> DnsRecord:
     if not isinstance(data, dict):
         raise TypeError(
@@ -162,15 +191,15 @@
 
     args: Dict[str, Any] = {}
 
     field = data.get("name", None)
     if field is not None:
         args["name"] = field
 
-    field = data.get("type_", None)
+    field = data.get("type", None)
     if field is not None:
         args["type_"] = field
 
     field = data.get("ttl", None)
     if field is not None:
         args["ttl"] = field
 
@@ -181,14 +210,16 @@
     field = data.get("status", None)
     if field is not None:
         args["status"] = field
 
     field = data.get("priority", None)
     if field is not None:
         args["priority"] = field
+    else:
+        args["priority"] = None
 
     return DnsRecord(**args)
 
 
 def unmarshal_Nameserver(data: Any) -> Nameserver:
     if not isinstance(data, dict):
         raise TypeError(
@@ -388,18 +419,22 @@
     field = data.get("control_panel_name", None)
     if field is not None:
         args["control_panel_name"] = field
 
     field = data.get("product", None)
     if field is not None:
         args["product"] = unmarshal_OfferProduct(field)
+    else:
+        args["product"] = None
 
     field = data.get("price", None)
     if field is not None:
         args["price"] = unmarshal_Money(field)
+    else:
+        args["price"] = None
 
     return Offer(**args)
 
 
 def unmarshal_ListOffersResponse(data: Any) -> ListOffersResponse:
     if not isinstance(data, dict):
         raise TypeError(
@@ -413,14 +448,35 @@
         args["offers"] = (
             [unmarshal_Offer(v) for v in field] if field is not None else None
         )
 
     return ListOffersResponse(**args)
 
 
+def marshal_CreateHostingRequestDomainConfiguration(
+    request: CreateHostingRequestDomainConfiguration,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.update_nameservers is not None:
+        output["update_nameservers"] = request.update_nameservers
+
+    if request.update_web_record is not None:
+        output["update_web_record"] = request.update_web_record
+
+    if request.update_mail_record is not None:
+        output["update_mail_record"] = request.update_mail_record
+
+    if request.update_all_records is not None:
+        output["update_all_records"] = request.update_all_records
+
+    return output
+
+
 def marshal_CreateHostingRequest(
     request: CreateHostingRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
     output: Dict[str, Any] = {}
 
     if request.offer_id is not None:
@@ -437,14 +493,24 @@
 
     if request.tags is not None:
         output["tags"] = request.tags
 
     if request.option_ids is not None:
         output["option_ids"] = request.option_ids
 
+    if request.language is not None:
+        output["language"] = str(request.language)
+
+    if request.domain_configuration is not None:
+        output["domain_configuration"] = (
+            marshal_CreateHostingRequestDomainConfiguration(
+                request.domain_configuration, defaults
+            ),
+        )
+
     return output
 
 
 def marshal_UpdateHostingRequest(
     request: UpdateHostingRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
@@ -458,8 +524,11 @@
 
     if request.option_ids is not None:
         output["option_ids"] = request.option_ids
 
     if request.offer_id is not None:
         output["offer_id"] = request.offer_id
 
+    if request.protected is not None:
+        output["protected"] = request.protected
+
     return output
```

### Comparing `scaleway_async-2.0.0.dev6/scaleway_async/webhosting/v1alpha1/types.py` & `scaleway_async-2.1.0/scaleway_async/billing/v2beta1/types.py`

 * *Files 22% similar despite different names*

```diff
@@ -5,656 +5,606 @@
 from dataclasses import dataclass
 from datetime import datetime
 from enum import Enum
 from typing import List, Optional
 
 from scaleway_core.bridge import (
     Money,
-    Region,
 )
 from scaleway_core.utils import (
     StrEnumMeta,
 )
 
 
-class DnsRecordStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_STATUS = "unknown_status"
-    VALID = "valid"
-    INVALID = "invalid"
+class DiscountDiscountMode(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_DISCOUNT_MODE = "unknown_discount_mode"
+    DISCOUNT_MODE_RATE = "discount_mode_rate"
+    DISCOUNT_MODE_VALUE = "discount_mode_value"
+    DISCOUNT_MODE_SPLITTABLE = "discount_mode_splittable"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class DnsRecordType(str, Enum, metaclass=StrEnumMeta):
+class DiscountFilterType(str, Enum, metaclass=StrEnumMeta):
     UNKNOWN_TYPE = "unknown_type"
-    A = "a"
-    CNAME = "cname"
-    MX = "mx"
-    TXT = "txt"
-    NS = "ns"
-    AAAA = "aaaa"
+    CATEGORY_NAME = "category_name"
+    PRODUCT_NAME = "product_name"
+    PRODUCT_RANGE = "product_range"
+    RESOURCE_NAME = "resource_name"
+    REGION = "region"
+    ZONE = "zone"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class DnsRecordsStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN = "unknown"
-    VALID = "valid"
-    INVALID = "invalid"
+class DownloadInvoiceRequestFileType(str, Enum, metaclass=StrEnumMeta):
+    PDF = "pdf"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class HostingDnsStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_DNS_STATUS = "unknown_dns_status"
-    VALID = "valid"
-    INVALID = "invalid"
+class ExportInvoicesRequestFileType(str, Enum, metaclass=StrEnumMeta):
+    CSV = "csv"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class HostingStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_STATUS = "unknown_status"
-    DELIVERING = "delivering"
-    READY = "ready"
-    DELETING = "deleting"
-    ERROR = "error"
-    LOCKED = "locked"
-    MIGRATING = "migrating"
+class ExportInvoicesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    INVOICE_NUMBER_DESC = "invoice_number_desc"
+    INVOICE_NUMBER_ASC = "invoice_number_asc"
+    START_DATE_DESC = "start_date_desc"
+    START_DATE_ASC = "start_date_asc"
+    ISSUED_DATE_DESC = "issued_date_desc"
+    ISSUED_DATE_ASC = "issued_date_asc"
+    DUE_DATE_DESC = "due_date_desc"
+    DUE_DATE_ASC = "due_date_asc"
+    TOTAL_UNTAXED_DESC = "total_untaxed_desc"
+    TOTAL_UNTAXED_ASC = "total_untaxed_asc"
+    TOTAL_TAXED_DESC = "total_taxed_desc"
+    TOTAL_TAXED_ASC = "total_taxed_asc"
+    INVOICE_TYPE_DESC = "invoice_type_desc"
+    INVOICE_TYPE_ASC = "invoice_type_asc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListHostingsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
+class InvoiceType(str, Enum, metaclass=StrEnumMeta):
+    UNKNOWN_TYPE = "unknown_type"
+    PERIODIC = "periodic"
+    PURCHASE = "purchase"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListOffersRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
-    PRICE_ASC = "price_asc"
+class ListConsumptionsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    UPDATED_AT_DESC = "updated_at_desc"
+    UPDATED_AT_ASC = "updated_at_asc"
+    CATEGORY_NAME_DESC = "category_name_desc"
+    CATEGORY_NAME_ASC = "category_name_asc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class NameserverStatus(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_STATUS = "unknown_status"
-    VALID = "valid"
-    INVALID = "invalid"
+class ListDiscountsRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    CREATION_DATE_DESC = "creation_date_desc"
+    CREATION_DATE_ASC = "creation_date_asc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class OfferQuotaWarning(str, Enum, metaclass=StrEnumMeta):
-    UNKNOWN_QUOTA_WARNING = "unknown_quota_warning"
-    EMAIL_COUNT_EXCEEDED = "email_count_exceeded"
-    DATABASE_COUNT_EXCEEDED = "database_count_exceeded"
-    DISK_USAGE_EXCEEDED = "disk_usage_exceeded"
+class ListInvoicesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    INVOICE_NUMBER_DESC = "invoice_number_desc"
+    INVOICE_NUMBER_ASC = "invoice_number_asc"
+    START_DATE_DESC = "start_date_desc"
+    START_DATE_ASC = "start_date_asc"
+    ISSUED_DATE_DESC = "issued_date_desc"
+    ISSUED_DATE_ASC = "issued_date_asc"
+    DUE_DATE_DESC = "due_date_desc"
+    DUE_DATE_ASC = "due_date_asc"
+    TOTAL_UNTAXED_DESC = "total_untaxed_desc"
+    TOTAL_UNTAXED_ASC = "total_untaxed_asc"
+    TOTAL_TAXED_DESC = "total_taxed_desc"
+    TOTAL_TAXED_ASC = "total_taxed_asc"
+    INVOICE_TYPE_DESC = "invoice_type_desc"
+    INVOICE_TYPE_ASC = "invoice_type_asc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-@dataclass
-class HostingCpanelUrls:
-    dashboard: str
+class ListTaxesRequestOrderBy(str, Enum, metaclass=StrEnumMeta):
+    UPDATED_AT_DESC = "updated_at_desc"
+    UPDATED_AT_ASC = "updated_at_asc"
+    CATEGORY_NAME_DESC = "category_name_desc"
+    CATEGORY_NAME_ASC = "category_name_asc"
 
-    webmail: str
+    def __str__(self) -> str:
+        return str(self.value)
 
 
 @dataclass
-class HostingOption:
-    id: str
+class DiscountCoupon:
+    description: Optional[str]
     """
-    Option ID.
-    """
-
-    name: str
-    """
-    Option name.
+    The description of the coupon.
     """
 
 
 @dataclass
-class OfferProduct:
-    name: str
+class DiscountFilter:
+    type_: DiscountFilterType
     """
-    Product name.
+    Type of the filter (category name, product name, product range, resource name, region or zone).
     """
 
-    option: bool
+    value: str
     """
-    Product option.
+    Value of filter.
     """
 
-    email_accounts_quota: int
+
+@dataclass
+class ListConsumptionsResponseConsumption:
+    product_name: str
     """
-    Limit number of email accounts.
+    The product name. For example, "VPC Public Gateway S", "VPC Public Gateway M" for the VPC product.
     """
 
-    email_storage_quota: int
+    resource_name: str
     """
-    Limit quantity of email storage in gigabytes.
+    Identifies the reference based on the category.
     """
 
-    databases_quota: int
+    sku: str
     """
-    Limit number of databases.
+    Unique identifier of the product.
     """
 
-    hosting_storage_quota: int
+    project_id: str
     """
-    Limit quantity of hosting storage in gigabytes.
+    Project ID of the consumption.
     """
 
-    support_included: bool
+    category_name: str
     """
-    Whether or not support is included.
+    Name of consumption category.
     """
 
-    v_cpu: int
+    unit: str
     """
-    Limit number of virtual CPU.
+    Unit of consumed quantity.
     """
 
-    ram: int
+    billed_quantity: str
     """
-    Limit quantity of memory in gigabytes.
+    Consumed quantity.
     """
 
-    max_addon_domains: int
+    value: Optional[Money]
     """
-    Limit number of add-on domains.
+    Monetary value of the consumption.
     """
 
 
 @dataclass
-class DnsRecord:
-    name: str
+class Discount:
+    id: str
     """
-    Record name.
+    The ID of the discount.
     """
 
-    type_: DnsRecordType
+    organization_id: str
     """
-    Record type.
+    The organization ID of the discount.
     """
 
-    ttl: int
+    description: str
     """
-    Record time-to-live.
+    The description of the discount.
     """
 
-    value: str
+    value: float
     """
-    Record value.
+    The initial value of the discount.
     """
 
-    status: DnsRecordStatus
+    value_used: float
     """
-    Record status.
+    The value indicating how much of the discount has been used.
     """
 
-    priority: Optional[int]
+    value_remaining: float
     """
-    Record priority level.
+    The remaining value of the discount.
     """
 
-
-@dataclass
-class Nameserver:
-    hostname: str
+    mode: DiscountDiscountMode
     """
-    Hostname of the nameserver.
+    The mode of the discount.
     """
 
-    status: NameserverStatus
+    filters: List[DiscountFilter]
     """
-    Status of the nameserver.
+    List of the discount scopes.
     """
 
-    is_default: bool
+    creation_date: Optional[datetime]
     """
-    Defines whether the nameserver is the default one.
+    The creation date of the discount.
     """
 
-
-@dataclass
-class ControlPanel:
-    name: str
+    start_date: Optional[datetime]
     """
-    Control panel name.
+    The start date of the discount.
     """
 
-    available: bool
+    stop_date: Optional[datetime]
     """
-    Define if the control panel type is available to order.
+    The stop date of the discount.
     """
 
-    logo_url: str
+    coupon: Optional[DiscountCoupon]
     """
-    URL of this control panel's logo.
+    The description of the coupon.
     """
 
 
 @dataclass
-class Hosting:
+class Invoice:
     id: str
     """
-    ID of the Web Hosting plan.
+    Invoice ID.
     """
 
     organization_id: str
-    """
-    ID of the Scaleway Organization the Web Hosting plan belongs to.
-    """
 
-    project_id: str
-    """
-    ID of the Scaleway Project the Web Hosting plan belongs to.
-    """
+    organization_name: str
 
-    status: HostingStatus
+    start_date: Optional[datetime]
     """
-    Status of the Web Hosting plan.
+    Start date of the billing period.
     """
 
-    platform_hostname: str
-    """
-    Hostname of the host platform.
-    """
+    stop_date: Optional[datetime]
 
-    offer_id: str
+    billing_period: Optional[datetime]
     """
-    ID of the active offer for the Web Hosting plan.
+    The billing period of the invoice in the YYYY-MM format.
     """
 
-    offer_name: str
+    issued_date: Optional[datetime]
     """
-    Name of the active offer for the Web Hosting plan.
+    Date when the invoice was sent to the customer.
     """
 
-    domain: str
+    due_date: Optional[datetime]
     """
-    Main domain associated with the Web Hosting plan.
+    Payment time limit, set according to the Organization's payment conditions.
     """
 
-    tags: List[str]
+    type_: InvoiceType
     """
-    List of tags associated with the Web Hosting plan.
+    Type of invoice, either periodic or purchase.
     """
 
-    updated_at: Optional[datetime]
-    """
-    Date on which the Web Hosting plan was last updated.
-    """
-
-    created_at: Optional[datetime]
-    """
-    Date on which the Web Hosting plan was created.
-    """
-
-    platform_number: Optional[int]
+    state: str
     """
-    Number of the host platform.
+    The state of the Invoice.
     """
 
-    options: List[HostingOption]
+    number: int
     """
-    Array of any options activated for the Web Hosting plan.
+    Invoice number.
     """
 
-    dns_status: HostingDnsStatus
+    seller_name: str
     """
-    DNS status of the Web Hosting plan.
+    The name of the seller (Scaleway).
     """
 
-    username: str
+    total_untaxed: Optional[Money]
     """
-    Main Web Hosting cPanel username.
+    Total amount, untaxed.
     """
 
-    offer_end_of_life: bool
+    total_taxed: Optional[Money]
     """
-    Indicates if the hosting offer has reached its end of life.
+    Total amount, taxed.
     """
 
-    control_panel_name: str
+    total_tax: Optional[Money]
     """
-    Name of the control panel.
+    The total tax amount of the invoice.
     """
 
-    region: Region
+    total_discount: Optional[Money]
     """
-    Region where the Web Hosting plan is hosted.
+    The total discount amount of the invoice.
     """
 
-    cpanel_urls: Optional[HostingCpanelUrls]
+    total_undiscount: Optional[Money]
     """
-    URL to connect to cPanel dashboard and to Webmail interface.
+    The total amount of the invoice before applying the discount.
     """
 
 
 @dataclass
-class Offer:
-    id: str
-    """
-    Offer ID.
-    """
-
-    billing_operation_path: str
+class ListTaxesResponseTax:
+    description: str
     """
-    Unique identifier used for billing.
+    Description of the tax applied.
     """
 
-    available: bool
+    currency: str
     """
-    If a hosting_id was specified in the call, defines whether this offer is available for that Web Hosting plan to migrate (update) to.
+    The three-letter currency code.
     """
 
-    quota_warnings: List[OfferQuotaWarning]
+    rate: Optional[float]
     """
-    Quota warnings, if the offer is not available for the specified hosting_id.
+    Applied tax rate (0.2 means a VAT of 20%).
     """
 
-    end_of_life: bool
+    total_tax_value: Optional[float]
     """
-    Indicates if the offer has reached its end of life.
+    The total tax value of the consumption.
     """
 
-    control_panel_name: str
-    """
-    Name of the control panel.
-    """
 
-    product: Optional[OfferProduct]
+@dataclass
+class DownloadInvoiceRequest:
+    invoice_id: str
     """
-    Product constituting this offer.
+    Invoice ID.
     """
 
-    price: Optional[Money]
+    file_type: Optional[DownloadInvoiceRequestFileType]
     """
-    Price of this offer.
+    File type. PDF by default.
     """
 
 
 @dataclass
-class CreateHostingRequest:
-    offer_id: str
+class ExportInvoicesRequest:
+    organization_id: Optional[str]
     """
-    ID of the selected offer for the Web Hosting plan.
+    Organization ID. If specified, only invoices from this Organization will be returned.
     """
 
-    domain: str
+    billing_period_start_after: Optional[datetime]
     """
-    Domain name to link to the Web Hosting plan. You must already own this domain name, and have completed the DNS validation process beforehand.
+    Return only invoice with start date greater than billing_period_start.
     """
 
-    region: Optional[Region]
+    billing_period_start_before: Optional[datetime]
     """
-    Region to target. If none is passed will use default region from the config.
+    Return only invoice with start date less than billing_period_start.
     """
 
-    project_id: Optional[str]
+    invoice_type: Optional[InvoiceType]
     """
-    ID of the Scaleway Project in which to create the Web Hosting plan.
+    Invoice type. It can either be `periodic` or `purchase`.
     """
 
-    email: Optional[str]
+    page: Optional[int]
     """
-    Contact email for the Web Hosting client.
+    Page number.
     """
 
-    tags: Optional[List[str]]
+    page_size: Optional[int]
     """
-    List of tags for the Web Hosting plan.
+    Positive integer lower or equal to 100 to select the number of items to return.
     """
 
-    option_ids: Optional[List[str]]
+    order_by: Optional[ExportInvoicesRequestOrderBy]
     """
-    IDs of any selected additional options for the Web Hosting plan.
+    How invoices are ordered in the response.
     """
 
-
-@dataclass
-class DeleteHostingRequest:
-    hosting_id: str
+    file_type: Optional[ExportInvoicesRequestFileType]
     """
-    Hosting ID.
+    File format for exporting the invoice list.
     """
 
-    region: Optional[Region]
+
+@dataclass
+class GetInvoiceRequest:
+    invoice_id: str
     """
-    Region to target. If none is passed will use default region from the config.
+    Invoice ID.
     """
 
 
 @dataclass
-class DnsRecords:
-    records: List[DnsRecord]
+class ListConsumptionsRequest:
+    order_by: Optional[ListConsumptionsRequestOrderBy]
     """
-    List of DNS records.
+    Order consumptions list in the response by their update date.
     """
 
-    name_servers: List[Nameserver]
+    page: Optional[int]
     """
-    List of nameservers.
+    Positive integer to choose the page to return.
     """
 
-    status: DnsRecordsStatus
+    page_size: Optional[int]
     """
-    Status of the records.
+    Positive integer lower or equal to 100 to select the number of items to return.
     """
 
-
-@dataclass
-class GetDomainDnsRecordsRequest:
-    domain: str
+    category_name: Optional[str]
     """
-    Domain associated with the DNS records.
+    Filter by name of a Category as they are shown in the invoice (Compute, Network, Observability).
     """
 
-    region: Optional[Region]
+    billing_period: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    Filter by the billing period in the YYYY-MM format. If it is empty the current billing period will be used as default.
     """
 
+    organization_id: Optional[str]
 
-@dataclass
-class GetHostingRequest:
-    hosting_id: str
-    """
-    Hosting ID.
-    """
-
-    region: Optional[Region]
-    """
-    Region to target. If none is passed will use default region from the config.
-    """
+    project_id: Optional[str]
 
 
 @dataclass
-class ListControlPanelsRequest:
-    region: Optional[Region]
-    """
-    Region to target. If none is passed will use default region from the config.
-    """
-
-    page: Optional[int]
+class ListConsumptionsResponse:
+    consumptions: List[ListConsumptionsResponseConsumption]
     """
-    Page number to return, from the paginated results (must be a positive integer).
+    Detailed consumption list.
     """
 
-    page_size: Optional[int]
+    total_count: int
     """
-    Number of control panels to return (must be a positive integer lower or equal to 100).
+    Total number of returned items.
     """
 
-
-@dataclass
-class ListControlPanelsResponse:
-    total_count: int
+    total_discount_untaxed_value: float
     """
-    Number of control panels returned.
+    Sum of all discounts, displayed only when no category or project ID filter is applied.
     """
 
-    control_panels: List[ControlPanel]
+    updated_at: Optional[datetime]
     """
-    List of control panels.
+    Last consumption update date.
     """
 
 
 @dataclass
-class ListHostingsRequest:
-    region: Optional[Region]
+class ListDiscountsRequest:
+    order_by: Optional[ListDiscountsRequestOrderBy]
     """
-    Region to target. If none is passed will use default region from the config.
+    Order discounts in the response by their description.
     """
 
     page: Optional[int]
     """
-    Page number to return, from the paginated results (must be a positive integer).
+    Positive integer to choose the page to return.
     """
 
     page_size: Optional[int]
     """
-    Number of Web Hosting plans to return (must be a positive integer lower or equal to 100).
+    Positive integer lower or equal to 100 to select the number of items to return.
     """
 
-    order_by: Optional[ListHostingsRequestOrderBy]
+    organization_id: Optional[str]
     """
-    Sort order for Web Hosting plans in the response.
+    ID of the organization.
     """
 
-    tags: Optional[List[str]]
-    """
-    Tags to filter for, only Web Hosting plans with matching tags will be returned.
-    """
 
-    statuses: Optional[List[HostingStatus]]
+@dataclass
+class ListDiscountsResponse:
+    total_count: int
     """
-    Statuses to filter for, only Web Hosting plans with matching statuses will be returned.
+    Total number of discounts.
     """
 
-    domain: Optional[str]
+    discounts: List[Discount]
     """
-    Domain to filter for, only Web Hosting plans associated with this domain will be returned.
+    Paginated returned discounts.
     """
 
-    project_id: Optional[str]
-    """
-    Project ID to filter for, only Web Hosting plans from this Project will be returned.
-    """
 
+@dataclass
+class ListInvoicesRequest:
     organization_id: Optional[str]
     """
-    Organization ID to filter for, only Web Hosting plans from this Organization will be returned.
+    Organization ID. If specified, only invoices from this Organization will be returned.
     """
 
-    control_panels: Optional[List[str]]
+    billing_period_start_after: Optional[datetime]
     """
-    Name of the control panel to filter for, only Web Hosting plans from this control panel will be returned.
+    Return only invoice with start date greater than billing_period_start.
     """
 
-
-@dataclass
-class ListHostingsResponse:
-    total_count: int
+    billing_period_start_before: Optional[datetime]
     """
-    Number of Web Hosting plans returned.
+    Return only invoice with start date less than billing_period_start.
     """
 
-    hostings: List[Hosting]
+    invoice_type: Optional[InvoiceType]
     """
-    List of Web Hosting plans.
+    Invoice type. It can either be `periodic` or `purchase`.
     """
 
-
-@dataclass
-class ListOffersRequest:
-    without_options: bool
+    page: Optional[int]
     """
-    Defines whether the response should consist of offers only, without options.
+    Page number.
     """
 
-    only_options: bool
+    page_size: Optional[int]
     """
-    Defines whether the response should consist of options only, without offers.
+    Positive integer lower or equal to 100 to select the number of items to return.
     """
 
-    region: Optional[Region]
+    order_by: Optional[ListInvoicesRequestOrderBy]
     """
-    Region to target. If none is passed will use default region from the config.
+    How invoices are ordered in the response.
     """
 
-    order_by: Optional[ListOffersRequestOrderBy]
-    """
-    Sort order of offers in the response.
-    """
 
-    hosting_id: Optional[str]
+@dataclass
+class ListInvoicesResponse:
+    total_count: int
     """
-    ID of a Web Hosting plan, to check compatibility with returned offers (in case of wanting to update the plan).
+    Total number of invoices.
     """
 
-
-@dataclass
-class ListOffersResponse:
-    offers: List[Offer]
+    invoices: List[Invoice]
     """
-    List of offers.
+    Paginated returned invoices.
     """
 
 
 @dataclass
-class RestoreHostingRequest:
-    hosting_id: str
+class ListTaxesRequest:
+    order_by: Optional[ListTaxesRequestOrderBy]
     """
-    Hosting ID.
+    Order consumed taxes list in the response by their update date.
     """
 
-    region: Optional[Region]
+    page: Optional[int]
     """
-    Region to target. If none is passed will use default region from the config.
+    Page number.
     """
 
-
-@dataclass
-class UpdateHostingRequest:
-    hosting_id: str
+    page_size: Optional[int]
     """
-    Hosting ID.
+    Positive integer lower or equal to 100 to select the number of items to return.
     """
 
-    region: Optional[Region]
+    organization_id: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    Filter by Organization ID.
     """
 
-    email: Optional[str]
+    billing_period: Optional[str]
     """
-    New contact email for the Web Hosting plan.
+    Filter by the billing period in the YYYY-MM format. If it is empty the current billing period will be used as default.
     """
 
-    tags: Optional[List[str]]
+
+@dataclass
+class ListTaxesResponse:
+    taxes: List[ListTaxesResponseTax]
     """
-    New tags for the Web Hosting plan.
+    Detailed consumption tax.
     """
 
-    option_ids: Optional[List[str]]
+    total_count: int
     """
-    IDs of the new options for the Web Hosting plan.
+    Total number of returned items.
     """
 
-    offer_id: Optional[str]
+    updated_at: Optional[datetime]
     """
-    ID of the new offer for the Web Hosting plan.
+    Last consumption update date.
     """
```

### Comparing `scaleway_async-2.0.0.dev6/PKG-INFO` & `scaleway_async-2.1.0/PKG-INFO`

 * *Files 13% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: scaleway-async
-Version: 2.0.0.dev6
+Version: 2.1.0
 Summary: Scaleway SDK for Python
 License: BSD
 Author: Scaleway
 Author-email: opensource@scaleway.com
 Requires-Python: >=3.8,<4.0
 Classifier: Development Status :: 3 - Alpha
 Classifier: Environment :: Console
@@ -19,12 +19,12 @@
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
 Classifier: Programming Language :: Python :: 3.4
 Classifier: Programming Language :: Python :: 3.5
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Topic :: Software Development
-Requires-Dist: scaleway-core (==2.0.0.dev6)
+Requires-Dist: scaleway-core (==2.1.0)
 Description-Content-Type: text/markdown
 
 # Scaleway Python SDK - Async
```

